<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-14T04:13:23.381Z</updated>
  <id>http://example.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STM32CubeMX-Keil 通用配置</title>
    <link href="http://example.com/2023/04/11/054-STM32-%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/04/11/054-STM32-%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2023-04-11T22:48:07.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<p>在实际项目开发中，我们会发现，有很多配置是通用的，有很多代码是复用的。本文总结了 STM32CubeMX 和 Keil5 MDK 的一些通用设置，以供 STM32 项目开发时查阅，帮助开发者快速配置好所需环境。</p><h3 id="STM32CubeMX-通用配置"><a href="#STM32CubeMX-通用配置" class="headerlink" title="STM32CubeMX 通用配置"></a>STM32CubeMX 通用配置</h3><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>打开 STM32CubeMX 软件，点击 <code>ACCESS TO MCU SELECTOR</code>，在左上搜索框输入芯片型号（如 <code>429ig</code>），在右下角选择自己的芯片，右上角点击 <code>Start Project</code>。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404220608706.png" alt="image-20230404220608706" style="zoom:70%;" /><center>图 1.1 芯片型号选择</center><h4 id="配置-SYS"><a href="#配置-SYS" class="headerlink" title="配置 SYS"></a>配置 SYS</h4><p><code>Debug</code> 选择 <code>Serial Wire(SW)</code>。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404220953836.png" alt="image-20230404220953836" style="zoom: 102%;" /><center>图 1.2 SYS 配置</center><h4 id="配置-RCC"><a href="#配置-RCC" class="headerlink" title="配置 RCC"></a>配置 RCC</h4><p><code>HSE</code> 选择 <code>Crystal/Ceramic Resonator</code>。</p><p>打开 <code>Clock Configuration</code> 界面，配置如图，选择 <code>HSE</code> 和 <code>PLLCLK</code>，在 <code>HCLK(MHz)</code> 框中输入 168 后回车，自动配置所有数据。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404221647685.png" alt="image-20230404221647685" style="zoom:99%;" /><center>图 1.3 RCC 配置</center><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404221440617.png" alt="image-20230404221440617" style="zoom: 83%;" /><center>图 1.4 Clock Configuration 界面配置</center><h4 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h4><p>配置包括工程名称、存储位置、IDE 选择、代码生成等选项，如下图所示。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404222946177.png" alt="image-20230404222946177" style="zoom:87%;" /><center>图 1.5 工程文件名称等配置</center><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404222803173.png" alt="image-20230404222803173" style="zoom:87%;" /><center>图 1.6 代码生成配置</center><h4 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h4><p>右上角点击 <code>GENERATE CODE</code>，接着点击 <code>Close</code>。（如果直接点 <code>Open Project</code>，Keil5 中没有代码提示。）</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411231055330.png" alt="image-20230411231055330" style="zoom:75%;" /><center>图 1.7 生成代码操作</center><h3 id="Keil5-MDK-通用配置"><a href="#Keil5-MDK-通用配置" class="headerlink" title="Keil5 MDK 通用配置"></a>Keil5 MDK 通用配置</h3><h4 id="打开项目工程文件"><a href="#打开项目工程文件" class="headerlink" title="打开项目工程文件"></a>打开项目工程文件</h4><p>找到存储位置，路径：<code>E:\Data\DuoJi\TEST\MDK-ARM</code>，双击打开 <code>xxx.uvprojx</code> 文件。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404225006620.png" alt="image-20230404225006620" style="zoom:111%;" /><center>图 2.1 项目工程文件位置</center><h4 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h4><p>打开项目后的第一件事：编译代码，关联出头文件。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411232200457.png" alt="image-20230411232200457" style="zoom:131%;" /><center>图 2.2 编译代码</center><h4 id="仿真器连接配置"><a href="#仿真器连接配置" class="headerlink" title="仿真器连接配置"></a>仿真器连接配置</h4><p>点击 <code>魔法棒</code> → <code>Debug</code> → 选择 <code>DAP</code> → <code>Setting</code>，可以看到已经识别到了芯片。然后点击 <code>Flash Download</code> → <code>Reset and Run</code>，为了能够下载进程序后，就开始运行代码，不用手动再去点一下复位键。配置完成后，点 <code>OK</code>。</p><table><thead><tr><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411232411409.png" alt="image-20230411232411409" style="zoom:80%;" /></th><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411232537940.png" alt="image-20230411232537940" style="zoom:95%;" /></th></tr></thead><tbody><tr><td align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411232702468.png" alt="image-20230411232702468"></td><td align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411233154977.png" alt="image-20230411233154977"></td></tr></tbody></table><center>图 2.3 仿真器连接配置</center><h4 id="下载程序"><a href="#下载程序" class="headerlink" title="下载程序"></a>下载程序</h4><p>写完代码后，先编译一下，再下载到开发板。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411233442568.png" alt="image-20230411233442568" style="zoom:120%;" /><center>图 2.4 下载程序流程</center><h3 id="宏定义-LED-灯"><a href="#宏定义-LED-灯" class="headerlink" title="宏定义 LED 灯"></a>宏定义 LED 灯</h3><p>写在 <code>main.c</code> 文件中的 main() 函数外。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET) <span class="comment">//LED0 亮</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET) <span class="comment">//LED0 灭</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET) <span class="comment">//LED1 亮</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET) <span class="comment">//LED1 灭</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1) <span class="comment">//LED0 闪烁</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0) <span class="comment">//LED1 闪烁</span></span></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure><h3 id="宏定义按键"><a href="#宏定义按键" class="headerlink" title="宏定义按键"></a>宏定义按键</h3><p>写在 <code>main.c</code> 文件中的 main() 函数外。判断按键是否按下，使用 <code>if(KEY0 == 0)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY2 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)</span></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在实际项目开发中，我们会发现，有很多配置是通用的，有很多代码是复用的。本文总结了 STM32CubeMX 和 Keil5 MDK 的一些通用设置，以供 STM32 项目开发时查阅，帮助开发者快速配置好所需环境。&lt;/p&gt;
&lt;h3 id=&quot;STM32CubeMX-通用配置&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="STM32" scheme="http://example.com/categories/STM32/"/>
    
    
    <category term="Keil5" scheme="http://example.com/tags/Keil5/"/>
    
    <category term="CubeMX" scheme="http://example.com/tags/CubeMX/"/>
    
  </entry>
  
  <entry>
    <title>成为点灯大师 LEDMaster</title>
    <link href="http://example.com/2023/04/11/058-%E6%88%90%E4%B8%BA%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88-LEDMaster/"/>
    <id>http://example.com/2023/04/11/058-%E6%88%90%E4%B8%BA%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88-LEDMaster/</id>
    <published>2023-04-11T22:43:13.000Z</published>
    <updated>2023-04-14T04:13:23.385Z</updated>
    
    <content type="html"><![CDATA[<p>孔乙己说回字有四种写法，而使用 STM32 点灯可不止有四种方式。本文利用 STM32F429IGT6 + STM32CubeMX + Keil5，通过各种外设，实现多种点灯方式。</p><blockquote><p>本系列代码均已开源至 Github，欢迎 Fork&amp;Star。</p></blockquote><h3 id="例程-1：使用-GPIO-点灯"><a href="#例程-1：使用-GPIO-点灯" class="headerlink" title="例程 1：使用 GPIO 点灯"></a>例程 1：使用 GPIO 点灯</h3><p><strong>要求</strong>：利用 STM32CubeMX 和 Keil5 MDK 进行 STM32 应用开发，完成以下功能。</p><ul><li>实现 LED0、LED1 闪烁。</li></ul><p><strong>步骤</strong>：</p><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code> <sup>[1]</sup>创建工程、后。在可视化界面的搜索框中输入 PB1，即可快速定位到引脚位置。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404223950257.png" alt="image-20230404223950257" style="zoom:57%;" /><center>图 1.1 引脚位置</center><ol start="2"><li>点击该引脚，可以看到多个选项，选择 <code>GPIO_Output</code>。PB0 与 PB 1 两个引脚都选上，使用中的引脚会变成绿色。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404224314725.png" alt="image-20230404224314725" style="zoom:72%;" /><center>图 1.2 LED 灯引脚配置</center><ol start="3"><li><p><strong>生成代码</strong>。</p></li><li><p>按路径打开工程文件。按照 <code>Keil5 MDK 通用配置</code> <sup>[1]</sup>完成后开始编写代码。</p><p>打开 <code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* LED1 配置 */</span></span><br><span class="line">    <span class="comment">/* 输入低电平，点亮 LED1 */</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);</span><br><span class="line">    HAL_Delay(<span class="number">200</span>);</span><br><span class="line">    <span class="comment">/* 输入高电平，熄灭 LED1 */</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);</span><br><span class="line">    HAL_Delay(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* LED0 配置 */</span></span><br><span class="line">    <span class="comment">/* 翻转电平，使 LED0 闪烁*/</span></span><br><span class="line">    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);</span><br><span class="line">    HAL_Delay(<span class="number">200</span>);</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure></li><li><p><strong>下载程序</strong>。</p></li></ol><h3 id="例程-2：使用按键点灯"><a href="#例程-2：使用按键点灯" class="headerlink" title="例程 2：使用按键点灯"></a>例程 2：使用按键点灯</h3><p><strong>要求</strong>：利用 STM32CubeMX 和 Keil5 MDK 进行 STM32 应用开发，完成以下功能：</p><ol><li>按下 KEY0（PH3）按键，松开后，切换 LED0（PB1）的开关状态。</li><li>按下 KEY1（PH2）按键，切换 LED1（PB0）的开关状态。</li><li>按下 KEY2（PC13）按键，把点亮的 LED 灯全部关闭。</li></ol><p><strong>步骤</strong>：</p><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code><sup>[1]</sup>完成后。将 PB0、PB1 引脚设置为 <code>GPIO_Output</code>，将 PH3、PH2、PC13 引脚设置为 <code>GPIO_Input</code>。</li></ol><table><thead><tr><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406124013141.png" alt="image-20230406124013141"></th><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406124026659.png" alt="image-20230406124026659"></th><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406124041053.png" alt="image-20230406124041053"></th></tr></thead></table><center>图 2.1 LED 灯与按键引脚配置</center><ol start="2"><li>将 PH3、PH2、PC13 的 GPIO 都改为上拉（Pull-up）。（<strong>注</strong>：将GPIO口设置为上拉输入模式，意思是当GPIO口没有外部信号输入时，将其上拉到高电平（即VCC电源电压）状态，从而避免GPIO口悬浮，导致输入不稳定或产生噪声。）</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406130602990.png" alt="image-20230406130602990" style="zoom:80%;" /><center>图 2.2 GPIO 引脚配置</center><ol start="3"><li><p><strong>生成代码</strong>。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> 完成后开始编写代码。</p><p>① 打开 <code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HAL_Delay() 经常会导致程序卡死，自己写一个延时函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能函数：扫描按键 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scan_Keys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 配置 KEY0--LED0*/</span></span><br><span class="line">    <span class="comment">/* 原理：由于将按键引脚全部配置为上拉，所以按下时会产生低电平(RESET)，检测到低电平执行下面程序 */</span></span><br><span class="line">    <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3) == GPIO_PIN_RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay(<span class="number">1000</span>); <span class="comment">//去抖动，防止误触</span></span><br><span class="line">        <span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3) == GPIO_PIN_RESET)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* while() 是为了保证按下后进入循环，直到松开，程序才会向下执行，即松开后切换 LED0 的状态 */</span></span><br><span class="line">            <span class="keyword">while</span>(HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3) == GPIO_PIN_RESET);</span><br><span class="line">            HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure><p>② 在 <code>main</code> 函数中执行 <code>Scan_Keys</code> 功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Scan_Keys();</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>宏定义</strong>：当执行到 KEY0 时，就会去找到 KEY0 的定义并执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIO_PIN_RESET 已经被定义好了为 0，相应的 GPIO_PIN_SET = 1。 */</span></span><br><span class="line"><span class="comment">/* 右键点击 GPIO_PIN_RESET，选择 Go To Definition of &#x27;GPIO_PIN_RESET&#x27; 可以看到源码如下: */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   GPIO_PIN_RESET = <span class="number">0</span>,</span><br><span class="line">   GPIO_PIN_SET</span><br><span class="line">&#125;GPIO_PinState;</span><br></pre></td></tr></table></figure><p>（补充知识）可以在 <code>gpio.c</code> 文件中通过结构体来配置引脚。</p></blockquote><p>① 完整代码。延时程序和扫描按键功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY2 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HAL_Delay() 经常会导致程序卡死，自己写一个延时函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能函数：扫描按键 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scan_Keys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 原理：由于将按键引脚全部配置为上拉，所以按下时会产生低电平(RESET)，检测到低电平执行下面程序 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置 KEY0--LED0*/</span></span><br><span class="line">    <span class="keyword">if</span>(KEY0 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay(<span class="number">1000</span>); <span class="comment">//去抖动，防止误触</span></span><br><span class="line">        <span class="keyword">if</span>(KEY0 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* while() 是为了保证按下并抬起只执行一次程序，如果一直按着，那么就一直都是低电平，程序就不会向下执行 */</span></span><br><span class="line">            <span class="keyword">while</span>(KEY0 == <span class="number">0</span>);</span><br><span class="line">            HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置 KEY1--LED1*/</span></span><br><span class="line">    <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay(<span class="number">1000</span>); <span class="comment">//去抖动，防止误触</span></span><br><span class="line">        <span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_0);</span><br><span class="line">            <span class="keyword">while</span>(KEY1 == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置 KEY3--LED0|LED1 */</span></span><br><span class="line">    <span class="keyword">if</span>(KEY2 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay(<span class="number">1000</span>); <span class="comment">//去抖动，防止误触</span></span><br><span class="line">        <span class="keyword">if</span>(KEY2 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(KEY2 == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure><p>② 在 <code>main</code> 函数的 while 中实现扫描按键功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Scan_Keys();</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure></li><li><p><strong>下载程序</strong>。</p></li></ol><h3 id="例程-3：使用外部中断点灯"><a href="#例程-3：使用外部中断点灯" class="headerlink" title="例程 3：使用外部中断点灯"></a>例程 3：使用外部中断点灯</h3><p><strong>要求</strong>：利用 STM32CubeMX 和 Keil5 进行 STM32 应用开发，完成以下功能：</p><ol><li>将 KEY0（PH3） 设置为外部中断输入，下降沿触发。在中断服务函数中，切换 LED0（PB1）的开关状态。</li><li>将 KEY1（PH2） 设置为外部中断输入，上升沿触发。在中断服务函数中，切换 LED1（PB0） 的开关状态。</li></ol><p><strong>步骤</strong>：</p><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code> 完成后。将 PB0、PB1 引脚设置为 <code>GPIO_Output</code>，将 PH3、PH2 引脚设置为 <code>GPIO_EXTI3</code>。</li></ol><table><thead><tr><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406213714766.png" alt="image-20230406213714766"  /></th><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406213957774.png" alt="image-20230406213957774"></th></tr></thead></table><center>图 3.1 LED 灯与按键引脚配置</center><ol start="2"><li>在 <code>GPIO</code> 中将 PH2、PH3 的配置都改为上拉（Pull-up）。同时，PH3 的 <code>GPIO mode</code> 改为外部中断下降沿触发，PH2 的 <code>GPIO mode</code> 改为外部中断上升沿触发。（<strong>注</strong>：上升沿触发指的是当外部中断引脚输入的信号由低电平变为高电平时，触发中断事件；而下降沿触发则指的是当外部中断引脚输入的信号由高电平变为低电平时，触发中断事件。）</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406214723072.png" alt="image-20230406214723072" style="zoom:60%;" /><center>图 3.2 按键引脚中断配置</center><ol start="3"><li>使能中断。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406215450172.png" alt="image-20230406215450172" style="zoom:61%;" /><center>图 3.3 使能中断配置</center><ol start="4"><li><p><strong>生成代码</strong>。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> 完成后开始编写代码。</p><blockquote><p><em>了解代码结构</em>。</p><ol><li><p>打开 <code>main.c</code> 文件，其【main()】函数中，有【MX_GPIO_Init()】语句，表示 GPIO 的初始化，右键点进它的定义。来到 <code>gpio.c</code> 文件，在【MX_GPIO_Init()】函数中可以看到 <em>EXTI interrupt init</em>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_NVIC_SetPriority(EXTI2_IRQn, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//第一行：设置优先级</span></span><br><span class="line">HAL_NVIC_EnableIRQ(EXTI2_IRQn); <span class="comment">//第二行：使能</span></span><br></pre></td></tr></table></figure></li><li><p>打开 <code>stm32f4xx_it.c</code> 文件，拉到最下面，可以看到 PH2、PH3 的中断服务函数【HAL_GPIO_EXTI_IRQHandler()】，右键点进它的定义，来到 <code>stm32f4xx_hal_gpio.c</code> 文件，可以看到在中断服务函数里面，有一个【HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)】函数，右键点进它的定义，来到下面的虚函数【__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)】，可以看到里面什么都没有做，需要重写它。一般将其拷到 <code>main.c</code> 文件中重写。</p></li></ol></blockquote><p>打开 <code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* KEY0--LED0 配置 */</span></span><br><span class="line"><span class="comment">/* 判断传进来的引脚是否为 PH3 */</span></span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == GPIO_PIN_3)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* KEY1--LED1 配置 */</span></span><br><span class="line"><span class="comment">/* 判断传进来的引脚是否为 PH2 */</span></span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == GPIO_PIN_2)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure><h4 id="掌握调试技巧"><a href="#掌握调试技巧" class="headerlink" title="掌握调试技巧"></a>掌握调试技巧</h4><blockquote><ol><li>加断点。在 <code>stm32f4xx_it.c</code> 文件中的【HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3)】前面加上断点。因为我们重写了虚函数，中断响应后，会首先来到这个函数。</li><li>进入调试模式。①全速运行。②按下 KEY0 按键，可以看到代码运行到了函数【HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3)】这里。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406224730587.png" alt="image-20230406224730587" style="zoom:80%;" /><center>图 3.4 调试步骤-1</center><ol start="3"><li>选择单步走，可以看到现在进入了 <code>stm32f4xx_hal_gpio.c</code> 文件中的【HAL_GPIO_EXTI_IRQHandler()】函数中的 if 语句。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406225129219.png" alt="image-20230406225129219" style="zoom:70%;" /><center>图 3.5 调试步骤-2</center><ol start="4"><li>继续单步走。当执行【HAL_GPIO_EXTI_Callback()】回调函数时，进入到了 <code>main.c</code> 文件中。然后继续执行，发现 LED0 发生翻转。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406225710807.png" alt="image-20230406225710807" style="zoom:90%;" /><center>图 3.6 调试步骤-3</center></blockquote></li><li><p><strong>下载程序</strong>。</p></li></ol><h3 id="例程-4：使用定时器中断点灯"><a href="#例程-4：使用定时器中断点灯" class="headerlink" title="例程 4：使用定时器中断点灯"></a>例程 4：使用定时器中断点灯</h3><p><strong>要求</strong>：在 STM32F429 进行 STM32 应用开发，完成以下功能：</p><ol><li><p>利用 TIM2 实现间隔定时，每隔 0.2s 将 LED0（PB1）的开关状态翻转。</p></li><li><p>利用 TIM3 实现间隔定时，每隔 1s 将 LED1（PB0）的开关状态翻转。</p></li></ol><blockquote><p><em>计算公式</em>：定时器发生中断的时间</p><p>定时时间 &#x3D; （PSC + 1）*（ARR + 1）&#x2F; 定时器时钟频率</p><ul><li>PSC：Prescaler，预分频器</li><li>ARR：重装载值，写在 Counter Period 中。</li></ul><p><em>练习题</em>：时钟信号频率 1KHz，PSC &#x3D; 9，ARR &#x3D; 999，求定时时间。</p><ul><li><p><code>9</code> 的意思是预分频器接收 10 个脉冲就会溢出。如下图，一个脉冲 1ms，PSC 每接收到 10 个脉冲，也就是 10ms，传给主计数器一次。</p></li><li><p><code>999</code> 的意思是主计数器的最大计数值为 1000。如下图，PSC 传给主机数器一个脉冲是 10ms，主计数器一共能接收 1000 个，也就是 10000ms &#x3D; 10s，然后传给内核。</p></li><li><p>综上所述，此处是每 10s 产生一次中断。</p></li></ul><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20221024105011992.png" alt="img" style="zoom:80%;" /><center>图 4.1 计算过程</center></blockquote><p><strong>步骤</strong>：</p><ol><li><p>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code> 完成后，操作通用计时器 TIM2、TIM3。</p><blockquote><p>计算：时钟频率为 84MHz，</p><ul><li>TIM2：$ \frac{8400\times2\times10^3}{84\times10^6}&#x3D;0.2s&#x3D;200ms $</li><li>TIM3：$ \frac{8400\times1\times10^4}{84\times10^6}&#x3D;1s $</li></ul></blockquote></li></ol><table><thead><tr><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406234448736.png" alt="image-20230406234448736"></th><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230406234557793.png" alt="image-20230406234557793"></th></tr></thead></table><center>图 4.2 TIM2&3 配置</center><ol start="2"><li>使能 NVIC 中断。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230407104212315.png" alt="image-20230407104212315" style="zoom:120%;" /><center>图 4.3 NVIC 使能</center><ol start="3"><li>配置 GPIO 向 LED 灯输出高低电平。（同 <code>例程 1：使用 GPIO 点灯</code> 第 2 步）</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404224314725.png" alt="image-20230404224314725" style="zoom: 66%;" /><center>图 4.4 LED 灯引脚配置</center><ol start="3"><li><p><strong>生成代码</strong>。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> 完成后开始编写代码。</p><blockquote><p>写中断服务函数，需要先找到对应的虚函数。</p><ul><li>打开 <code>stm32f4xx_it.c</code> 文件，拉到最下面，可以看到 TIM2、TIM3 的中断服务函数【HAL_TIM_IRQHandler(&amp;htim2)、HAL_TIM_IRQHandler(&amp;htim3)】。随便右键点一个进入定义，来到 <code>stm32f4xx_hal_tim.c</code> 文件中，在【HAL_TIM_IRQHandler()】函数中，有很多复杂的功能，找到定时器中断回调函数【HAL_TIM_PeriodElapsedCallback(htim)】，右键点进定义，将原型拷贝到 <code>main.c</code> 文件中。</li></ul><p>开启定时器中断。</p><ul><li>打开 <code>stm32f4xxhal_hal_tim.c</code> 文件，（在 400~500 行之间）找到【HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)】函数，将其拷贝到 <code>main.c</code> 文件中，在【main】函数中初始化。</li></ul></blockquote><p>打开 <code>main.c</code> 文件。</p><p>① 在【main】函数外重写中断服务函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TIM2--LED0 */</span></span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance == TIM2)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* TIM3--LED1 */</span></span><br><span class="line">    <span class="keyword">if</span>(htim-&gt;Instance == TIM3)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure><p>② 在【main】函数中开启定时器中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim3);</span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure></li><li><p><strong>下载代码</strong>。</p></li></ol><h3 id="例程-5：使用定时器输出-PWM-实现呼吸灯"><a href="#例程-5：使用定时器输出-PWM-实现呼吸灯" class="headerlink" title="例程 5：使用定时器输出 PWM 实现呼吸灯"></a>例程 5：使用定时器输出 PWM 实现呼吸灯</h3><p><strong>要求</strong>：在 STM32F429 进行 STM32 应用开发，完成以下功能：</p><ul><li>利用 TIM3 输出 PWM 信号，使 LED0、LED1 变成呼吸灯效果。</li></ul><p><strong>步骤</strong>：</p><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code> 完成后。将 PB0、PB1 引脚分别设置为 <code>TIM3_CH3</code>、<code>TIM3_CH4</code>。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404234417624.png" alt="image-20230404234417624" style="zoom:72%;" /><center>图 5.1 LED 灯引脚配置</center><ol start="2"><li>配置 TIM3 的 CH3、CH4，完成后可以看到右边 PB0、PB1 引脚变为绿色。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230404234944897.png" alt="image-20230404234944897" style="zoom:58%;" /><center>图 5.2 TIM3 Channel 配置</center><ol start="3"><li><p><strong>生成代码</strong>。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> 完成后开始编写代码。</p><p>打开 <code>main.c</code> 文件。在 <code>main</code> 函数中开启 PWM。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_4);</span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure><p>输出 PWM。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** LED0 配置 **/</span></span><br><span class="line">    <span class="comment">/* LED0 逐渐熄灭 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> pwmVal=<span class="number">0</span>; pwmVal&lt;<span class="number">1000</span>; pwmVal++)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_4, pwmVal);</span><br><span class="line">        HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* LED0 逐渐点亮 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> pwmVal=<span class="number">1000</span>; pwmVal&gt;<span class="number">0</span>; pwmVal--)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_4, pwmVal);</span><br><span class="line">        HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** LED1 配置 **/</span></span><br><span class="line">    <span class="comment">/* LED1 逐渐熄灭 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> pwmVal=<span class="number">0</span>; pwmVal&lt;<span class="number">1000</span>; pwmVal++)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_3, pwmVal);</span><br><span class="line">        HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* LED1 逐渐点亮 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> pwmVal=<span class="number">1000</span>; pwmVal&gt;<span class="number">0</span>; pwmVal--)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_3, pwmVal);</span><br><span class="line">        HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure></li><li><p><strong>下载代码</strong>。</p></li></ol><h3 id="例程-6：使用串口通信点灯"><a href="#例程-6：使用串口通信点灯" class="headerlink" title="例程 6：使用串口通信点灯"></a>例程 6：使用串口通信点灯</h3><p><strong>要求</strong>：在 STM32F429IGT6 中进行 STM32 应用开发，完成以下功能。</p><ul><li>开机后，向串口 1 发送”Hello World!”。</li><li>串口 1 收到字节指令”0xA1”，打开 LED0（PB1），发送”LED0 Opened!”。</li><li>串口 1 收到字节指令”0xA2”，关闭 LED0（PB0），发送”LED0 Closed!”。</li><li>在串口发送过程中，打开 LED1 作为发送数据指示灯。</li></ul><p><strong>步骤</strong>：</p><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code>配置完成后。将 PB0、PB1 引脚分别设置为 <code>GPIO_Out</code>。接着配置 USART1 的模式、参数及使能中断，中断的<strong>优先级</strong>设置为 1，如图所示：</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410152306321.png" alt="image-20230410152306321" style="zoom:45%;" /><center>图 6.1 串口 USART1 配置</center><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230413114558206.png" alt="image-20230413114558206" style="zoom:87%;" /><center>图 6.2 使能 USART1 中断</center><ol start="2"><li><p><strong>生成代码</strong>。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> 完成后开始编写代码。</p><blockquote><p>打开 <code>usart1.c</code> 文件，可以看到 huart1 的配置。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410153414008.png" alt="image-20230410153414008" style="zoom:;" /><center>图 6.3 USART1 的代码初始化</center></blockquote><p>打开 <code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 LED0、LED1 亮灭 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首先定义了无符号 8 位整数型（unsigned 8-bit integer）数组的语句，常用于表示一串 ASCII 字符。其中，Tx_str1 是数组的名称，方括号中没有指定数组长度，因此该数组长度将根据初始化时赋值的元素个数进行确定 */</span></span><br><span class="line"><span class="type">uint8_t</span> Tx_str1[] = <span class="string">&quot;Hello World!\r\n&quot;</span>; <span class="comment">// \r：回车，\n：换行</span></span><br><span class="line"><span class="type">uint8_t</span> Tx_str2[] = <span class="string">&quot;LED1 Opened!\r\n&quot;</span>;</span><br><span class="line"><span class="type">uint8_t</span> Tx_str3[] = <span class="string">&quot;LED1 Closed!\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义了一个无符号8位整数型（unsigned 8-bit integer）变量,通常用于存储通过UART接收到的单个字节数据，每次接收完成后将数据存储到该变量中 */</span></span><br><span class="line"><span class="type">uint8_t</span> Rx_dat = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 中断回调函数, 在这里面实现接收到指令后的功能*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Rx_dat == <span class="number">0xa1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED0_ON();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */</span></span><br><span class="line">LED1_OFF();</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, Tx_str2, <span class="keyword">sizeof</span>(Tx_str2), <span class="number">10000</span>);</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">LED1_ON();</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Rx_dat == <span class="number">0xa2</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED0_OFF();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */</span></span><br><span class="line">LED1_OFF();</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, Tx_str3, <span class="keyword">sizeof</span>(Tx_str3), <span class="number">10000</span>);</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">LED1_ON();</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数内↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能 1：开机后向串口 1 发送 “Hello World!” */</span></span><br><span class="line"><span class="comment">/* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */</span></span><br><span class="line">LED1_OFF();</span><br><span class="line">HAL_Delay(<span class="number">200</span>); <span class="comment">//加入延时函数，以便肉眼观察得到</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, Tx_str1, <span class="keyword">sizeof</span>(Tx_str1), <span class="number">10000</span>);</span><br><span class="line">HAL_Delay(<span class="number">200</span>); <span class="comment">//加入延时函数，以便肉眼观察得到</span></span><br><span class="line">LED1_ON();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能 2、3：接收串口发来的数据” */</span></span><br><span class="line"><span class="comment">/* &amp;huart1 表示指向 UART1 外设的指针，&amp;Rx_dat 表示指向存储接收数据的缓冲区的指针， 1 表示要接收的数据长度 */</span></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span>  </span><br></pre></td></tr></table></figure><blockquote><p><em>串口调试助手操作要点</em></p><ol><li>MicroUSB 接口要接到板子的左下角第二个口，写着 USB_232。才会显示 <code>COM4：USB-SERIAL</code>。<code>COM3</code> 不能用于串口调试。</li><li>波特率要和 CubeMX 中设置的一致。</li><li>在发送框中输入程序中所写的字符串，然后选择 <code>16 进制发送</code>。</li></ol></blockquote></li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410181007350.png" alt="image-20230410181007350" style="zoom:75%;" /><center>图 6.4 功能实现</center><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://storybeginswhen.icu/2023/04/11/059-STM32-%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/" >STM32CubeMX-Keil 通用配置 | Story Begins…… <i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;孔乙己说回字有四种写法，而使用 STM32 点灯可不止有四种方式。本文利用 STM32F429IGT6 + STM32CubeMX + Keil5，通过各种外设，实现多种点灯方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本系列代码均已开源至 Github，欢迎 Fork&amp;</summary>
      
    
    
    
    <category term="STM32" scheme="http://example.com/categories/STM32/"/>
    
    
    <category term="TIM" scheme="http://example.com/tags/TIM/"/>
    
    <category term="USART" scheme="http://example.com/tags/USART/"/>
    
    <category term="ADC" scheme="http://example.com/tags/ADC/"/>
    
    <category term="GPIO" scheme="http://example.com/tags/GPIO/"/>
    
  </entry>
  
  <entry>
    <title>STM32 HAL 库实现 ADC 采样</title>
    <link href="http://example.com/2023/04/11/057-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0-ADC-%E9%87%87%E6%A0%B7/"/>
    <id>http://example.com/2023/04/11/057-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0-ADC-%E9%87%87%E6%A0%B7/</id>
    <published>2023-04-11T16:22:30.000Z</published>
    <updated>2023-04-14T04:13:23.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="例程-1：ADC-单次数据采样与电压换算"><a href="#例程-1：ADC-单次数据采样与电压换算" class="headerlink" title="例程 1：ADC 单次数据采样与电压换算"></a>例程 1：ADC 单次数据采样与电压换算</h3><p><strong>要求</strong>：在 STM32F429IGTx 中进行 STM32 应用开发，完成以下的功能。</p><ul><li>将 ADC_IN0 设置为 12 位 ADC，右对齐，启用中断。</li><li>分别用查询和中断这 2 种方式，每隔 0.5 秒采样一次 ADC 数据。</li><li>将每次读取到的 ADC 采样值转换为对应的电压值，发送到上位机（需用到串口）。</li><li>LED1 作为采样指示灯，在 ADC 转换过程中点亮，其余时间熄灭。LED0 作为系统检测灯常亮。</li></ul><p>【注】配置 GPIO、ADC1、USART1。</p><ol><li>GPIO 比较好配置，就 LED0、LED1 的引脚设为 Output。</li><li>配置 ADC1，PA0 设为 ADC1_IN0，然后勾选 IN0。参数设置模块的 Data Alignment 默认 Right alignment（右对齐）即可，同样其他都默认，NVIC 中断使能勾选。</li><li>配置 USART1，Mode 选 Asynchronous（异步），参数设置模块波特率改为 9600 Bits&#x2F;s，其他默认。由于串口没有用到中断，所以 NVIC 模块不需要使能。</li></ol><p><strong>步骤</strong>：</p><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code><sup>[1]</sup>配置完成后。将 PB0、PB1 引脚分别设置为 <code>GPIO_Out</code>。如图所示：</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411162944353.png" alt="image-20230411162944353" style="zoom:67%;" /><center>图 1.1 LED 灯引脚配置</center><ol start="2"><li>配置 ADC。将 PA0 引脚设置为 <code>ADC1_IN0</code>，然后勾选 <code>ADC1</code>→<code>IN0</code>。如图所示：</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411163909279.png" alt="image-20230411163909279" style="zoom:80%;" /><center>图 1.2 ADC1 引脚、参数配置</center><p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411164125549.png" alt="image-20230411164125549"></p><center>图 1.3 ADC1 中断使能</center><ol start="3"><li>配置串口 USART1。选择异步通信，波特率设置为 9600。配置完成后，PA9、PA10 引脚会自动变成绿色。由于本要求中只写了<strong>将每次读取到的 ADC 采样值转换为对应的电压值，发送到上位机</strong>，且在代码中使用阻塞式发送，因此就没有必要开启中断了。</li></ol><p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411164502352.png" alt="image-20230411164502352"></p><center>图 1.4 USART1 配置</center><ol start="4"><li><p>进行 <code>STM32CubeMX 通用配置</code> <sup>[1]</sup>的第 5 步：生成代码。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> <sup>[1]</sup>完成后开始编写代码。</p><p>打开 <code>main.c</code> 文件。</p><p><strong>方式 1：查询</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 第一步：引入头文件，以使用 sprintf() 函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span> </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 第二步：宏定义 LED 灯开关 */</span>    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第三步-1：定义变量。采样到数据存储在 ADC_Value 中，ADC_Volt 用于运算 */</span></span><br><span class="line"><span class="comment">/* 第三步-2：定义 str_buff[64]，用于向上位机发送数据，用在 sprintf() 函数中 */</span></span><br><span class="line"><span class="type">uint16_t</span> ADC_Value = <span class="number">0</span>, ADC_Volt = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> str_buff[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第五步：写发送数据到上位机的功能函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UR1_Send_Info</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将电压值取余，分别放到个位和小数位上 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span> *)str_buff, <span class="string">&quot;采样值：%d，电压值：%d.%d%d%dv\r\n&quot;</span>, ADC_Value, ADC_Volt/<span class="number">1000</span>, (ADC_Volt%<span class="number">1000</span>)/<span class="number">100</span>, (ADC_Volt%<span class="number">100</span>)/<span class="number">10</span>, ADC_Volt%<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 阻塞式串口发送函数，将缓冲数组 str_buff 发送到上位机，显示在串口调试助手中 */</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, str_buff, <span class="keyword">sizeof</span>(str_buff), <span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第四步-1：查询方式 */</span></span><br><span class="line"><span class="comment">/* 功能函数：采样数据（写完后放在 main() 函数中运行 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC1_Get_Value</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_ADC_Start(&amp;hadc1); <span class="comment">//启动 ADC1</span></span><br><span class="line">LED1_OFF(); <span class="comment">//关闭 LED1，表示 ADC 开始转换</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 判断查询转换函数，如果确实是在转换（HAL_OK），则读 ADC1 的值 */</span></span><br><span class="line"><span class="keyword">if</span>(HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">10</span>) == HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">ADC_Value = HAL_ADC_GetValue(&amp;hadc1); <span class="comment">//得到 ADC1 的值</span></span><br><span class="line">ADC_Volt = ADC_Value * <span class="number">3300</span> / <span class="number">4096</span>; <span class="comment">//计算电压值的转换公式，3300mv = 3.3v，4096 是 2 的 12 次方，因为是 12 位的 ADC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UR1_Send_Info(); <span class="comment">//在上面写此功能函数，一定要写在上面。或者写在下面，但是一定要在上面声明</span></span><br><span class="line">LED1_ON(); <span class="comment">//开启 LED1，表示 ADC 转换完成</span></span><br><span class="line"></span><br><span class="line">HAL_ADC_Stop(&amp;hadc1); <span class="comment">//关闭 ADC1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数内↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*第四步-2，运行该采样功能函数*/</span></span><br><span class="line">    ADC1_Get_Value();</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure><p><strong>方式 2：中断</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 第一步：引入头文件，以使用 sprintf() 函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span> </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 第二步：宏定义 LED 灯开关 */</span>    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第三步-1：定义变量。采样到数据存储在 ADC_Value 中，ADC_Volt 用于运算 */</span></span><br><span class="line"><span class="comment">/* 第三步-2：定义 str_buff[64]，用于向上位机发送数据，用在 sprintf() 函数中 */</span></span><br><span class="line"><span class="type">uint16_t</span> ADC_Value = <span class="number">0</span>, ADC_Volt = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> str_buff[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第五步：写发送数据到上位机的功能函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UR1_Send_Info</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 将电压值取余，分别放到个位和小数位上 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span> *)str_buff, <span class="string">&quot;采样值：%d，电压值：%d.%d%d%dv\r\n&quot;</span>, ADC_Value, ADC_Volt/<span class="number">1000</span>, (ADC_Volt%<span class="number">1000</span>)/<span class="number">100</span>, (ADC_Volt%<span class="number">100</span>)/<span class="number">10</span>, ADC_Volt%<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 阻塞式串口发送函数，将缓冲数组 str_buff 发送到上位机，显示在串口调试助手中 */</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, str_buff, <span class="keyword">sizeof</span>(str_buff), <span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第四步-1：重写 ADC 中断回调函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef* hadc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hadc-&gt;Instance == ADC1) <span class="comment">//如果有多个 ADC，就要先用 if 来判断是不是 ADC1</span></span><br><span class="line">&#123;</span><br><span class="line">ADC_Value = HAL_ADC_GetValue(&amp;hadc1); <span class="comment">//得到 ADC1 的采样值</span></span><br><span class="line">ADC_Volt = ADC_Value * <span class="number">3300</span> / <span class="number">4096</span>; <span class="comment">//转换为电压，3300mv = 3.3v，4096 是 2 的 12 次方，因为是 12 位的 ADC</span></span><br><span class="line">UR1_Send_Info(); <span class="comment">//发送函数，写在了上面</span></span><br><span class="line">LED1_ON(); <span class="comment">//因为在主函数中，LED1 先灭掉了，才启动的中断服务函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数内↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*第四步-2，运行该采样功能函数*/</span></span><br><span class="line">    LED1_OFF(); <span class="comment">//中断启动前关掉 LED1</span></span><br><span class="line">    HAL_ADC_Start_IT(&amp;hadc1); <span class="comment">//以中断方式启动 ADC1</span></span><br><span class="line">    HAL_Delay(<span class="number">500</span>); <span class="comment">//延时 0.5s，然后运行中断回调函数里面的内容（最后一句：LED1 开启）</span></span><br><span class="line">    HAL_ADC_Stop_IT(&amp;hadc1);   <span class="comment">//运行完后关闭 ADC1，然后继续循环</span></span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure></li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411174232128.png" alt="image-20230411174232128" style="zoom:67%;" /><center>图 1.5 串口调试助手接收到的采样数值</center>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;例程-1：ADC-单次数据采样与电压换算&quot;&gt;&lt;a href=&quot;#例程-1：ADC-单次数据采样与电压换算&quot; class=&quot;headerlink&quot; title=&quot;例程 1：ADC 单次数据采样与电压换算&quot;&gt;&lt;/a&gt;例程 1：ADC 单次数据采样与电压换算&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="STM32" scheme="http://example.com/categories/STM32/"/>
    
    
    <category term="HAL" scheme="http://example.com/tags/HAL/"/>
    
    <category term="ADC" scheme="http://example.com/tags/ADC/"/>
    
  </entry>
  
  <entry>
    <title>STM32 HAL 库实现串口通信</title>
    <link href="http://example.com/2023/04/10/056-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/2023/04/10/056-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</id>
    <published>2023-04-10T10:59:03.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h3><p>在 STM32F429IGT6 这块开发板中：</p><ul><li>USART1_TX 与 PA9 复用，USART1_RX 与 PA10 复用。</li><li>USART2_TX 与 PA2 复用，USART2_RX 与 PA3 复用。</li><li>USART3_TX 与 PB10 复用，USART3_RX 与 PB11 复用。</li></ul><h3 id="HAL-库串口发送重要函数"><a href="#HAL-库串口发送重要函数" class="headerlink" title="HAL 库串口发送重要函数"></a>HAL 库串口发送重要函数</h3><ul><li><p><strong>阻塞式发送函数</strong>（<em>新手推荐使用</em>）</p><p>阻塞式发送函数是指在向设备发送数据时，函数会一直阻塞（即一直等待）直到数据发送完毕后才返回。在这种发送方式下，发送函数会一直等待直到发送缓冲区中的数据全部被发送出去，才会返回函数执行结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">unit32_t</span> Timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数解释 */</span></span><br><span class="line">句柄（哪个外设），指针，数据长度，超时时间</span><br></pre></td></tr></table></figure></li><li><p><strong>非阻塞式发送函数</strong>（<em>不推荐使用</em>）</p><p>非阻塞式发送函数是指在向设备发送数据时，不会一直等待数据全部发送完毕后才返回，而是在发送数据时，将数据放入发送缓冲区中，然后立即返回函数执行结果，继续执行后续代码。这种方式下，发送函数不会阻塞当前线程或任务，可以提高系统的实时性和响应能力。但是，需要在发送函数中添加相应的错误处理机制，以避免因为发送过程中出现错误导致数据未发送完成的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以看到这个函数里面多了 IT（interrupt 中断），且没有了 Timeout（超时）参数 */</span></span><br></pre></td></tr></table></figure><p><strong>发送完毕中断回调函数</strong></p><p>发送完毕中断回调函数指的是当使用 UART 或者其他通信方式向外部设备发送数据时，当数据全部发送完毕后，会产生一个发送完成中断（或称为发送完毕中断）。这个中断是外部设备向处理器发送的一种通知，用于告诉处理器数据已经全部发送完成，可以进行其他操作了。当发送完成中断触发时，可以通过调用对应的中断回调函数来处理这个中断事件。中断回调函数是在中断服务程序之后执行的一种特殊函数，它负责处理中断服务程序中未处理完的任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxHalfCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="举个🌰1"><a href="#举个🌰1" class="headerlink" title="举个🌰1"></a>举个🌰1</h4><p><strong>要求</strong>：使用（非）阻塞式的串口发送函数，将发送缓存数组 dat_Txd 中的前 5 个数据发送到 USART1，在数据发送完成后，翻转 PB1（LED0）引脚的输出电平。</p><p><strong>代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用非阻塞式串口 1 发送函数 */</span></span><br><span class="line">HAL_UART_Transmit_IT(&amp;huart1, dat_Txd, <span class="number">5</span>); <span class="comment">//因为 dat_Txd 是数组，前面不用加 &amp;（取地址符号）</span></span><br><span class="line"><span class="comment">/* 发送完成后，使用中断回调函数来控制 LED0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="comment">/* 使用阻塞式串口 1 发送函数 */</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, dat_Txd, <span class="number">5</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="comment">/* 发送完成后，直接使用 Toggle 控制 LED0 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);</span><br></pre></td></tr></table></figure><h3 id="HAL-库串口接收重要函数"><a href="#HAL-库串口接收重要函数" class="headerlink" title="HAL 库串口接收重要函数"></a>HAL 库串口接收重要函数</h3><ul><li><p><strong>阻塞式接收函数</strong>（<em>不推荐使用</em>）</p><p>阻塞式接收函数是指在从设备接收数据时，函数会一直阻塞（即一直等待）直到接收到完整的数据后才返回。在这种接收方式下，接收函数会一直等待直到接收缓冲区中的数据长度达到预定长度，或者接收超时时间到达后才返回函数执行结果。如果接收数据长度过短或者接收速率过慢，会导致阻塞时间较长，从而影响系统的实时性和响应性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">unit32_t</span> Timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 参数解释 */</span></span><br><span class="line">句柄（哪个外设），指针，数据长度，超时时间</span><br></pre></td></tr></table></figure></li><li><p><strong>非阻塞式接收函数</strong>（<em>推荐使用</em>）</p><p>非阻塞式接收函数是指在从设备接收数据时，不会一直等待数据接收完成后才返回，而是在接收数据时，将接收到的数据存入接收缓冲区中，然后立即返回函数执行结果，继续执行后续代码。这种方式下，接收函数不会阻塞当前线程或任务，可以提高系统的实时性和响应能力。但是，需要在接收函数中添加相应的错误处理机制，以避免因为接收过程中出现错误导致数据未接收完成的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以看到这个函数里面多了 IT（interrupt 中断），且没有了 Timeout（超时）参数 */</span></span><br></pre></td></tr></table></figure><p><strong>接收完毕中断回调函数</strong></p><p>接收完毕中断回调函数指的是当使用UART或者其他通信方式接收到完整的数据后，会产生一个接收完成中断（或称为接收完毕中断）。这个中断是外部设备向处理器发送的一种通知，用于告诉处理器数据已经接收完成，可以进行其他操作了。当接收完成中断触发时，可以通过调用对应的中断回调函数来处理这个中断事件。中断回调函数是在中断服务程序之后执行的一种特殊函数，它负责处理中断服务程序中未处理完的任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxHalfCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="举个🌰2"><a href="#举个🌰2" class="headerlink" title="举个🌰2"></a>举个🌰2</h4><p><strong>要求</strong>：使用非阻塞式的串口接收函数，接收USART1中的一个字节，将其保存在 dat_Rxd 变量中，在数据发送完成后，若该字节为 0x5A，则翻转 PB0（LED1） 引脚的输出电平。</p><p><strong>代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用非阻塞式串口 1 发送函数 */</span></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, &amp;dat_Rxd, <span class="number">1</span>);<span class="comment">//因为 dat_Rxd 是地址，前面需要加 &amp;（取地址符号）</span></span><br><span class="line"><span class="comment">/* 接收完成后，使用中断回调函数来控制 LED1 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dat_Rxd == <span class="number">0x5A</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例程-1：通过串口通信开关灯"><a href="#例程-1：通过串口通信开关灯" class="headerlink" title="例程 1：通过串口通信开关灯"></a>例程 1：通过串口通信开关灯</h3><p><strong>要求</strong>：在 STM32F429IGT6 中进行 STM32 应用开发，完成以下功能。</p><ul><li>开机后，向串口 1 发送”Hello World!”。</li><li>串口 1 收到字节指令”0xA1”，打开 LED0（PB1），发送”LED0 Opened!”。</li><li>串口 1 收到字节指令”0xA2”，关闭 LED0（PB0），发送”LED0 Closed!”。</li><li>在串口发送过程中，打开 LED1 作为发送数据指示灯。</li></ul><p><strong>步骤</strong>：</p><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code><sup>[1]</sup>配置完成后。将 PB0、PB1 引脚分别设置为 <code>GPIO_Out</code>。接着配置 USART1 的模式、参数及使能中断，如图所示：</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410152306321.png" alt="image-20230410152306321" style="zoom:80%;" /><center>图 4.1 串口 USART1 配置</center><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410152508181.png" alt="image-20230410152508181" style="zoom:80%;" /><center>图 4.2 使能 USART1 中断</center><ol start="2"><li><p>进行 <code>STM32CubeMX 通用配置</code> <sup>[1]</sup>的第 5 步：生成代码。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> <sup>[1]</sup>完成后开始编写代码。</p><blockquote><p>打开 <code>usart1.c</code> 文件，可以看到 huart1 的配置。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410153414008.png" alt="image-20230410153414008"  /><center>图 4.3 USART1 的代码初始化</center></blockquote><p>打开 <code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宏定义 LED0、LED1 亮灭 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首先定义了无符号 8 位整数型（unsigned 8-bit integer）数组的语句，常用于表示一串 ASCII 字符。其中，Tx_str1 是数组的名称，方括号中没有指定数组长度，因此该数组长度将根据初始化时赋值的元素个数进行确定 */</span></span><br><span class="line"><span class="type">uint8_t</span> Tx_str1[] = <span class="string">&quot;Hello World!\r\n&quot;</span>; <span class="comment">// \r：回车，\n：换行</span></span><br><span class="line"><span class="type">uint8_t</span> Tx_str2[] = <span class="string">&quot;LED1 Opened!\r\n&quot;</span>;</span><br><span class="line"><span class="type">uint8_t</span> Tx_str3[] = <span class="string">&quot;LED1 Closed!\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义了一个无符号8位整数型（unsigned 8-bit integer）变量,通常用于存储通过UART接收到的单个字节数据，每次接收完成后将数据存储到该变量中 */</span></span><br><span class="line"><span class="type">uint8_t</span> Rx_dat = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 中断回调函数, 在这里面实现接收到指令后的功能*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Rx_dat == <span class="number">0xa1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED0_ON();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */</span></span><br><span class="line">LED1_OFF();</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, Tx_str2, <span class="keyword">sizeof</span>(Tx_str2), <span class="number">10000</span>);</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">LED1_ON();</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Rx_dat == <span class="number">0xa2</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED0_OFF();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */</span></span><br><span class="line">LED1_OFF();</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, Tx_str3, <span class="keyword">sizeof</span>(Tx_str3), <span class="number">10000</span>);</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">LED1_ON();</span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数内↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能 1：开机后向串口 1 发送 “Hello World!” */</span></span><br><span class="line"><span class="comment">/* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */</span></span><br><span class="line">LED1_OFF();</span><br><span class="line">HAL_Delay(<span class="number">200</span>); <span class="comment">//加入延时函数，以便肉眼观察得到</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, Tx_str1, <span class="keyword">sizeof</span>(Tx_str1), <span class="number">10000</span>);</span><br><span class="line">HAL_Delay(<span class="number">200</span>); <span class="comment">//加入延时函数，以便肉眼观察得到</span></span><br><span class="line">LED1_ON();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能 2、3：接收串口发来的数据” */</span></span><br><span class="line"><span class="comment">/* &amp;huart1 表示指向 UART1 外设的指针，&amp;Rx_dat 表示指向存储接收数据的缓冲区的指针， 1 表示要接收的数据长度 */</span></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span>  </span><br></pre></td></tr></table></figure><blockquote><p><em>串口调试助手操作要点</em></p><ol><li>MicroUSB 接口要接到板子的左下角第二个口，写着 USB_232。才会显示 <code>COM4：USB-SERIAL</code>。<code>COM3</code> 不能用于串口调试。</li><li>波特率要和 CubeMX 中设置的一致。</li><li>在发送框中输入程序中所写的字符串，然后选择 <code>16 进制发送</code>。</li></ol></blockquote></li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410181007350.png" alt="image-20230410181007350" style="zoom:75%;" /><center>图 4.4 功能实现</center><h3 id="例程-2：定时器与串口综合训练"><a href="#例程-2：定时器与串口综合训练" class="headerlink" title="例程 2：定时器与串口综合训练"></a>例程 2：定时器与串口综合训练</h3><p><strong>要求</strong>：在 STM32F429IGT6 中进行 STM32 应用开发，完成以下的功能。</p><ol><li><p>开机后，LED0 与 LED1 依次点亮，然后熄灭，进行灯光检测。</p></li><li><p>系统通过串口 1 向上位机发送一个字符串”STM32F429 欢迎您！”。</p></li><li><p>LED0 作为一个秒闪灯，系统向上位机发送完字符串后，开始亮 0.5 秒，灭 0.5 秒……循环闪烁，并开始启动系统运行时间的记录，其时分秒格式为”XX:XX:XX”。</p></li><li><p>上位机通过一个由 3 个字节组成的命令帧控制 LED1 灯的开关。该命令帧的格式为”0xBF 控制字 OxFB”。0xBF 为帧头，0xFB 为帧尾，控制字的定义如下：</p><p>0xA1：打开 LED1，返回信息”XX:XX:XX LED1 打开”。</p><p>0xA2：关闭 LED1，返回信息”XX:XX:XX LED1 关闭”。</p><p>其他：返回信息”XX:XX:XX 这是一个错误指令!”。</p></li></ol><p><strong>步骤</strong>：</p><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code><sup>[1]</sup>配置完成后。将 PB0、PB1 引脚分别设置为 <code>GPIO_Out</code>。接着配置定时器 TIM2、串口 USART1，最后中断使能，如图所示：</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410224921634.png" alt="image-20230410224921634" style="zoom: 67%;" /><center>图 5.1 LED 灯引脚设置</center><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410224315250.png" alt="image-20230410224315250" style="zoom:80%;" /><center>图 5.2 定时器 TIM2 配置</center><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410224531718.png" alt="image-20230410224531718" style="zoom:80%;" /><center>图 5.3 串口 USART1 配置</center><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230410224713093.png" alt="image-20230410224713093" style="zoom:80%;" /><center>图 5.4 中断使能</center><ol start="2"><li><p>进行 <code>STM32CubeMX 通用配置</code> <sup>[1]</sup>的第 5 步：生成代码。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> <sup>[1]</sup>完成后开始编写代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 第一步：宏定义 LED 灯，方便后续代码易读 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED0_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 第二步：定义所要用到的字符串 */</span></span><br><span class="line"><span class="type">uint8_t</span> str1[] = <span class="string">&quot;= = = = = = = Welcome to Xiaoma&#x27;s codes = = = = = = =\r\n&quot;</span>; <span class="comment">//开机显示</span></span><br><span class="line"><span class="type">uint8_t</span> hh = <span class="number">0</span>, mm = <span class="number">0</span>, ss = <span class="number">0</span>, ss05 = <span class="number">0</span>; <span class="comment">//定义时分秒，以及 0.5s</span></span><br><span class="line"><span class="type">uint8_t</span> str_buff[<span class="number">64</span>]; <span class="comment">//定义一个字符串的缓冲数组，64 个字节</span></span><br><span class="line"><span class="type">uint8_t</span> Rx_dat[<span class="number">16</span>]; <span class="comment">//定义一个串口接收的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第三步-1：功能函数：灯光检测 */</span></span><br><span class="line"><span class="comment">/* 跑马灯，LED0、LED1 轮流灭亮 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Check_LED</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">LED0_OFF();</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">LED1_OFF();</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">LED0_ON();</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">LED1_ON();</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第五步-2：重写定时器 TIM2 的中断回调函数，使 LED0 按 0.5s 间隔闪烁，0.5 是在 CubeMX 中设置好的 500ms 产生一次中断 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">LED0_TOG();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把时间变化记录到字符串时分秒中 */</span></span><br><span class="line">    <span class="comment">/* 逻辑：当记录两次 ss05，则 ss05 清零，记录 1s；当记录 60 次 ss，则 ss 清零，记录 1min；当记录 60 次 1min，则 mm 清零，记录 1h。依此循环*/</span></span><br><span class="line">ss05++;</span><br><span class="line"><span class="keyword">if</span>(ss05 == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ss05 = <span class="number">0</span>;</span><br><span class="line">ss++;</span><br><span class="line"><span class="keyword">if</span>(ss == <span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">ss = <span class="number">0</span>;</span><br><span class="line">mm++;</span><br><span class="line"><span class="keyword">if</span>(mm == <span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line">mm = <span class="number">0</span>;</span><br><span class="line">hh++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第六步-2：重写非阻塞式接收字符串的中断回调函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 判断串口是否为 USART1 */</span></span><br><span class="line"><span class="keyword">if</span>(huart-&gt;Instance == USART1)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* 判断第一个字符是否为 BF 并且第三个字符是否为 FB */</span></span><br><span class="line"><span class="keyword">if</span>(Rx_dat[<span class="number">0</span>] == <span class="number">0xBF</span> &amp;&amp; Rx_dat[<span class="number">2</span>] == <span class="number">0xFB</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">/* 使用 switch：case/break 来判断第二个字符是什么，共有三组判断 */</span></span><br><span class="line">            <span class="comment">/* 此处也可以使用 if/else 来判断，但使用 switch 使代码更整洁 */</span></span><br><span class="line"><span class="keyword">switch</span>(Rx_dat[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">/* 接收到 a1 时，则 LED1 关闭 */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0xa1</span>:</span><br><span class="line">LED1_OFF();</span><br><span class="line">                    <span class="comment">/* 要想使用 sprintf() 函数，需引入头文件 #include &quot;stdio.h&quot; */</span></span><br><span class="line">                    <span class="comment">/* %d 是占位符，在双引号的后面写对应的参数 */</span></span><br><span class="line">                    <span class="comment">/* 开头定义 str_buff 为无符号 8 位整型（uint8_t)，此处使用 (char *) 转化为字符型指针，因为 sprintf() 函数需要的参数是字符型指针*/</span></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)str_buff, <span class="string">&quot;%d:%d:%d    LED1 关闭!\r\n&quot;</span>, hh, mm, ss);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 接收到 a1 时，则 LED1 关闭 */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0xa2</span>:</span><br><span class="line">LED1_ON();</span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)str_buff, <span class="string">&quot;%d:%d:%d    LED2 打开!\r\n&quot;</span>, hh, mm, ss);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)str_buff, <span class="string">&quot;%d:%d:%d    这是一个错误的命令!\r\n&quot;</span>, hh, mm, ss);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">/* 向串口发送缓冲区 str_buff 字符串 */</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, str_buff, <span class="keyword">sizeof</span>(str_buff), <span class="number">10000</span>);</span><br><span class="line">            <span class="comment">/* 补一个接收中断函数，因为还要继续接收串口调试助手发来的字符串，同例程 1*/</span></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, Rx_dat, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第三步-2：灯光检测功能运行 */</span></span><br><span class="line">Check_LED();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第四步：发送 str1 到串口调试助手*/</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart1, str1, <span class="keyword">sizeof</span>(str1), <span class="number">10000</span>); <span class="comment">//阻塞式发送</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第五步-1：启动定时器 TIM2 中断 */</span></span><br><span class="line"><span class="comment">/* 此函数在 main.c 关联的 stm32f4xx_hal_tim.h 文件的最下面可以找到 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 第六步-1：采用非阻塞式接收字符串 */</span></span><br><span class="line"><span class="comment">/* 接收到的字节放到 Rx_dat，当接收到完整的三个字节后，进入串口接收完成中断，然后调用它的回调函数 */</span></span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, Rx_dat, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span>   </span><br></pre></td></tr></table></figure></li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230411000329095.png" alt="image-20230411000329095" style="zoom:75%;" /><center>图 5.5 串口调试助手功能实现</center><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://storybeginswhen.icu/2023/04/04/054-%E6%88%90%E4%B8%BA%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88-LED-Master/" >成为点灯大师 LED Master | Story Begins……<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引脚定义&quot;&gt;&lt;a href=&quot;#引脚定义&quot; class=&quot;headerlink&quot; title=&quot;引脚定义&quot;&gt;&lt;/a&gt;引脚定义&lt;/h3&gt;&lt;p&gt;在 STM32F429IGT6 这块开发板中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;USART1_TX 与 PA9 复用，USART1</summary>
      
    
    
    
    <category term="STM32" scheme="http://example.com/categories/STM32/"/>
    
    
    <category term="TIM" scheme="http://example.com/tags/TIM/"/>
    
    <category term="USART" scheme="http://example.com/tags/USART/"/>
    
  </entry>
  
  <entry>
    <title>PWM 从入门到入土</title>
    <link href="http://example.com/2023/04/07/055-PWM-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>http://example.com/2023/04/07/055-PWM-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2023-04-07T16:02:07.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在嵌入式开发中，除了对电路进行简单的数字量控制（如【打开&#x2F;关闭】，也就是“状态”控制），还会进行一些模拟电路控制（也就是“程度”控制）。举个栗子：比如现在控制一盏灯，简单的开关灯，就是对数字量（0、1）的控制；而控制灯的亮度，如把灯调得暗一些，就是对模拟量的控制。PWM 就是用来做“程度”控制的一种技术。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>PWM（Pulse Width Modulation，脉宽调制）是一种调制技术，用于控制模拟信号的幅度、频率和相位等特性。PWM 技术通过改变信号的脉冲宽度，来控制信号的平均电压值和电平持续时间，从而实现对模拟信号的控制。</p><p>在 PWM 技术中，一个周期的时间被分为若干个等分的时间片，每个时间片内的电平状态由信号的脉冲宽度决定，通常用占空比（Duty Cycle）表示，即高电平时间与一个周期的比值。例如，如果一个周期的时间为 1 秒，高电平时间为 0.5 秒，则占空比为 50%。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230407175807992.png" alt="image-20230407175807992" style="zoom:80%;" /><center>图 1.1 PWM 输出原理图</center><p><strong>图注</strong>：定时器工作模式为<strong>向上计数</strong>，当 CNT&lt;CCRx 时，输出低电平，当 CNT&gt;CCRx 时，输出高电平。当 CNT&#x3D;ARR 时，重新归零，然后重新向上计数，依次循环。改变 CCRx 的值，就可以改变 PWM 的占空比。改变 ARR 的值，就可以改变 PWM 的输出频率。</p><p><strong>举栗</strong>：定时器 TIM2 的 APB1 桥频率为 84MHz，PSC &#x3D; 84 -1，经过预分频器，频率变成了 1MHz（&#x3D;1&#x2F;10<sup>6</sup>&#x3D;0.001ms），ARR 设置为 1000-1，则相当于 1KHz（&#x3D; 1ms）重载一次，也就意味着 1ms 产生一次中断。①如果想要 0.2s 产生一次中断，则将 ARR 的值设为 200x10<sup>3</sup>-1，如果想要 0.5s 产生一次中断，则将 ARR 的值设为 500x10<sup>3</sup>-1。②如果想要占空比为 50%，则将 CCRx 的值设置为 ARR 的一半。</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="例程-1：PWM-呼吸灯"><a href="#例程-1：PWM-呼吸灯" class="headerlink" title="例程 1：PWM 呼吸灯"></a>例程 1：PWM 呼吸灯</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code><sup>[1]</sup>配置完成后。将 PB0、PB1 引脚分别设置为 <code>TIM3_CH3</code>、<code>TIM3_CH4</code>。接着配置 TIM3 的 CH3、CH4，如图所示：</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230407230043429.png" alt="image-20230407230043429" style="zoom:80%;" /><center>图 3.1 LED 灯引脚定时器功能配置</center><ol start="2"><li><p>配置完成后生成代码。打开 Keil5 MDK 工程文件，按照 <code>Keil5 MDK 通用配置</code><sup>[1]</sup>配置完成后，开始编写代码。</p><p>打开 <code>main.c</code> 文件。在【main】函数中开启 PWM。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_4);</span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure><p>在【main】函数中的【while】循环中写 PWM 控制呼吸灯功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** LED0 配置 **/</span></span><br><span class="line">    <span class="comment">/* LED0 逐渐熄灭 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> pwmVal=<span class="number">0</span>; pwmVal&lt;<span class="number">1000</span>; pwmVal++)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_4, pwmVal);</span><br><span class="line">        HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* LED0 逐渐点亮 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> pwmVal=<span class="number">1000</span>; pwmVal&gt;<span class="number">0</span>; pwmVal--)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_4, pwmVal);</span><br><span class="line">        HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** LED1 配置 **/</span></span><br><span class="line">    <span class="comment">/* LED1 逐渐熄灭 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> pwmVal=<span class="number">0</span>; pwmVal&lt;<span class="number">1000</span>; pwmVal++)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_3, pwmVal);</span><br><span class="line">        HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* LED1 逐渐点亮 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint16_t</span> pwmVal=<span class="number">1000</span>; pwmVal&gt;<span class="number">0</span>; pwmVal--)</span><br><span class="line">    &#123;</span><br><span class="line">        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_3, pwmVal);</span><br><span class="line">        HAL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure></li><li><p>编译代码，下载到开发板。例程成功运行。</p></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Q1：<code>pwmVal</code> 变量的值与 LED 灯亮度的关系？</p><p>A1：当 <code>pwmVal</code> 的值从 0 到 1000 变化时，PWM 波形的占空比会从 0% 逐渐变化到 100%。具体来说，当 pwmVal 为 0 时，PWM 波形的占空比为 0%，即输出为低电平；当 pwmVal 为 1000 时，PWM 波形的占空比为 100%，即输出为高电平。正点原子阿波罗这款开发板的 LED 等是低电平亮、高电平灭，因此，当 <code>pwmVal</code> 的值增加时，占空比增加，高电平增加，亮度变暗。当 <code>pwmVal</code> 的值减小时，占空比减小，低电平增加，亮度变亮。<code>pwmVal</code> 的值与 LED 灯亮度呈<strong>反比</strong>关系。</p><table><thead><tr><th align="center">pwmVal</th><th align="center">占空比</th><th align="center">高电平</th><th align="center">亮度</th></tr></thead><tbody><tr><td align="center">↑</td><td align="center">↑</td><td align="center">↑</td><td align="center">↓</td></tr><tr><td align="center">↓</td><td align="center">↓</td><td align="center">↓</td><td align="center">↑</td></tr></tbody></table><p>Q2：【HAL_Delay】函数的作用？ </p><p>A2：【HAL_Delay】函数的作用是产生延时，使程序在逐渐增加或降低 LED 亮度的过程中，能够有足够的时间让人眼观察到亮度变化。如果没有 Delay 函数，LED 的亮度会在很短的时间内逐渐变亮或变暗，人眼很难察觉到亮度变化。延时时间越长，越能充分观察到 LED 亮度的变化。但是如果延时时间过长，则会影响程序的响应速度。另外，建议使用【HAL_Delay】作为延时函数而不是另外写一个，因为这个更准确，可以产生 1ms 延时。如下面这个函数，通过循环计数的方式实现延时，即在一个循环中执行一定的操作，直到计数器减为 0，从而产生一定的延时，但是其单位是 CPU 时钟周期或者是毫秒，就不够准确了，所以还是不要用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(t--);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="例程-2：PWM-舵机"><a href="#例程-2：PWM-舵机" class="headerlink" title="例程 2：PWM 舵机"></a>例程 2：PWM 舵机</h4><blockquote><p>功能实现：①使用 TIM2 中断控制 LED0 的闪烁，用于检测显示程序正在实时运行。②使用 TIM3_CH1 控制 PA6 引脚输出 PWM，控制舵机（SG90 180°）。③使用按键 KEY0 控制 PWM 输出。④使用按键 KEY1 控制 LED1 的亮灭，用于检测显示程序正在实时运行。</p></blockquote><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code><sup>[1]</sup>配置完成后。将 LED 灯引脚 PB0、PB1 引脚设置为 <code>GPIO_Output</code>，将按键引脚 PH2、PH3 引脚设置为 <code>GPIO_Input</code>，将 PA6 引脚设置为 <code>TIM3_CH1</code>。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230408210843835.png" alt="image-20230408210843835" style="zoom:80%;" /><center>图 3.2 LED 灯、按键、PWM 引脚设置</center><ol start="2"><li>将按键引脚 PH2、PH3 改为上拉（Pull-up）输入。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230408213106845.png" alt="image-20230408213106845" style="zoom:80%;" /><center>图 3.3 按键引脚配置</center><ol start="3"><li><p>定时器 TIM3 配置。</p><blockquote><p>180° 舵机周期为 20ms，则 ARR &#x3D; 20*10<sup>3</sup>-1。</p></blockquote></li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230408213427558.png" alt="image-20230408213427558" style="zoom:80%;" /><center>图 3.4 定时器 TIM3_CH1 配置</center><ol start="4"><li><p>定时器 TIM2 配置。</p><blockquote><ul><li><p>每 200ms 翻转一次 LED0 电平，ARR &#x3D; 200*10<sup>3</sup>-1。</p></li><li><p>使能中断。</p></li></ul></blockquote></li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230408214340107.png" alt="image-20230408214340107" style="zoom: 80%;" /><center>图 3.5 定时器 TIM2 ARR 配置</center><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230408220018741.png" alt="image-20230408220018741" style="zoom:80%;" /><center>图 3.6 定时器 TIM2 中断使能</center><ol start="5"><li><p>配置完成后生成代码。打开 Keil5 MDK 工程文件，按照 <code>Keil5 MDK 通用配置</code><sup>[1]</sup>配置完成后，开始编写代码。</p><p><strong>分步代码</strong>：</p><p>① 开启定时器中断和 PWM：打开 <code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数内↓↓↓</span><br><span class="line">-----------------------  </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2); <span class="comment">//开启定时器中断</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1); <span class="comment">//开启 PWM</span></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure><p>② 使用定时器 TIM2 中断控制 LED0 的闪烁：打开 <code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TIM2--LED0 每 20ms 翻转一次电平 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure><p>③ KEY1 控制 LED1 亮灭：打开<code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="comment">/* 宏定义 KEY0、KEY1 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scan_Keys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* KEY1--LED1 按下控制亮灭 */</span></span><br><span class="line"><span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay(<span class="number">200</span>); <span class="comment">//延时函数去抖动</span></span><br><span class="line"><span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_0);</span><br><span class="line"><span class="keyword">while</span>(KEY1 == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数内↓↓↓</span><br><span class="line">-----------------------   </span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Scan_Keys();</span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">     <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure><p>④ KEY0 控制 PWM 输出：打开 <code>main.c</code> 文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="comment">/* 宏定义 KEY0、KEY1 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scan_Keys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* KEY0--PWM 按下控制舵机旋转 90° */</span></span><br><span class="line"><span class="keyword">if</span>(KEY0 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay(<span class="number">200</span>); <span class="comment">//延时函数去抖动</span></span><br><span class="line"><span class="keyword">if</span>(KEY0 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">/* 运行逻辑：开始舵机在 0° 位置，1500 表示转到 90°，500 表示转到 0°，此处代码的意思是按下 KEY0，舵机由初始位置 0° 旋转到 90°，然后再回到初始位置 0° */</span></span><br><span class="line">            __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, <span class="number">1500</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>); <span class="comment">// 延时 1s，为了让舵机旋转到 90° 时停一下再旋转</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">while</span>(KEY0 == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure><p><strong>完整代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数外↓↓↓</span><br><span class="line">-----------------------  </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TIM2 中断回调函数：控制 LED0 闪烁 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* TIM2--LED0 每 20ms 翻转一次电平 */</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 功能函数：扫描按键 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scan_Keys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* KEY0--PWM 按下控制舵机旋转 90° */</span></span><br><span class="line"><span class="keyword">if</span>(KEY0 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay(<span class="number">100</span>); <span class="comment">//延时函数去抖动</span></span><br><span class="line"><span class="keyword">if</span>(KEY0 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 运行逻辑：开始舵机在 0° 位置，1500 表示转到 90°，500 表示转到 0°，此处代码的意思是按下 KEY0，舵机由初始位置 0° 旋转到 90°，然后再回到初始位置 0° */</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, <span class="number">1500</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>); <span class="comment">// 延时 1s，为了让舵机旋转到 90° 时停一下再旋转</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, <span class="number">500</span>);</span><br><span class="line"><span class="keyword">while</span>(KEY0 == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* KEY1--LED1 按下控制亮灭 */</span></span><br><span class="line"><span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay(<span class="number">200</span>); <span class="comment">//延时函数去抖动</span></span><br><span class="line"><span class="keyword">if</span>(KEY1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_0);</span><br><span class="line"><span class="keyword">while</span>(KEY1 == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line">↓↓↓注：main() 函数内↓↓↓</span><br><span class="line">----------------------- </span><br><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2); <span class="comment">//开启定时器中断</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1); <span class="comment">//开启 PWM</span></span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Scan_Keys();</span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure></li><li><p>编译代码，下载到开发板。例程成功运行，各功能均已实现。</p></li></ol><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://storybeginswhen.icu/2023/04/04/054-%E6%88%90%E4%B8%BA%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88-LED-Master/" >成为点灯大师 LED Master | Story Begins…… <i class="fas fa-external-link-alt"></i></a></p><p>[2] <a class="link"   href="https://storybeginswhen.icu/2023/04/03/053-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%88%B5%E6%9C%BA%E6%97%8B%E8%BD%AC/" >STM32 HAL 库实现舵机旋转 | Story Begins…… <i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在嵌入式开发中，除了对电路进行简单的数字量控制（如【打开&amp;#x2F;关闭】，也就是“状态”控制），还会进行一些模拟电路控制（也就是“程度”控</summary>
      
    
    
    
    <category term="STM32" scheme="http://example.com/categories/STM32/"/>
    
    
    <category term="PWM" scheme="http://example.com/tags/PWM/"/>
    
  </entry>
  
  <entry>
    <title>STM32 HAL 库实现舵机旋转</title>
    <link href="http://example.com/2023/04/03/053-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%88%B5%E6%9C%BA%E6%97%8B%E8%BD%AC/"/>
    <id>http://example.com/2023/04/03/053-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%88%B5%E6%9C%BA%E6%97%8B%E8%BD%AC/</id>
    <published>2023-04-03T16:16:13.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h4><p>有一种电机可以在程序的控制下，在一定范围内连续改变输出轴角度并可以保持住。 这种电机最早被用在航模和船模等遥控模型中，控制各种舵面的转动，这就是舵机。 </p><h4 id="舵机控制基本原理"><a href="#舵机控制基本原理" class="headerlink" title="舵机控制基本原理"></a>舵机控制基本原理</h4><p>舵机的控制一般需要一个 20ms 周期的 PWM 信号，该脉冲的高电平部分一般为 0.5ms~2.5ms 范围内的角度控制脉冲部分。以 180° 角度伺服为例，对应关系如下所示：</p><ul><li>0.5 ms 高电平 ——– 0°</li><li>1.0 ms 高电平 ——– 45°</li><li>1.5 ms 高电平 ——– 90°</li><li>2.0 ms 高电平 ——– 135°</li><li>2.5 ms 高电平 ——– 180°</li></ul><p>顺时针还是逆时针转动需要自己试。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><ul><li>STM32F429IGT6 开发板</li><li>SG90 9 克舵机</li></ul><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><ul><li>STM32CubeMX</li><li>Keil5</li></ul><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>180° → 2ms。那么 3μm → 0.27°。意味着这个舵机的控制精度为 0.27°。</p><p>推导公式：n&#x2F;90(ms) + 0.5ms，n 为想要转到的角度。</p><h3 id="实操步骤"><a href="#实操步骤" class="headerlink" title="实操步骤"></a>实操步骤</h3><ol><li>打开 STM32CubeMX 软件，按照 <code>STM32CubeMX 通用配置</code>（参考：<a class="link"   href="https://storybeginswhen.icu/2023/04/04/054-%E6%88%90%E4%B8%BA%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88%EF%BC%88LED-Master%EF%BC%89/" >成为点灯大师 LED Master | Story Begins <i class="fas fa-external-link-alt"></i></a>）完成后。选择针脚，查阅手册可知 PA6 可通过 TIM3_CH1 开启。配置 TIM3 的 CH1，完成后可以看到右边 PA6 引脚变为绿色。③ 的原理参考：xx。</li></ol><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230405184143879.png" alt="image-20230405184143879" style="zoom:80%;" /><center>图 1 TIM3_CH1 配置</center><ol start="2"><li><p>进行 <code>STM32CubeMX 通用配置</code> <sup>[2]</sup>的第 5 步。</p></li><li><p>打开工程文件。按照 <code>Keil5 MDK 通用配置</code> <sup>[2]</sup>完成后开始编写代码。</p><p>打开 <code>main.c</code> 文件。在 <code>main</code> 函数中开启 PWM。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1);</span><br><span class="line"><span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure><p>输出 PWM。此处输出为正转 180° 后反转 180°，以此往复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_6);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, <span class="number">500</span>);</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">    __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, <span class="number">2500</span>);</span><br><span class="line">    HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 3 */</span></span><br></pre></td></tr></table></figure></li><li><p>进行 <code>Keil5 MDK 通用配置</code> <sup>[2]</sup>的第 5 步。</p></li></ol><blockquote><p>上述例程成功运行。</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://www.bilibili.com/video/BV1de411M7uf/?spm_id_from=333.337.search-card.all.click&vd_source=988bef447181962dfedd9c12da816e87" >基于cubemx的舵机加减速控制方法_bilibili<i class="fas fa-external-link-alt"></i></a></p><p>[2] <a class="link"   href="https://storybeginswhen.icu/2023/04/04/054-%E6%88%90%E4%B8%BA%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88%EF%BC%88LED-Master%EF%BC%89/" >成为点灯大师 LED Master | Story Begins <i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;h4 id=&quot;舵机&quot;&gt;&lt;a href=&quot;#舵机&quot; class=&quot;headerlink&quot; title=&quot;舵机&quot;&gt;&lt;/a&gt;舵机&lt;/h4&gt;&lt;p&gt;有一种</summary>
      
    
    
    
    <category term="STM32" scheme="http://example.com/categories/STM32/"/>
    
    
    <category term="HAL" scheme="http://example.com/tags/HAL/"/>
    
    <category term="PWM" scheme="http://example.com/tags/PWM/"/>
    
  </entry>
  
  <entry>
    <title>手指机器人实现</title>
    <link href="http://example.com/2023/04/01/052-%E6%89%8B%E6%8C%87%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/04/01/052-%E6%89%8B%E6%8C%87%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-04-01T15:58:39.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://space.bilibili.com/486234858/?spm_id_from=333.999.0.0" >关耳极创的个人空间 bilibili<i class="fas fa-external-link-alt"></i></a></p><p>[2] <a class="link"   href="https://blog.csdn.net/u012241570/article/details/90406919" >SG90系列 MG系列马达_wonull的博客-CSDN博客<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;[1] &lt;a class=&quot;link&quot;   href=&quot;https://space.bilibili.com/486234858/?spm_</summary>
      
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="控制" scheme="http://example.com/tags/%E6%8E%A7%E5%88%B6/"/>
    
    <category term="建模" scheme="http://example.com/tags/%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用 VLC 拉取视频流</title>
    <link href="http://example.com/2023/03/31/051-%E4%BD%BF%E7%94%A8-VLC-%E6%8B%89%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81/"/>
    <id>http://example.com/2023/03/31/051-%E4%BD%BF%E7%94%A8-VLC-%E6%8B%89%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81/</id>
    <published>2023-03-31T22:18:59.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><ul><li>VLC media player：v3.0.17.4</li><li>OS：Win11</li></ul><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><ul><li>摄像头：SONY FCB-CV7520</li><li>无线模块 1：</li><li>无线模块 2：</li></ul><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="http://www.sumboy.cn/product_diy.php-id=15.html" >跟踪板 产品详情 (sumboy.cn)<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;h4 id=&quot;软件&quot;&gt;&lt;a href=&quot;#软件&quot; class=&quot;headerlink&quot; title=&quot;软件&quot;&gt;&lt;/a&gt;软件&lt;/h</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="VLC" scheme="http://example.com/tags/VLC/"/>
    
    <category term="网络摄像头" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    
  </entry>
  
  <entry>
    <title>无线投影仪使用教程</title>
    <link href="http://example.com/2023/03/31/050-%E6%97%A0%E7%BA%BF%E6%8A%95%E5%BD%B1%E4%BB%AA%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2023/03/31/050-%E6%97%A0%E7%BA%BF%E6%8A%95%E5%BD%B1%E4%BB%AA%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2023-03-31T17:26:41.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>EPSON TW740&#x2F;750</li><li>笔记本电脑（Win11 系统）</li></ul><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="EPSON-投影仪端"><a href="#EPSON-投影仪端" class="headerlink" title="EPSON 投影仪端"></a>EPSON 投影仪端</h4><ol><li>使用遥控器或投影仪面板的 <code>Menu</code> 键进入菜单<sup>[1]</sup>，找到【网络】，将【无线电源】设置为【无线 LAN 开】，进入【网络配置】。</li><li>选择【无线 LAN】，将连接模式改为【高级】，进入【搜索接入点】，选择要连接的 WiFi 名称，输入密码，点【Finish】连接。在【IP 设置】中将【DHCP】设置为 <code>开</code>（可选项）。</li></ol><h4 id="笔记本电脑端"><a href="#笔记本电脑端" class="headerlink" title="笔记本电脑端"></a>笔记本电脑端</h4><ol><li>连接名称相同的 WiFi。（505 与 505_5G 同属于一个路由器，所以都可以使用）</li><li>按下快捷键<sup>[2]</sup> <code>Win + K</code>，选择出现的投影仪名称连接即可。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://www.epson.com.cn/apps/tech_support/faq/QA-content.aspx?ColumnId=31525&ArticleId=37167&pg=&view=&columnid2=31525" >移动设备通过路由器实现无线投影方法 - 爱普生产品常见问题 - 爱普生中国 (epson.com.cn)<i class="fas fa-external-link-alt"></i></a></p><p>[2] EPSON 官方电话：4008109977</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;硬件&quot;&gt;&lt;a href=&quot;#硬件&quot; class=&quot;headerlink&quot; title=&quot;硬件&quot;&gt;&lt;/a&gt;硬件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;EPSON TW740&amp;#x2F;750&lt;/li&gt;
&lt;li&gt;笔记本电脑（Win11 系统）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="投影仪" scheme="http://example.com/tags/%E6%8A%95%E5%BD%B1%E4%BB%AA/"/>
    
    <category term="无线" scheme="http://example.com/tags/%E6%97%A0%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Stable Diffusion WebUI 入门</title>
    <link href="http://example.com/2023/03/30/049-Stable-Diffusion-WebUI-%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/03/30/049-Stable-Diffusion-WebUI-%E5%85%A5%E9%97%A8/</id>
    <published>2023-03-30T00:12:58.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Stable-Diffusion-WebUI-安装"><a href="#Stable-Diffusion-WebUI-安装" class="headerlink" title="Stable-Diffusion-WebUI 安装"></a>Stable-Diffusion-WebUI 安装</h3><p>网上各种配置着实麻烦，可能因为网络崩掉。幸好，有秋叶大佬：<a class="link"   href="https://b23.tv/Om1eiEu" >秋葉aaaki的个人空间-哔哩哔哩<i class="fas fa-external-link-alt"></i></a></p><h4 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h4><p>启动器<sup>[1]</sup>下载链接：<a class="link"   href="https://pan.baidu.com/s/1XHOx7zgO0IQVL-01opwXjA?pwd=uvdy" >https://pan.baidu.com/s/1XHOx7zgO0IQVL-01opwXjA?pwd=uvdy<i class="fas fa-external-link-alt"></i></a></p><h4 id="整合包"><a href="#整合包" class="headerlink" title="整合包"></a>整合包</h4><p>整合包<sup>[2]</sup>下载链接: <a class="link"   href="https://pan.baidu.com/s/1qWggi0qMMTdMpqCNCRcjoQ" >https://pan.baidu.com/s/1qWggi0qMMTdMpqCNCRcjoQ<i class="fas fa-external-link-alt"></i></a><br>提取码: a241</p><h3 id="SDW-启动"><a href="#SDW-启动" class="headerlink" title="SDW 启动"></a>SDW 启动</h3><p>打开如图所示，点击【一键启动】。（刚开始启动时会要求填写同意书，按提示操作即可）</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230330001011090.png" alt="image-20230330001011090" style="zoom:81%;" /><p>第二次启动，在浏览器中打开 Stable Diffusion WebUI。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230330001232534.png" alt="image-20230330001232534" style="zoom:45%;" /><h3 id="AI-绘画网站收集"><a href="#AI-绘画网站收集" class="headerlink" title="AI 绘画网站收集"></a>AI 绘画网站收集</h3><p>[1] <a class="link"   href="https://civitai.com/" >Civitai | Stable Diffusion models, embeddings, hypernetworks and more<i class="fas fa-external-link-alt"></i></a></p><p>[2] <a class="link"   href="https://stability.ai/" >Stability AI<i class="fas fa-external-link-alt"></i></a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://b23.tv/ziSz60i" >【AI绘画】启动器正式发布！一键启动&#x2F;修复&#x2F;更新&#x2F;模型下载管理全支持！-哔哩哔哩<i class="fas fa-external-link-alt"></i></a></p><p>[2] <a class="link"   href="https://b23.tv/z29pfnz" >【AI绘画】Stable Diffusion 最终版 无需额外下载安装！可更新✓ 训练✓ 汉化✓ 提供7G模型 NovelAI-哔哩哔哩<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Stable-Diffusion-WebUI-安装&quot;&gt;&lt;a href=&quot;#Stable-Diffusion-WebUI-安装&quot; class=&quot;headerlink&quot; title=&quot;Stable-Diffusion-WebUI 安装&quot;&gt;&lt;/a&gt;Stable-Diff</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="SD" scheme="http://example.com/tags/SD/"/>
    
    <category term="AI 绘画" scheme="http://example.com/tags/AI-%E7%BB%98%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>jupyter 入门</title>
    <link href="http://example.com/2023/03/29/048-jupyter-%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/03/29/048-jupyter-%E5%85%A5%E9%97%A8/</id>
    <published>2023-03-29T22:10:16.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>此处使用最简单的方式。（OS：Win11）</p><p>打开 <code>Anaconda Navigator</code>，在 <code>Enviroments</code> 页面创建一个新的虚拟环境。回到 <code>Home</code> 页，点击 <code>JupyterLab</code> 下的 <code>Install</code>。等待安装完成。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>选择想要使用的 <code>Enviroment</code>，回到 <code>Home</code> 页，点击 <code>JupyterLab</code> 下的 <code>Launch</code>，会直接跳转到浏览器页面，如下图所示。</p><p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230329221903806.png" alt="image-20230329221903806"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>每一个 <code>.ipynb</code> 文件都是 <code>Jupyter Notebook</code>（Jupyter 笔记本）。里面有一个个的 <code>Cell</code>，每个 <code>Cell</code> 都是一段独立的程序，运行它，就会在下面显示输出结果。</p><p>（……后续补充）</p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><h4 id="命令模式（按-Esc-键进入）"><a href="#命令模式（按-Esc-键进入）" class="headerlink" title="命令模式（按 Esc 键进入）"></a>命令模式（按 Esc 键进入）</h4><ul><li><code>Enter</code>：进入编辑模式</li><li><code>Shift + Enter</code>：执行当前单元格，并跳转到下一个单元格</li><li><code>Ctrl + Enter</code>：执行当前单元格，不跳转</li><li><code>Alt + Enter</code>：执行当前单元格，并在下面插入一个新单元格</li><li><code>Y</code>：将当前单元格转换为代码单元格</li><li><code>M</code>：将当前单元格转换为 Markdown 单元格</li><li><code>A</code>：在上面插入一个新单元格</li><li><code>B</code>：在下面插入一个新单元格</li><li><code>X</code>：剪切当前单元格</li><li><code>C</code>：复制当前单元格</li><li><code>V</code>：粘贴到下方</li><li><code>Shift + V</code>：粘贴到上方</li><li><code>D + D</code>：删除当前单元格</li><li><code>Z</code>：撤销删除操作</li><li><code>Shift + M</code>：合并当前单元格和下方的单元格</li><li><code>Ctrl + S</code>：保存当前笔记本</li><li><code>F</code>：查找和替换</li></ul><h4 id="编辑模式（按-Enter-键进入）"><a href="#编辑模式（按-Enter-键进入）" class="headerlink" title="编辑模式（按 Enter 键进入）"></a>编辑模式（按 Enter 键进入）</h4><ul><li><code>Shift + Enter</code>：执行当前单元格，并跳转到下一个单元格</li><li><code>Ctrl + Enter</code>：执行当前单元格，不跳转</li><li><code>Alt + Enter</code>：执行当前单元格，并在下面插入一个新单元格</li><li><code>Ctrl + /</code>：注释当前行或取消注释</li><li><code>Ctrl + ]</code>：缩进当前行</li><li><code>Ctrl + [</code>：取消缩进当前行</li><li><code>Tab</code>：代码补全</li><li><code>Shift + Tab</code>：获取当前变量的帮助文档</li><li><code>Ctrl + Shift + -</code>：在当前光标位置拆分单元格</li><li><code>Esc</code>：返回到命令模式</li></ul><h3 id="停止正在运行的程序"><a href="#停止正在运行的程序" class="headerlink" title="停止正在运行的程序"></a>停止正在运行的程序</h3><p>在 Jupyter Notebook 中，要停止正在运行的程序，可以使用以下方法：</p><ol><li>在运行程序的单元格上按 <code>Interrupt the kernel</code> 按钮。这个按钮的图标是一个黑色的方块，在 Jupyter Notebook 的工具栏上。点击该按钮后，程序将被中断并停止运行。</li><li>在 Jupyter Notebook 中的 Kernel 菜单中选择 <code>Interrupt</code> 命令。这个命令将中断正在运行的程序并停止它。</li><li>在 Jupyter Notebook 中的 Kernel 菜单中选择 <code>Restart</code> 命令。这个命令将重新启动 Jupyter Notebook 的内核，并且所有正在运行的程序将被终止。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;此处使用最简单的方式。（OS：Win11）&lt;/p&gt;
&lt;p&gt;打开 &lt;code&gt;Anaconda Navigator&lt;/code&gt;，在 &lt;cod</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
    <category term="jupyter" scheme="http://example.com/tags/jupyter/"/>
    
  </entry>
  
  <entry>
    <title>Keil5 DAP 仿真器设置</title>
    <link href="http://example.com/2023/03/29/047-Keil5-DAP-%E4%BB%BF%E7%9C%9F%E5%99%A8%E8%AE%BE%E7%BD%AE/"/>
    <id>http://example.com/2023/03/29/047-Keil5-DAP-%E4%BB%BF%E7%9C%9F%E5%99%A8%E8%AE%BE%E7%BD%AE/</id>
    <published>2023-03-29T10:22:17.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<p>使用 DAP 仿真器的设置（来自正点原子旗舰店技术支持）：</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/20230329102501.png" alt="20230329102501" style="zoom:100%;" /><p><strong>注意</strong>：下图默认的 Connect 和 Reset 改为上图所示。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/20230329102514.png" alt="20230329102514" style="zoom:100%;" /><p>设置完 Debug 栏后，再设置一下 Utilities。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/20230329102525.png" alt="20230329102525" style="zoom:100%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 DAP 仿真器的设置（来自正点原子旗舰店技术支持）：&lt;/p&gt;
&lt;img src=&quot;https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/20230329102501.png&quot; alt=&quot;20230329</summary>
      
    
    
    
    <category term="STM32" scheme="http://example.com/categories/STM32/"/>
    
    
    <category term="Keil5" scheme="http://example.com/tags/Keil5/"/>
    
    <category term="DAP" scheme="http://example.com/tags/DAP/"/>
    
  </entry>
  
  <entry>
    <title>WordPress 入门</title>
    <link href="http://example.com/2023/03/27/046-WordPress-%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/03/27/046-WordPress-%E5%85%A5%E9%97%A8/</id>
    <published>2023-03-27T21:29:43.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>阿里云提供了非常方便的安装方式。使用之前创建 Memos 时购买的轻量应用服务器。点击【重置系统】（或者新买一台），在镜像那一栏，选择【应用镜像】→【WordPress】（可以选版本），然后确认即可，等待几秒钟，重置完成。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230327213623634.png" alt="image-20230327213623634" style="zoom: 80%;" /><p>在左栏点击【应用管理】→【应用详情】，可以看到 WordPress 的使用方式。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230327213831966.png" alt="image-20230327213831966" style="zoom:80%;" /><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>根据上述提示，打开 WordPress 管理界面。</p><p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230327213936936.png" alt="image-20230327213936936"></p><p>输入账号密码登录。成功进入后台。（管理员邮箱的事情其实不必管它）</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230327220409032.png" alt="image-20230327220409032" style="zoom:31.5%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;阿里云提供了非常方便的安装方式。使用之前创建 Memos 时购买的轻量应用服务器。点击【重置系统】（或者新买一台），在镜像那一栏，选择【应用</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="WordPress" scheme="http://example.com/tags/WordPress/"/>
    
    <category term="博客" scheme="http://example.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>无线打印机使用教程</title>
    <link href="http://example.com/2023/03/27/045-%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2023/03/27/045-%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2023-03-27T16:31:01.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<p><strong>型号</strong>：HP Laser Jet MFP M227fdw</p><p><strong>步骤</strong>：</p><ol><li><p>笔记本电脑连接 WiFi：<strong>505_5G</strong></p></li><li><p>（Win11）打开【设置】→【蓝牙和其他设备】→【打印机和扫描仪】→【添加设备】</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230327164208268.png" alt="image-20230327164208268" style="zoom:60%;" /><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230327164305588.png" alt="image-20230327164305588" style="zoom:47%;" /></li><li><p>使用 <code>Ctrl + P</code> 进行打印，打印机选项选择 NPI02ACF7。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;型号&lt;/strong&gt;：HP Laser Jet MFP M227fdw&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;笔记本电脑连接 WiFi：&lt;strong&gt;505_5G&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="打印机" scheme="http://example.com/tags/%E6%89%93%E5%8D%B0%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>树莓派入门</title>
    <link href="http://example.com/2023/03/27/044-%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2023/03/27/044-%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/</id>
    <published>2023-03-27T16:09:42.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<p>从淘宝购得树莓派一套，型号为 Raspbeey Pi 4B 8G。首先组装亚克力外壳<sup>[1,2]</sup>。</p><h4 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h4><p><code>Ctrl + Alt + T</code> 打开终端，输入 <code>ipconfig</code> 查看树莓派 IP 地址。</p><p>但是下次启动时可能由于路由器采取的是 DHCP，自动分配未使用的 IP 地址。下次登录时就不知道 IP 地址了。可以通过【搭建开发环境所需的工具与系统镜像】文件夹中的 <code>Advanced IP Scanner</code> 来查找树莓派 IP 地址。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://www.bilibili.com/video/BV1ZE41187mx/?buvid=43c0bbfa5ef1cf2069f924c4aafaa3d1&is_story_h5=false&mid=CUYEjqc3CJrjkATsK2Ds5A==&p=1&plat_id=168&share_from=ugc&share_medium=iphone&share_plat=ios&share_session_id=16633860-E140-40F5-AEB3-9D2C4F84C2CE&share_source=COPY&share_tag=s_i&timestamp=1679905675&unique_k=8PiLiTg&up_id=478347994&vd_source=988bef447181962dfedd9c12da816e87" >树莓派4代 透明亚克力外壳安装（兼容红外遥控模块）bilibili<i class="fas fa-external-link-alt"></i></a></p><p>[2] <a class="link"   href="https://www.bilibili.com/video/BV14A411i7w7/?buvid=43c0bbfa5ef1cf2069f924c4aafaa3d1&is_story_h5=false&mid=CUYEjqc3CJrjkATsK2Ds5A==&p=1&plat_id=168&share_from=ugc&share_medium=iphone&share_plat=ios&share_session_id=7D8A2BCE-D131-4E25-A4C1-8448FB264EE6&share_source=COPY&share_tag=s_i&timestamp=1679905662&unique_k=RNImnwC&up_id=160497604&vd_source=988bef447181962dfedd9c12da816e87" >【树莓派】树莓派摄像头安装教程！超详细！bilibili<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从淘宝购得树莓派一套，型号为 Raspbeey Pi 4B 8G。首先组装亚克力外壳&lt;sup&gt;[1,2]&lt;/sup&gt;。&lt;/p&gt;
&lt;h4 id=&quot;SSH-连接&quot;&gt;&lt;a href=&quot;#SSH-连接&quot; class=&quot;headerlink&quot; title=&quot;SSH 连接&quot;&gt;&lt;/a&gt;S</summary>
      
    
    
    
    <category term="树莓派" scheme="http://example.com/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="入门" scheme="http://example.com/tags/%E5%85%A5%E9%97%A8/"/>
    
    <category term="组装" scheme="http://example.com/tags/%E7%BB%84%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 Anaconda</title>
    <link href="http://example.com/2023/03/24/043-Ubuntu-%E5%AE%89%E8%A3%85-Anaconda/"/>
    <id>http://example.com/2023/03/24/043-Ubuntu-%E5%AE%89%E8%A3%85-Anaconda/</id>
    <published>2023-03-24T22:14:22.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>下载 Anaconda 打开文件夹，在想要下载 Anaconda 的位置，右键打开终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget &lt;https://mirrors.bfsu.edu.cn/anaconda/archive/Anaconda3-2023.03-Linux-x86_64.sh&gt; --no-check-certificate</span><br></pre></td></tr></table></figure><p>注意：在镜像网站（ <a class="link"   href="https://repo.anaconda.com/archive/?C=M&O=A" >https://repo.anaconda.com/archive/?C=M&amp;O=A<i class="fas fa-external-link-alt"></i></a> ）查看 Anaconda 的版本信息，然后更改命令。</p></li><li><p>安装 Anaconda 下载完成后发现是一个 .sh 脚本。 首先给他可执行权限，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x Anaconda3-2023.03-Linux-x86_64.sh</span><br><span class="line">./Anaconda3-2023.03-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>回车后查看许可证，按 q 退出许可证，然后输入 yes 表示同意。确认安装的路径，默认即可。 安装完毕后，输入 yes 来确认使用 conda init 来启动。 </p></li><li><p>退出 Anaconda3 的基础环境（base）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure></li><li><p>打开 Anaconda 图形化界面 首先将 Anaconda 的 bin 目录添加到系统的 PATH 环境变量中。如果不知道 Anaconda 的路径，可以先用命令行查找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> conda //查看 Anaconda 路径</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/path/to/anaconda/bin:<span class="variable">$PATH</span>&quot;</span> //修改成 bin 的路径</span><br><span class="line">anaconda-navigator //启动图形化界面，有警告不用理会</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-VSCode"><a href="#安装-VSCode" class="headerlink" title="安装 VSCode"></a>安装 VSCode</h3><ol><li><p>下载 <code>deb</code> 安装包：<a class="link"   href="https://code.visualstudio.com/Download" >Download Visual Studio Code - Mac, Linux, Windows<i class="fas fa-external-link-alt"></i></a></p></li><li><p>安装 VSCode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i code_(tab) //使用 Tab 键补全</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://zhuanlan.zhihu.com/p/459607806" >Ubuntu 安装 conda - 知乎 (zhihu.com)<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载 Anaconda 打开文件夹，在想要下载 Anaconda 的位置，右键打开终端：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Ubuntu" scheme="http://example.com/tags/Ubuntu/"/>
    
    <category term="Anaconda" scheme="http://example.com/tags/Anaconda/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT Plus 续费失败及解决方案</title>
    <link href="http://example.com/2023/03/24/042-ChatGPT-Plus-%E7%BB%AD%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2023/03/24/042-ChatGPT-Plus-%E7%BB%AD%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2023-03-24T09:15:20.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<p>最近到了续订 ChatGPT Plus 的日期，没有任何提示，Depay 钱包也没有任何付款记录。打开 ChatGPT Plus 订阅界面，发现付款失败了。提示“<strong>您最近的付款失败了。更新您的支付方式，以继续该方案。</strong>”</p><p>点击更新支付方式，重新输入显示“<strong>银行卡被拒绝</strong>”。</p><p>看网上说 Depay 被风控了。于是找了国外的朋友，使用他们的信用卡&#x2F;借记卡。通通显示拒绝该银行卡。以为是账单地址的问题，于是修改账单地址，再填写银行卡，依然不行。</p><p>点击<strong>取消方案</strong>，看到可以用到 4 月 19 日（白嫖 1 个月）。意思是取消 Plus 方案也还可以再用一个月。</p><p>去闲鱼找代付，要我账号和密码。去 Telegram 找代付，要我 70 手续费。我都想着白嫖完这一个月到时候买成品号了。</p><p>直到昨晚睡前刷一下知乎，看到了有人和我遇到了同样的问题<sup>[1]</sup>，并解决了它。顺藤摸瓜找到了 Twitter 大神的解决方案。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/IMG_7863.jpg" alt="IMG_7863" style="zoom:70%;" /><p>首先使用日本节点、加拿大朋友的借记卡，经过一系列【我是人类】的验证后，失败。更换为韩国节点，继续使用加拿大朋友的借记卡，经过一次【我是人类】的验证，等待……付款成功！</p><p>不清楚 Stripe 风控的什么，反正能续一个月是一个月，这次又能用到 5 月 19 日了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://zhuanlan.zhihu.com/p/616328942" >续订ChatGPT Plus失败，如何解决？ - 知乎 (zhihu.com)<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近到了续订 ChatGPT Plus 的日期，没有任何提示，Depay 钱包也没有任何付款记录。打开 ChatGPT Plus 订阅界面，发现付款失败了。提示“&lt;strong&gt;您最近的付款失败了。更新您的支付方式，以继续该方案。&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;点击更新</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="ChatGPT" scheme="http://example.com/tags/ChatGPT/"/>
    
    <category term="Plus" scheme="http://example.com/tags/Plus/"/>
    
    <category term="国外信用卡" scheme="http://example.com/tags/%E5%9B%BD%E5%A4%96%E4%BF%A1%E7%94%A8%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>单片机名词解释</title>
    <link href="http://example.com/2023/03/23/041-%E5%8D%95%E7%89%87%E6%9C%BA%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    <id>http://example.com/2023/03/23/041-%E5%8D%95%E7%89%87%E6%9C%BA%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</id>
    <published>2023-03-23T20:35:48.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引脚英文缩写解释"><a href="#引脚英文缩写解释" class="headerlink" title="引脚英文缩写解释"></a>引脚英文缩写解释</h3><h4 id="GND"><a href="#GND" class="headerlink" title="GND"></a>GND</h4><p>GND 是 Ground 的缩写，通常翻译为“地”或“接地”，是电路中的一个重要概念。在电路中，GND 通常指代电路的零电位或参考电位，它是一个共同的参考点，用于给电路中的各个部分提供一个共同的电位基准。</p><p>在单片机中，GND 通常是微控制器芯片的引脚之一，用于连接到电路板的地线。在连接外设和其他电路元件时，通常需要将这些元件的 GND 连接到微控制器芯片的 GND 引脚上，以确保整个电路的电势参考是相同的，从而保证电路正常运行。</p><h4 id="5V-amp-3-3V"><a href="#5V-amp-3-3V" class="headerlink" title="5V &amp; 3.3V"></a>5V &amp; 3.3V</h4><p>5V 和 3.3V 是单片机常用的两种电压。它们分别代表着 5 伏特和 3.3 伏特的电压水平。在单片机中，这些电压通常用于给微控制器芯片和其他电路元件提供电源电压。</p><p>5V 通常是较高的电压，可以提供更大的电流和更高的功率，适合驱动需要较大功率的元件，如大型电机、继电器、LED 灯等。在单片机中，5V 通常是由外部电源提供的，比如 AC 电源经过整流、滤波、稳压等步骤得到的直流电源。</p><p>而 3.3V 则是较低的电压，通常用于驱动数字电路、存储器、传感器等低功率元件。相较于 5V，3.3V 可以降低功耗，减少电路中元件的发热和寿命损耗。在单片机中，3.3V 通常是由内部稳压器产生的，通过对 5V 电压进行稳压而得到的。</p><p>需要注意的是，单片机中的 5V 和 3.3V 电源引脚的电流输出能力是有限的，不能超过其规定的最大值，否则会造成电路故障或烧毁元件。因此，在设计电路时需要根据实际需求和元件的规格选择适当的电源电压。</p><h4 id="RXD-amp-TXD"><a href="#RXD-amp-TXD" class="headerlink" title="RXD &amp; TXD"></a>RXD &amp; TXD</h4><p>RXD 和 TXD 分别是串行通信中的接收器数据线和传输器数据线，它们通常是单片机芯片上的引脚之一。在串行通信中，TXD 用于发送数据位序列，RXD 用于接收数据位序列。</p><p>当一个设备向另一个设备发送数据时，发送器将数据位序列传输到 TXD 引脚，然后将这些数据位序列转换成一个数据帧，该数据帧包含用于标识和检测数据的同步和校验位。接收器通过 RXD 引脚接收数据帧，并根据同步和校验位确定是否正确接收了数据。如果接收器成功接收了数据，则可以将这些数据用于后续操作。</p><p>在单片机系统中，TXD 和 RXD 引脚通常用于与外部设备进行串行通信，例如与传感器、显示屏、GPS 接收器等设备进行通信。单片机可以使用内置串行通信模块或外部串行通信芯片来实现与这些设备的通信。</p><p>需要注意的是，不同的串行通信协议（如 UART、SPI、I2C 等）具有不同的数据传输方式和电信号特性，因此需要根据实际情况来选择正确的串行通信协议和接口引脚。</p><h4 id="DAC、ADC-amp-TPAD"><a href="#DAC、ADC-amp-TPAD" class="headerlink" title="DAC、ADC &amp; TPAD"></a>DAC、ADC &amp; TPAD</h4><p>DAC、ADC 和 TPAD 都是单片机中常见的模拟电路模块，分别用于数字信号到模拟信号的转换、模拟信号到数字信号的转换和触摸检测。</p><p>DAC（Digital-to-Analog Converter，数字模拟转换器）是一种电路，用于将数字信号转换为模拟信号。DAC 可以将数字数据（例如二进制数据）转换为模拟信号，如电压或电流。在单片机应用中，DAC 通常用于输出模拟电压，以控制电路的各种操作，例如输出音频信号、控制电机转速等。</p><p>ADC（Analog-to-Digital Converter，模拟数字转换器）是一种电路，用于将模拟信号转换为数字信号。ADC 可以将模拟电压或电流转换为数字数据（例如二进制数据），以便单片机可以使用这些数据进行数字信号处理。在单片机应用中，ADC 通常用于读取传感器输出的模拟信号、检测电池电压、读取温度传感器等。</p><p>TPAD（Touch Pad，触摸检测器）是一种用于检测触摸的电路模块。TPAD 通常使用传感器或电容触摸技术来检测用户触摸板上的位置和动作。在单片机应用中，TPAD 可以用于设计触摸开关、触摸屏、触摸按钮等应用场景。</p><h4 id="PWR"><a href="#PWR" class="headerlink" title="PWR"></a>PWR</h4><p>在单片机系统中，PWR 通常是指电源或电源管理电路。PWR 是提供单片机系统所需电压的电源电路或芯片，它可以提供不同电压级别的电源输出，以满足单片机和外部电路的不同电源需求。</p><p>PWR 的主要功能包括：稳定电压输出、保护电路和检测电源状态。PWR 通常包括稳压器、滤波器、过压保护、欠压保护和电源监测等功能，以确保单片机系统在不同的工作条件下都能正常工作。</p><h4 id="VEXT"><a href="#VEXT" class="headerlink" title="VEXT"></a>VEXT</h4><p>VEXT 通常是指在某些嵌入式系统或单片机板上的扩展电源引脚，用于提供外部设备的电源。</p><p>在一些嵌入式系统或单片机板上，VEXT 可能是一个电源引脚，通常用于提供外部设备的电源。VEXT 通常会被设计为可编程的，以便用户可以根据需要设置电源的电压和电流，以满足外部设备的电源要求。VEXT 通常需要在代码中进行配置和初始化，以确保其正确工作。</p><h4 id="TX-amp-RX"><a href="#TX-amp-RX" class="headerlink" title="TX &amp; RX"></a>TX &amp; RX</h4><p>TX 和 RX 是串行通信中常用的引脚名称，分别表示发送（Transmit）和接收（Receive）数据的引脚。</p><p>在串行通信中，TX 引脚用于将数据从发送端发送到接收端，而 RX 引脚用于将数据从接收端接收到发送端。这种通信方式通常使用串行通信协议，如UART、SPI、I2C等。</p><p>例如，在UART通信中，数据通过TX引脚从发送器发送到接收器的RX引脚。在SPI通信中，数据通过主设备的TX引脚发送到从设备的RX引脚。在I2C通信中，数据通过SDA引脚进行双向传输，而SCL引脚用于时钟同步。</p><h4 id="CLK"><a href="#CLK" class="headerlink" title="CLK"></a>CLK</h4><p>CLK 是时钟信号的缩写，通常用于指示系统中的时钟引脚或时钟信号。在数字系统中，时钟信号是一种特殊的信号，它用于同步系统中的各种操作和数据传输。</p><p>在单片机系统中，CLK 通常用于指示时钟引脚或时钟信号。时钟信号通常由时钟发生器或外部时钟源产生，用于同步单片机内部操作和外部设备之间的数据传输。</p><p>时钟信号的频率通常被称为时钟频率，它表示时钟信号在单位时间内变化的次数。时钟频率越高，系统的运行速度就越快，但同时也会增加系统的功耗和干扰。</p><p>在单片机系统中，CLK 引脚通常用于连接时钟信号源或时钟发生器，以提供系统所需的时钟信号。CLK 引脚的特性和功能取决于具体的单片机型号和应用要求，有些单片机还可能具有多个 CLK 引脚，以支持不同的时钟频率和操作模式。</p><h4 id="DIO"><a href="#DIO" class="headerlink" title="DIO"></a>DIO</h4><p>DIO 是数字输入&#x2F;输出（Digital Input&#x2F;Output）的缩写，通常用于指示数字信号输入&#x2F;输出引脚或数字信号输入&#x2F;输出模块。</p><p>在电子系统中，数字信号是用离散的、二进制的方式表示的信号，通常由 0 和 1 两个状态组成。数字信号输入&#x2F;输出通常用于连接数字传感器、执行器、开关等数字设备或模块，用于接收或输出数字信号。</p><p>DIO 引脚通常用于连接数字输入&#x2F;输出设备或模块，以实现数字信号的输入或输出。数字输入&#x2F;输出设备通常由数字电路和数字信号转换电路组成，可以将输入的数字信号转换为电压或电流信号，或者将输出的电压或电流信号转换为数字信号。</p><p>在单片机系统中，DIO 引脚通常用于连接数字输入&#x2F;输出设备或模块，以实现与外部数字设备的通信和控制。DIO 引脚的数量、特性和功能取决于具体的单片机型号和应用要求，有些单片机还可能具有多个 DIO 引脚，以支持更多的数字输入&#x2F;输出设备或模块。</p><h4 id="TRST-amp-NRST"><a href="#TRST-amp-NRST" class="headerlink" title="TRST &amp; NRST"></a>TRST &amp; NRST</h4><p>TRST 和 NRST 都是芯片或系统的复位引脚，但两者有着不同的特点和用途。</p><p>TRST 是 Test Reset 的缩写，通常用于调试接口或测试引脚中的复位信号。TRST 引脚通常用于测试和调试芯片或系统，以实现调试和测试的目的。TRST 通常是一个可选的引脚，不是所有的芯片或系统都支持 TRST 功能。</p><p>NRST 是 Negative Reset 的缩写，通常用于将芯片或系统复位到初始状态。NRST 引脚通常用于连接复位电路或复位按钮，以实现芯片或系统的复位。NRST 通常是必选的引脚，所有的芯片或系统都需要支持 NRST 功能。</p><p>另外，TRST 和 NRST 的电平和信号特性也有所不同。TRST 通常需要提供低电平或负电平的复位信号，而 NRST 则需要提供高电平或正电平的复位信号。在使用 TRST 或 NRST 引脚时，需要根据具体的芯片或系统规格和需求，选择合适的电平和信号特性，以确保复位信号的正确性和可靠性。</p><h4 id="TDI-amp-TDO"><a href="#TDI-amp-TDO" class="headerlink" title="TDI &amp; TDO"></a>TDI &amp; TDO</h4><p>TDI 是 Test Data Input 的缩写，通常用于指示调试接口或测试引脚中的测试数据输入引脚。TDI 通常用于在调试或测试过程中向目标系统或芯片输入测试数据，以进行测试或调试操作。</p><p>TDO 是 Test Data Output 的缩写，通常用于指示调试接口或测试引脚中的测试数据输出引脚。TDO 通常用于在调试或测试过程中从目标系统或芯片输出测试数据，以进行测试或调试操作。</p><h4 id="TMS"><a href="#TMS" class="headerlink" title="TMS"></a>TMS</h4><p>TMS 是 Test Mode Select 的缩写，通常用于指示调试接口或测试引脚中的测试模式选择引脚。TMS 通常用于在调试或测试过程中控制目标系统或芯片的测试模式，以进行测试或调试操作。</p><h4 id="TCK"><a href="#TCK" class="headerlink" title="TCK"></a>TCK</h4><p>TCK 是 Test Clock 的缩写，通常用于指示调试接口或测试引脚中的测试时钟引脚。TCK 通常用于在调试或测试过程中提供目标系统或芯片的时钟信号，以进行测试或调试操作。</p><h4 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h4><p>NC 通常是 Not Connected 的缩写，表示该引脚没有连接到任何电路或设备，即未连接（Not Connected）。在电路设计或器件规格中，NC 通常用于表示某些引脚或端口不需要使用，或者暂时没有使用。</p><h3 id="其他英文缩写解释"><a href="#其他英文缩写解释" class="headerlink" title="其他英文缩写解释"></a>其他英文缩写解释</h3><h4 id="JTAG、SWD-amp-STP"><a href="#JTAG、SWD-amp-STP" class="headerlink" title="JTAG、SWD &amp; STP"></a>JTAG、SWD &amp; STP</h4><p><strong>JTAG</strong> 是 Joint Test Action Group 的缩写，也称为 IEEE 1149.1 标准，是一种用于测试和调试集成电路的标准接口协议。JTAG 通常用于连接调试工具和测试设备，实现对芯片或系统的测试和调试操作。</p><p>JTAG 接口标准定义了一组标准化的测试和调试信号，包括 Test Clock (TCK)、Test Mode Select (TMS)、Test Data Input (TDI)、Test Data Output (TDO) 和 Test Reset (TRST) 等信号。这些信号通常通过一个标准的接口进行连接，以实现芯片或系统的测试和调试功能。</p><p>JTAG 接口通常包括两种工作模式，一种是测试模式，用于对芯片或系统进行测试和调试；另一种是生产模式，用于生产过程中的编程和测试。JTAG 接口也支持芯片或系统的在线编程和调试，以及实时监测芯片或系统的运行状态和性能指标。</p><p><strong>SWD</strong> 是 Serial Wire Debug 的缩写，是一种用于调试嵌入式系统的接口协议。SWD 接口是 ARM 公司开发的，通常用于连接调试工具和目标芯片，实现对芯片的调试和测试操作。</p><p>SWD 接口包括两根线：SWDIO 和 SWCLK。其中，SWDIO 是双向数据线，用于在芯片和调试工具之间传输数据，包括调试命令和数据；SWCLK 是单向时钟线，用于提供时钟信号，控制数据的传输和接收。</p><p>SWD 接口通常采用 2 线模式或 4 线模式。在 2 线模式下，只需要使用 SWDIO 和 SWCLK 两根线；在 4 线模式下，除了 SWDIO 和 SWCLK，还需要使用另外两根线，分别是 RESET 和 SWO。RESET 用于芯片的复位，SWO 用于从芯片输出调试数据。</p><p><strong>STP</strong> 是 Serial Test and Programming 的缩写，是一种用于调试和编程集成电路的接口协议。STP 接口是 TI 公司开发的，通常用于连接调试工具和目标芯片，实现对芯片的调试和编程操作。</p><p>STP 接口包括两根线：STPDI 和 STPDO。其中，STPDI 是双向数据线，用于在芯片和调试工具之间传输数据，包括调试命令和数据；STPDO 是单向数据线，用于芯片从调试工具读取数据。</p><p>STP 接口支持多种操作模式，包括调试模式、编程模式、读出模式等。调试模式用于实时监测芯片的运行状态和性能指标；编程模式用于对芯片进行在线编程和调试；读出模式用于从芯片读取数据。</p><p>三者的区别主要在于接口协议的实现方式、连接线的数量和接口功能的不同。它们的联系主要在于都是用于调试和编程集成电路的接口协议，都需要连接调试工具和目标芯片，实现对芯片的调试和编程操作。此外，JTAG、SWD 和 STP 的应用和实现也受到芯片和系统的具体要求和规格的影响。</p><h4 id="J-Link"><a href="#J-Link" class="headerlink" title="J-Link"></a>J-Link</h4><p>J-Link 是一种由 SEGGER 公司开发的通用 JTAG&#x2F;SWD 调试器和仿真器，用于连接调试工具和目标芯片，实现对芯片的调试、测试和编程操作。J-Link 支持多种调试接口协议，包括 JTAG、SWD、STP 等，可以实现对多种芯片和系统的调试和编程功能。</p><p>J-Link 通常包括硬件和软件两部分。硬件部分包括 J-Link 调试器本身，以及与芯片和目标系统连接的接口线。J-Link 调试器可以提供高速、稳定的调试和仿真功能，支持多种工作模式和操作模式，包括在线调试、离线调试、仿真模式等。接口线通常包括不同的接口头和线缆，以适配不同的芯片和目标系统。</p><p>软件部分包括 J-Link 调试器驱动程序和调试工具软件。J-Link 调试器驱动程序用于与操作系统和调试工具软件通信，以实现对芯片和目标系统的调试和编程操作。调试工具软件包括多种调试工具和 IDE，如 J-Link GDB Server、J-Link Flash Programmer、J-Link Integrated Development Environment（IDE）等，以提供全面的调试和编程功能。</p><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>Integrated Development Environment（IDE）是一种集成的开发环境，用于开发、调试和测试软件应用程序。IDE 通常包括多个组件，如源代码编辑器、编译器、调试器、版本控制工具、图形界面设计工具、文档生成工具等，以提供全面的软件开发和测试功能。</p><p>IDE 主要用于软件开发过程中的集成化、协同化和自动化，可以提高开发效率和软件质量，减少错误和重复工作。IDE 通常提供多种功能和工具，如代码自动补全、语法检查、代码重构、调试跟踪、性能分析、测试工具等，可以帮助开发人员在更短的时间内开发出高质量的软件应用程序。</p><p>IDE 的实现和应用广泛，适用于多种软件开发环境和语言，如 C、C++、Java、Python 等。不同的 IDE 也具有不同的特点和优势，可以根据具体的软件开发需求和环境进行选择和使用。</p><h4 id="Winbond-W9825G6KH-6"><a href="#Winbond-W9825G6KH-6" class="headerlink" title="Winbond W9825G6KH-6"></a>Winbond W9825G6KH-6</h4><p>Winbond W9825G6KH-6 是一种 SDRAM 存储器，属于 Winbond 公司生产的 W98 系列产品。该产品具有 256M 位的容量，数据传输速度为 166MHz，采用 4 个银河内部银行和 4 个独立外部银行的设计，支持 4bit 和 8bit 的预取数据。此外，W9825G6KH-6 还采用了低功耗设计，具有广泛的应用和优秀的性能特点。</p><p>W9825G6KH-6 适用于各种存储设备和系统中，如智能手机、平板电脑、网络通讯、工业控制、汽车电子等领域。该产品采用了高速、稳定、可靠的设计，可以满足客户的不同需求，并且具有优秀的性能和可靠性，得到了广泛的应用和好评。</p><p>（Winbond 是一家专门从事闪存存储器、DRAM 存储器、语音 IC、微控制器和系统软件等领域的半导体公司。其总部位于台湾，成立于1987年，目前已经成为全球领先的半导体公司之一。</p><p>Winbond 公司主要的产品包括闪存存储器、DRAM 存储器、语音 IC、微控制器和系统软件等，广泛应用于智能手机、平板电脑、数码相机、网络通讯、工业控制、汽车电子等领域。其中，闪存存储器和DRAM 存储器是 Winbond 公司的核心业务之一，具有高速、稳定、可靠等优点，被广泛应用于各种存储设备和系统中。）</p><h4 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h4><p>USART，全称为 Universal Synchronous&#x2F;Asynchronous Receiver Transmitter，是一种串行通信接口协议，用于实现数据的收发和传输。USART 接口通常包括 TXD（发送端）、RXD（接收端）和时钟等信号线，支持同步和异步两种通信方式，以及多种数据格式和传输速率。</p><p>USART 接口主要应用于嵌入式系统中，可用于与外设或者其他设备进行数据的交换和通信。</p><h4 id="USB-x2F-CAN"><a href="#USB-x2F-CAN" class="headerlink" title="USB&#x2F;CAN"></a>USB&#x2F;CAN</h4><p>USB&#x2F;CAN 是一种 USB 和 CAN 通信接口的组合，用于实现 USB 和 CAN 总线之间的数据交换和通信。USB&#x2F;CAN 接口通常包括 USB 接口和 CAN 总线接口两部分，可以通过 USB 端口与计算机或其他设备相连，实现数据的读写和传输。</p><p>USB&#x2F;CAN 接口通常用于嵌入式系统中，可以用于与外设或其他设备进行数据的交换和通信。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引脚英文缩写解释&quot;&gt;&lt;a href=&quot;#引脚英文缩写解释&quot; class=&quot;headerlink&quot; title=&quot;引脚英文缩写解释&quot;&gt;&lt;/a&gt;引脚英文缩写解释&lt;/h3&gt;&lt;h4 id=&quot;GND&quot;&gt;&lt;a href=&quot;#GND&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="STM32" scheme="http://example.com/categories/STM32/"/>
    
    
    <category term="名词解释" scheme="http://example.com/tags/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
    <category term="单片机" scheme="http://example.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>路由器测速报告</title>
    <link href="http://example.com/2023/03/21/040-%E8%B7%AF%E7%94%B1%E5%99%A8%E6%B5%8B%E9%80%9F%E6%8A%A5%E5%91%8A/"/>
    <id>http://example.com/2023/03/21/040-%E8%B7%AF%E7%94%B1%E5%99%A8%E6%B5%8B%E9%80%9F%E6%8A%A5%E5%91%8A/</id>
    <published>2023-03-21T18:04:40.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>H3C Magic RC3000 千兆双频 WIFi6+ 路由器（电信送）</li><li>Redmi AX6S（京东购入）</li></ul><h3 id="测速网站"><a href="#测速网站" class="headerlink" title="测速网站"></a>测速网站</h3><ul><li><a class="link"   href="https://www.speedtest.cn/" >测速网<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="http://speedtest.jsinfo.net/2000m/index.html" >中国电信宽带助手<i class="fas fa-external-link-alt"></i></a></li></ul><h3 id="测速结果"><a href="#测速结果" class="headerlink" title="测速结果"></a>测速结果</h3><table><thead><tr><th align="center">Magic RC3000</th><th align="center">测速网</th><th align="center">电信宽带助手</th></tr></thead><tbody><tr><td align="center">有线</td><td align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-19%20230818.png" alt="屏幕截图 2023-03-19 230818"></td><td align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230321182014002.png" alt="image-20230321182014002"></td></tr><tr><td align="center">无线</td><td align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230321182352318.png" alt="image-20230321182352318"></td><td align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230321182216178.png" alt="image-20230321182216178"></td></tr></tbody></table><table><thead><tr><th align="center">Redmi AX6S</th><th align="center">测速网</th><th align="center">电信宽带助手</th></tr></thead><tbody><tr><td align="center">有线</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">无线</td><td align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230321181829119.png" alt="image-20230321181829119" style="zoom:83%;" /></td><td align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230327165617623.png" alt="image-20230327165617623"></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;硬件&quot;&gt;&lt;a href=&quot;#硬件&quot; class=&quot;headerlink&quot; title=&quot;硬件&quot;&gt;&lt;/a&gt;硬件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;H3C Magic RC3000 千兆双频 WIFi6+ 路由器（电信送）&lt;/li&gt;
&lt;li&gt;Redmi AX6S（京东购入）&lt;</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="路由器" scheme="http://example.com/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    <category term="测速" scheme="http://example.com/tags/%E6%B5%8B%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>PassWall-入门及进阶</title>
    <link href="http://example.com/2023/03/17/039-PassWall-%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2023/03/17/039-PassWall-%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6/</id>
    <published>2023-03-17T17:24:43.000Z</published>
    <updated>2023-04-14T04:13:23.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Openwrt-上网配置"><a href="#Openwrt-上网配置" class="headerlink" title="Openwrt 上网配置"></a>Openwrt 上网配置</h3><p>在左栏点开【服务】，可以看到已经预装了很多插件。这篇文章详细讲解 PassWall 的基本使用和进阶教程。左图是我的，右图是参考链接博主<sup>[1]</sup>的。可以看出来很明显的不一样。</p><table><thead><tr><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230317172829389.png" alt="image-20230317172829389" style="zoom:50%;" /></th><th align="center"><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230317173059002.png" alt="image-20230317173059002" style="zoom:50%;" /></th></tr></thead></table><h3 id="PassWall-基本使用教程"><a href="#PassWall-基本使用教程" class="headerlink" title="PassWall 基本使用教程"></a>PassWall 基本使用教程</h3><p>打开 PassWall，可以看到上方菜单栏有非常多的选项。而我们不需要关注那么多，只需要了解【基本设置】、【节点列表】、【自动切换】、【高级设置】、【节点订阅】、【规则列表】、【访问控制】。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230317182909708.png" alt="image-20230317182909708" style="zoom:36.5%;" /><h4 id="订阅机场链接"><a href="#订阅机场链接" class="headerlink" title="订阅机场链接"></a>订阅机场链接</h4><p>打开机场，复制订阅链接。如果有多个订阅链接，选择复制 SSR 订阅链接。</p><p>回到 PassWall，打开【节点订阅】，拉到最下面，点击<code>添加</code>，依次输入<code>备注（可选）</code>、<code>订阅 URL（必填）</code>。其他一概默认即可。点击<code>保存&amp;应用</code>。返回至【节点订阅】界面后，点击上面的<code>手动订阅</code>，会跳转到【查看日志】界面，订阅成功后会显示一共解析出多少个节点。【节点订阅】界面内容一概默认即可，尤其不要勾选<code>通过代理订阅</code>。打开【节点列表】界面，可以看到解析出的所有节点。另外，Ping 值没有任何意义。一般考虑带宽和拥堵情况来判断节点的好坏。</p><h4 id="使用节点"><a href="#使用节点" class="headerlink" title="使用节点"></a>使用节点</h4><p>打开【基本设置】界面，点开<code>主要</code>，TCP 节点选择一个节点，UDP 节点选择<code>与 TCP 节点相同</code>，勾选<code>主开关</code>。点击右下角<code>保存&amp;应用</code>，然后测试<code>谷歌连接</code>，有数值即可，不必在意数值大小，没有参考意义。此时就可以打开 YouTube。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230317184428471.png" alt="image-20230317184428471" style="zoom:80%;" /><blockquote><p>关于【基本设置】界面的几点说明：</p><p>DNS：不要去动它。</p><p>模式：如果想要调整，只调整<code>TCP 默认代理模式</code> 即可，其他都不要去动它。①不代理：字面意思；②全局代理：字面意思；③GFW 列表：仅那些被防火墙屏蔽的网站才走代理；④中国列表外：国内的所有网站都不走代理，国外的所有网站都走代理（不管是否屏蔽）；⑤中国列表：回国模式，国外网友想翻回国内。</p><p>日志：不要去动它。</p><p>FAQ：小提示，不需要去管它。</p></blockquote><h3 id="PassWall-进阶使用教程"><a href="#PassWall-进阶使用教程" class="headerlink" title="PassWall 进阶使用教程"></a>PassWall 进阶使用教程</h3><h4 id="自动切换"><a href="#自动切换" class="headerlink" title="自动切换"></a>自动切换</h4><p>自动切换 &#x3D; 故障转移。比如说正在使用 A 节点，A 突然不能用了，自动切换到 B，B 突然不能用了，自动切换到 C。</p><p>打开【自动切换】界面。勾选<code>启用</code>，添加<code>TCP 备用节点的列表</code>。勾选<code>TCP 恢复切换</code>，意思是当 TCP 主节点恢复可以使用后，自动切换到主节点。点击<code>保存&amp;应用</code>。设置好后，【自动切换】就会去帮我们自动循环使用这些节点。</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230317190351779.png" alt="image-20230317190351779" style="zoom:50%;" /><h4 id="规则列表"><a href="#规则列表" class="headerlink" title="规则列表"></a>规则列表</h4><p>打开【规则列表】界面。直连列表 &#x3D; 不代理的网站列表（无论之前在【基本设置】界面选择了什么模式）。代理列表与之相反。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>【访问控制】控制的是局域网内的设备，也就是连接到该路由器的设备。主要是来决定是否让它科学上网？使用什么节点科学上网？使用什么模式科学上网？</p><p>专业名词：桥接、AP、有线中继……（必须在同一网段才能控制）。</p><h4 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h4><p>我的这个 PassWall 好像是被阉割过的。但是高级设置并用不到。和访问控制搭配食用。用于决定某设备走哪个节点，走什么模式等。</p><h4 id="分流"><a href="#分流" class="headerlink" title="分流"></a>分流</h4><p>打开【节点列表】界面，点击<code>添加</code>，<code>类型</code>选择 <code>V2ray</code>（<code>Xray</code> 目前可直接兼容 <code>V2ray</code> 并使用），<code>协议</code>选择<code>分流</code>，然后对分流规则里提供的网站分别选择节点，<code>前置代理</code>勾选就是使用默认节点，所以关闭即可。然后回到【基本设置】界面，在<code>主要</code>→<code>TCP 节点</code>中可以选择 <code>Xray 分流：[分流总节点]</code>，下面又是对给网站的一个配置。（好像也不需要）</p><img src="https://storybeginswhenicu.oss-cn-hangzhou.aliyuncs.com/img/image-20230317222222560.png" alt="image-20230317222222560" style="zoom:80%;" /><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a class="link"   href="https://www.youtube.com/watch?v=H83J0JPD1-k&t=666s" >「275」 小白必看！OpenWrt下科学插件PassWall&amp;SSRP家教级入门和进阶使用 - YouTube<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Openwrt-上网配置&quot;&gt;&lt;a href=&quot;#Openwrt-上网配置&quot; class=&quot;headerlink&quot; title=&quot;Openwrt 上网配置&quot;&gt;&lt;/a&gt;Openwrt 上网配置&lt;/h3&gt;&lt;p&gt;在左栏点开【服务】，可以看到已经预装了很多插件。这篇文章详细</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="PassWall" scheme="http://example.com/tags/PassWall/"/>
    
    <category term="节点" scheme="http://example.com/tags/%E8%8A%82%E7%82%B9/"/>
    
  </entry>
  
</feed>
