[{"title":"Hello World","url":"/2022/10/25/001-hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub..\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nTest\n","categories":["博客"],"tags":["Hexo","Command"]},{"title":"更换 Keep 主题","url":"/2022/09/14/002-%E6%9B%B4%E6%8D%A2-Keep-%E4%B8%BB%E9%A2%98/","content":"偶尔浏览到某站点，看起来比 NexT 更简洁大方，尤其是手机网页浏览，主页不显得那么臃肿。拉到最后发现是 Keep。于是重新动手配置。\n本地搭建Hexo 安装npm install -g hexo-cli\n\nHexo 初始化hexo init # 初始化npm install # 安装组件\n\n启动本地服务器预览hexo g # 生成页面hexo s # 启动预览\n\n访问 http://localhost:4000，出现 Hexo 默认界面，本地安装成功。\nGitHub 推送安装 hexo-deployer-git 插件\nnpm install hexo-deployer-git --save\n\n运行以下命令：\nhexo cleanhexo g --d\n\n（有时会因为网络问题出现错误，建议再来一次或者更换网络。）\nKeep 主题安装安装使用 Git 克隆整个仓库：\ngit clone https://github.com/XPoet/hexo-theme-keep themes/keep\n\n配置配置指南 | hexo-theme-keep (xpoet.cn)\n","categories":["博客"],"tags":["Themes","Keep"]},{"title":"为什么学习矩阵","url":"/2022/09/14/003-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E7%9F%A9%E9%98%B5/","content":"看了网上别人说的，并没有真正解答我的疑惑。大概是我还没有把矩阵用到科研中，平时也就解解题，所以才会感到迷茫。应该着重收集，看一下相关论文中的公式表达，数学建模都是怎么搞的。先把《线性代数》这本书找来好好看看，把重要的知识点记录下来，为《矩阵分析与计算》这门课打好基础。\n矩阵扫盲\n\n\n行列式\n矩阵\n\n\n\n\n\n\n\n\n行列式：是指将一些数据建立成计算方阵，经过规定的计算方法最终得到一个数。换句话说，行列式代表的是一个值。\n矩阵：矩阵表示的是一个数表，是一个数据的集合体。换句话说，矩阵更神似于一张 m 行 n 列的数字表格，或者 Excel 表。\n\n当第一个矩阵的列数与第二个矩阵的行数相同时，才能相乘。如  为  的矩阵， 为  的矩阵，那么称  的矩阵  为矩阵  与矩阵  的乘积。记作 。如下所示：\n\n线性变换：向量空间  到其自身的映射成为  的变换， 到  的线性映射成为  的线性变换。简言之，线性映射就是保持线性关系的映射。\n\n","categories":["思考"],"tags":["数学","矩阵"]},{"title":"STM32 入门篇","url":"/2022/11/03/004-STM32-%E5%85%A5%E9%97%A8%E7%AF%87/","content":"软件安装与环境配置\nSetupSTM32CubeMX-6.2.0-Win.exe：STM32CubeMX 本体，免费\njre-8u211-windows-x64.exe：JAVA 环境，免费\nMDK521A.exe：Keil5，开发环境，收费\nKeil.STM32F4xx_DFP.2.9.0.pack：F429 芯片支持包\nkeygen_new2032.exe：破解 Keil5\nXCOM V2.3.exe：串口调试助手（正点原子开发）\n\nGPIO 开发基础\nSTM32 最多拥有 GPIOA、GPIOB……GPIOG 等 7 组端口。每组端口最多拥有 Pin0、Pin1……Pin15 共 16 个引脚。（最多拥有 7 * 16 &#x3D; 112 个引脚）（有的引脚会直接命名为 PA3、PB3 这种，是端口和引脚号写在了一起）\nSTM32 的每个 I&#x2F;O 端口都可以自由编程，但 I&#x2F;O 端口寄存器必须按 32 位字被访问。\nSTM32 的每个 I&#x2F;O 端口都由 7 个寄存器控制。\nSTM32 的 I&#x2F;O 端口可以由软件配置成 8 种模式。（通过 STM32CubeMX 里的图像化界面，配置好功能，直接生成初始化代码）\n输出\n推挽输出：指普通的高低电平输出。\n开漏输出\n推挽式复用功能\n开漏式复用功能\n\n\n输入\n模拟输入（AD 转换的模拟信号）\n浮空输入\n下拉输入\n上拉输入\n\n\n\n\n\n三个 GPIO 输出的 HAL 库函数\nGPIO 电平输出 HAL 库函数\nvoid HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);\n\n\nGPIOx：目标引脚的端口号（填 A、B、C……）。\nGPIO_Pin：目标引脚的引脚号。\nPinState：高电平 GPIO_PIN_SET；低电平 GPIO_PIN_RESET。\n\n【例】：向 PB8 引脚输出高电平。\nHAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);\n\nGPIO 电平翻转 HAL 库函数\nvoid HAL_GPIO_TogglePin(GPIO_Type* GPIOx, unit16_t GPIO_Pin);\n\n【例】：将 PA3 引脚输出电平翻转。\nHAL_GPIO_TogglePin(GPIOA, GPIO_PIN_3);\n\nGPIO 电平输入 HAL 库函数\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); //具有返回值\n\n【例】：判断 PC13 引脚的输入信号，若为高电平，则将 PB9 引脚控制的 LED 等的开关状态切换。\nif(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET)&#123;    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_9);&#125;\n\nGPIO 的重要数据结构（待补充）\n实训：跑马灯实现流程\n打开 STM32CubeMX 软件。\n\n选择对应的 MCU：ACCESS TO MCU SELECTOR。\n\n把自己开发板芯片的型号输入到搜索框中，选中后，点击 Start Project。\n\n进行基本配置。\n\nSystem Core，SYS。配置仿真口。可选择 SW 或 JTAG 口。 \nSystem Core，RCC。配置时钟。选完后可以看到有针脚变颜色。然后还需配置时钟树。\n\n\n配置 LED 灯所对应的针脚。每个针脚只能选一个功能。\n\n配置完成后。对项目进行命名。选择开发环境 MDK-ARM V5。在代码器（Code Generator）勾选 Generate peripheral initialization as a pair of ‘.c&#x2F;.h’ files per peripheral。点击右上角 GENERATE CODE。\n\n打开文件夹，在 MDK-ARM 文件夹中，找到带有 Keil5 工程图标的文件，双击打开。\n\n打开项目后，先进行一次编译，目的是检查默认代码有没有问题，同时把 main.c 文件相关的头文件关联出来。\n\n应用代码写在以下注释中间。重新配置工程文件时，放在这里面的代码会被保留下来，其他代码会覆盖掉。\n/* USER CODE BEGIN 0 *//* USER CODE END 0 */\n\n在 int main(void) 中的 MX_GPIO_Init() 写代码。\n/* Infinite loop *//* USER CODE BEGIN WHILE */while(1)&#123;    /* USER CODE END WHILE */        /* USER CODE BEGIN 3 */\t\t    /* LED0 RED 闪烁，方式 1，写高低电平。阿波罗的板子，低电平亮，高电平灭 */    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);    HAL_Delay(1000);    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);    HAL_Delay(1000);\t\t    /* LED0 RED 闪烁，方式 2，写翻转电平 */\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);\tHAL_Delay(200);\t&#125;/* USER CODE END 3 */\n\n编译后，下载到开发板上。按下开发板的复位键，可以看到 LED0 RED 闪烁。\n\n\nSTM32 的按键开发基础基本原理\n按键信号的识别：一般来说，按键的两个引脚的一端通过电阻上拉到高电平，另一端则接地。没有按键按下时，输入引脚为高电平。当有按键按下，输入引脚则为低电平。通过反复读取按键输入引脚的信号，然后识别高低电平来判断是否有按键触发。\n去抖动：按键的输入引脚有低电平产生不代表一定是有按键按下，也许是干扰信号。因此需要通过去抖动处理将这些干扰信号过滤，从而获得真实的按键触发信号。方法：首次检测到按键输入引脚有低电平后，稍作延时，再次读取该引脚，如果还是低电平，则确认有按键触发信号；否则，判断为干扰信号，不予处理。\n\n实训：按键控制 LED 灯开关利用 STM32CubeMX 和 Keil5 进行 STM32 应用开发，完成以下功能：\n\n按下 KEY0（PH3）按键，松开后，切换 LED0（PB1）的开关状态。\n按下 KEY1（PH2）按键，切换 LED1（PB0）的开关状态。\n按下 KEY2（PC13）按键，把点亮的 LED 灯全部关闭。\n\n/* USER CODE BEGIN 0 */#define KEY0 HAL_GPIO_ReadPin(GPIOH, GPIO_PIN_3)#define KEY1 HAL_GPIO_ReadPin(GPIOH, GPIO_PIN_2)#define KEY2 HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13)void Scan_Keys()&#123;\tif(KEY0 == 0)\t&#123;\t\tHAL_Delay(100);                           //直接用 HAL 库的延时函数\t\tif(KEY0 == 0)                             //按下为低电平，可以直接用 0 表示，不过最好还是用 GPIO_PIN_RESET\t\t&#123;\t\t\twhile(KEY0 == 0);                     //while 很好用\t\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);\t\t&#125;\t&#125;\t\tif(KEY1 == 0)\t&#123;\t\tHAL_Delay(100);\t\tif(KEY1 == 0)\t\t&#123;\t\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);\t\t\twhile(KEY1 == 0);\t\t&#125;\t&#125;\t\tif(KEY2 == 0)\t&#123;\t\tHAL_Delay(100);\t\tif(KEY2 == 0)\t\t&#123;\t\t\tHAL_GPIO_WritePin(GPIOB, GPIO_PIN_0 | GPIO_PIN_1, GPIO_PIN_SET);\t\t\twhile(KEY2 == 0);\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */----------------------------------------------------------------------------/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123;    Scan_Keys();\t/* USER CODE END WHILE */    /* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\nSTM32 的中断系统与外部中断基础名词扫盲\n中断：\n中断源：\n中断向量：\n中断优先级：\n中断服务函数：\n\n中断系统ARM Cortex M3 内核支持 256 个中断，包括 16 个内核中断和 240 个外设中断，拥有 256 个中断优先级别。\nSTM32 的中断通道可能会由多个中断源共用。这就意味着，某一个中断服务函数也可能被多个中断源所共用。所以，在中断服务函数的入口处，需要有一个判断机制，用以辨别是哪个中断出发了中断。\nSTM32 中有 2 个优先级的概念：抢占优先级和响应优先级，每个中断都需要指定这两种优先级。\nCortex M3 内核中有一个称为嵌套向量中断控制器（NVIC）的设备，对中断进行统一的协调和控制。其中最主要的工作就是控制中断使能和确定中断优先级。\n外部中断外部中断 EXTI 是 STM32 芯片实时处理外部事件的一种机制，由于中断请求来自 GPIO 端口的引脚，所以称为外部中断。\nSTM32 芯片有 16 个外部中断源 EXTI0~EXTI15，分别对应这 7 个中断向量，也就是对应着 7 个中断服务函数。\n\nEXTI0、1、2、3、4：专用。（5:5）\nEXTI5~9：共用。（5:1）\nEXTI10~15：共用。（6:1）\n\nEXTI0 的连接引脚是：PA0~PG0，即每个端口组的 0 号引脚。以此类推。\n\n\n外部中断触发条件：上升沿触发、下降沿触发或双边沿触发。注意：不能配置成高电平触发和低电平触发。\n外部中断的程序设计思路：\n传统的：\n\n将 GPIO 初始化为输入端口。\n配置相关 I&#x2F;O 引脚与中断线的映射关系。\n设置该 I&#x2F;O 引脚对应的中断触发条件。\n配置 NVIC，并使能中断。\n编写中断服务函数。\n\n基于 STM32CubeMX 的外部中断设计步骤：\n\n在 STM32CubeMX 中指定引脚，配置中断初始化参数。\n重写该 I&#x2F;O 引脚对应的中断回调函数。\n\n【例】将 PC13 引脚设置为外部中断，下降沿触发，在中断服务函数中，翻转 PB9 引脚的电平信号。1. \n\n初始化配置\n将 GPIO 设置为：GPIO_EXTI 功能。\n设置中断触发条件：上升沿、下降沿、上升沿或下降沿。\n使能相关的 NVIC 通道。\n\n\n中断服务函数编写\n\n实训：外部中断信号控制 LED 灯开关利用 STM32CubeMX 和 Keil5 进行 STM32 应用开发，完成以下功能：\n\n将 KEY0，即 PH3 设置为外部中断输入，下降沿触发。在中断服务函数中，切换 LED0（PB1）的开关状态。\n将 KEY1，即 PH2 设置为外部中断输入，上升沿触发。在中断服务函数中，切换 LED1（PB0） 的开关状态。\n\n【注】这个题目的代码很简单，重写虚函数（weak void）即可。主要在于 STM32 中的参数配置，这里折腾了很久，调试经验如下：\n\n配置 RCC：选择 Crystal&#x2F;Ceramic Resonator 即可，不需要去 Clock Configuration 中进行修改。（原理之后学到来补充，占坑）\n配置 GPIO：上升&#x2F;下降沿分别是 External Interrupt Mode with Rising&#x2F;Falling edge trigger detection。一定都选择上拉（Pull-up）。\n最后按键按的时候，可能会出现时亮时不亮，这是因为没有进行按键消抖，触发两次或者是没有触发。\n\n/* USER CODE BEGIN 0 */void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)&#123;\tif(GPIO_Pin == GPIO_PIN_3)\t&#123;\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);\t&#125;\t\tif(GPIO_Pin == GPIO_PIN_2)\t&#123;\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);\t&#125;&#125;/* USER CODE END 0 */\n\nSTM32 的定时器开发基础常见定时器资源\n系统嘀嗒定时器 SysTick\n集成在 Cortex M3 内核。\n\n看门狗定时器 WatchDog\n\n实时时钟 RTC\n\n基本定时器：TIM6、TIM7\n\n通用定时器：TIM2、TIM3、TIM4、TIM5\n在基本定时器的基础上，实现输出比较、输入捕获、PWM 生成、单脉冲模式输出等功能。这类定时器最具代表性，使用也最广泛。\n\n高级定时器：TIM1、TIM8\n\n\n通用定时器STM32 的通用定时器是一个通过可编程预分频器（Prescaler）驱动的 16 位自动重装主计数器（Counter Period）构成。可以对内部时钟或触发源以及外部时钟或触发源进行计数。\n\n基本工作原理\n首先，定时器时钟信号送入 16 位可编程预分频器（Prescaler），该预分配器系数为 0~65535 之间的任意数值。预分配器溢出后，会向 16 位的主计数器（Counter Period）发出一个脉冲信号。\n预分频器，本质上是一个加法计数器。预分频系数实际上就是加计数的溢出值。\n\n定时器发生中断时间的计算方法\n定时时间 &#x3D; （Prescaler + 1）X（Counter Period + 1）X 1&#x2F;定时器时钟频率S\n\n\n【例】时钟信号 1KHz，Prescaler 为 9，Counter Period 为 999，定时时间？\n\n\nSTM32CubeMX 中关于 TIM 的配置【例】时钟信号 32MHz，每隔 500ms 翻转一次 PB9 的输出电平\n\n设置 Clock Source 时钟源\n设置 Prescaler 和 Counter Period 参数\n设置 NVIC 嵌套向量中断控制器\n\n如何得到 500ms：32000 X 500 X 1&#x2F;32000000 &#x3D; 0.5s &#x3D; 500ms\n因此，Prescaler 为 31999，Counter Period 为 499。\n时钟树相关知识\nSTM32F429 时钟源\nHSI：高速内部时钟，RC 振荡器，16MHz\nLSI：低速内部时钟，RC 振荡器，32KHz\nHSE：高速外部时钟，4-26MHz\nLSE：低速外部时钟，32.768KHz\n\n\n系统时钟 SYSCLK 来源\nHSI\nHSE\nPLL（Phase Locked Loop）：锁相环。用来统一整合时钟信号。\n\n\n其他常用名词扫盲\nAHB（Advanced High-performance Bus）总线\nAPB（Advanced Peripheral Bus）总线\nHCLK：AHB 总线的时钟。\nPCLK1：APB1 总线的时钟\nPCLK2：APB2 总线的时钟\nRTC 实时时钟：一个独立的定时&#x2F;计数器。\n\n\n\n实训：外部中断信号控制 LED 灯开关在 STM32F429 进行 STM32 应用开发，完成以下功能：\n\n利用 TIM2 实现间隔定时，每隔 0.2s 将 LED0（PB1）的开关状态翻转。\n利用 TIM3 实现间隔定时，每隔 1s 将 LED1（PB0）的开关状态翻转。\n修改 TIM2 的初始化代码，改为每隔 0.5s 将 LED1 的开关状态翻转。（在 time.c 文件中，找到 TIM2 的配置代码 void MX_TIM2_Init(void)，把对应的 htim2.Init.Period = 199; 修改为 500 即可。\n\n【注】同样代码很简单，把虚函数放到 main.c 文件中重写即可。主要是在 STM32CubeMX 中配置 TIM2、TIM3。\n\n找到 TIM2&#x2F;3，首先 Clock Source 设置为 Internal Clock；\n因为是 32MHz，所以 Prescaler &#x3D; 31999。\n因为是 0.2s，所以 Period &#x3D; 199（200ms -1）。\n最后一定要勾选上 NVIC。\n\n另外，写完虚函数后，要在 main 函数中启动 TIM2、TIM3。\n/* USER CODE BEGIN 0 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;\tif(htim-&gt;Instance == TIM2)   //如果实例为 TIM2，就运行\t&#123;\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);\t&#125;\t\tif(htim-&gt;Instance == TIM3)\t&#123;\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);\t&#125;&#125;/* USER CODE END 0 */------------------------------------------------------------/* USER CODE BEGIN 2 */\tHAL_TIM_Base_Start_IT(&amp;htim2); //启动函数，前面&amp;表示传地址\tHAL_TIM_Base_Start_IT(&amp;htim3);/* USER CODE END 2 */\n\nSTM32 的串口数据收发基础名词扫盲\n并行&#x2F;串行通信\n\n单工、半双工、全双工\n\n异步串行通信：通信双方在没有同步时钟的前提下，将一个字符（包括特定的附加位）按位进行传输的通信方式。\n\n波特率：每秒钟传输的二进制位数，如 9600bps。\n\nTTL电平←→RS232：MAX3232 SP3232\n串口←→USB 接口：CH340 CP2012\n\nSTM32 芯片的串口 USART 功能十分强大，但对于日常编程而言，使用最多的还是异步串行通信。\n\n\nSTM32CubeMX 中关于 USART 的配置（待补充）\nHAL 库中串口发送的重要函数\n阻塞式发送函数（推荐使用）\nHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, unit32_t Timeout);\n\n非阻塞式发送函数\nHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);\n\n发送完毕中断回调函数\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);\n\n【例】使用非阻塞式的串口发送函数，将发送缓存数组 dat_Txd 中的前 5 个数据发送到 USART1，在数据发送完成后，翻转 PB9 引脚的输出电平。\nHAL_UART_Transmit_IT(&amp;huart1, dat_Txd, 5);void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);&#123;    if(huart-&gt;Instance == USART1)    &#123;        HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_9);    &#125;&#125;/* 使用阻塞式串口发送函数 */HAL_UART_Transmit(&amp;huart1, dat_Txd, 5, 10000);HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_9);\n\nHAL 库中串口接收的重要函数\n阻塞式发送函数（不推荐使用）\nHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, unit32_t Timeout);\n\n非阻塞式发送函数（推荐使用）\nHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);\n\n接收完成中断回调函数\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);\n\n【例】使用非阻塞式的串口接收函数，接收USART1中的一个字节，将其保存在 dat_Rxd 变量中，在数据发送完成后，若该字节为 0x5A，则翻转 PB8 引脚的输出电平。\nHAL_UART_Receive_IT(&amp;huart1, &amp;dat_Rxd, 1);void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);&#123;    if(huart-&gt;Instance == USART1)    &#123;        if(dat_Rxd == 0x5A)        &#123;            HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_8);        &#125;    &#125;&#125;\n\n实训：外部中断信号控制 LED 灯开关在 F429 中进行 STM32 应用开发，完成以下功能。\n\n开机后，向串口 1 发送”Hello World!”。\n串口 1 收到字节指令”0xA1”，关闭 LED0（PB1），发送”LED1 Closed!”。\n串口 1 收到字节指令”0xA2”，打开 LED0（PB0），发送”LED1 Open!”。\n在串口发送过程中，打开 LED1 作为发送数据指示灯。\n\n/* USER CODE BEGIN 0 */#define LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);#define LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);uint8_t Tx_str1[] = &quot;Hello World!\\r\\n&quot;;uint8_t Tx_str2[] = &quot;LED1 Open!\\r\\n&quot;;uint8_t Tx_str3[] = &quot;LED1 Closed!\\r\\n&quot;;uint8_t Rx_dat = 0;                                       //创建一个接收的数据，先是 0void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)   //发送完毕中断回调函数，用于接收指令&#123;\tif(huart-&gt;Instance == USART1)                         //先进行判断是不是串口 1\t&#123;\t\tif(Rx_dat == 0xa1)                                //发送指令 A1\t\t&#123;\t\t\tLED1_OFF();                                   //LED1 灭\t\t\t\t\t\tLED0_OFF();                                   //LED0 作为数据发送指示灯\t\t\tHAL_UART_Transmit(&amp;huart1, Tx_str3, sizeof(Tx_str3), 10000);\t\t\tLED0_ON();\t\t\t\t\t\tHAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);     //还要再用一遍非阻塞式发送函数\t\t&#125;\t\telse if(Rx_dat == 0xa2)\t\t&#123;\t\t\tLED1_ON();\t\t\t\t\t\tLED0_OFF();\t\t\tHAL_UART_Transmit(&amp;huart1, Tx_str2, sizeof(Tx_str2), 10000);\t\t\tLED0_ON();\t\t\t\t\t\tHAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */---------------------------------------------------------/* USER CODE BEGIN 2 */\tHAL_Delay(1000);                                      //开机运行，发送 Hello World 表示开机了\tLED0_OFF();\tHAL_UART_Transmit(&amp;huart1, Tx_str1, sizeof(Tx_str1), 10000);\tHAL_Delay(1000);\tLED0_ON();\t\tHAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);/* USER CODE END 2 */\n\nSTM32 的定时器与串口综合训练关于常用函数 sprintf() 的用法\nsprintf()，指的是字符串格式化函数，把格式化的数据写入某个字符串中。\nint sprintf(char*string, char *format[,argument,…]);\n\n需要引用头文件：#include “stdio.h”。\n\n\n【例】有一个表示温度的整型变量 tmp，现在要将其格式化为字符串“温度是：XX 摄氏度”，并将其通过串口 1 发送出去。\nuint8_t Str_buff[64];sprintf((char*)Strbuff, &quot;温度是：%d摄氏度&quot;, tmp); //%d 是占位符HAL_UART_Transmit(&amp;huart, Str_buff, sizeof(Str_buff), 0xFFFF); //简单来说，0x 后面的值为十六进制\n\n实训：定时器与串口综合训练在 F429 中进行 STM32 应用开发，完成以下的功能。\n\n开机后，LED0 与LED1 依次点亮，然后熄灭，进行灯光检测。（LED0 接到 STM32 的 PB1，LED1 接到 STM32 的 PB0，低电平点亮）\n\n系统通过串口 1 向上位机发送一个字符串”STM32F429 欢迎您!”。\n\nLED0 作为一个秒闪灯，系统向上位机发送完字符串后，开始亮 0.5 秒，灭 0.5 秒……循环闪烁，并开始启动系统运行时间的记录，其时分秒格式为”XX:XX:XX”。\n\n上位机通过一个由 3 个字节组成的命令帧控制 LED1 灯的开关。该命令帧的格式为”0xBF 控制字 OxFB”。\n0xBF 为帧头，0xFB 为帧尾，控制字的定义如下：\n0xA1：打开 LED1，返回信息”XX:XX:XX LED1 打开”。\n0xA2：关闭 LED1，返回信息”XX:XX:XX LED1 关闭”。\n其他：返回信息”XX:XX:XX 这是一个错误指令!”。\n\n\n/* USER CODE BEGIN 0 */#define LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET)#define LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET)#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET)#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET)#define LED0_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1)#define LED1_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0)uint8_t str1[] = &quot;********* STM32F429 欢迎您！*********\\r\\n&quot;;uint8_t hh = 0, mm = 0, ss = 0, ss05 = 0;                         //定义时分秒，以及 0.5suint8_t str_buff[64];                                             //定义一个字符串的缓冲数组，64 个字节uint8_t Rx_dat[16];                                               //串口接收的数组，16 个字节void Check_LED()                                                  //灯光检测的函数&#123;\tHAL_Delay(1000);\t\tLED0_OFF();\tHAL_Delay(500);\tLED1_OFF();\tHAL_Delay(500);\t\tLED0_ON();\tHAL_Delay(500);\tLED1_ON();\tHAL_Delay(500);&#125;void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)        //回调函数（虚函数），用定时器做秒闪灯，LED0 闪烁&#123;\tLED0_TOG();\t\tss05++;\tif(ss05 == 2)\t&#123;\t\tss05 = 0;\t\tss++;\t\tif(ss == 60)\t\t&#123;\t\t\tss = 0;\t\t\tmm++;\t\t\tif(mm == 60)\t\t\t&#123;\t\t\t\tmm = 0;\t\t\t\thh++;\t\t\t&#125;\t\t&#125;\t&#125;&#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;\tif(huart-&gt;Instance == USART1)\t&#123;\t\tif(Rx_dat[0] == 0xBF &amp;&amp; Rx_dat[2] == 0xFB)\t\t&#123;\t\t\tswitch(Rx_dat[1])\t\t\t&#123;\t\t\t\tcase 0xa1:\t\t\t\t\tLED1_OFF();\t\t\t\t\tsprintf((char *)str_buff, &quot;%d:%d:%d    LED1 关闭！\\r\\n&quot;, hh, mm, ss);\t\t\t\tbreak;\t\t\t\t\t\t\t\tcase 0xa2:\t\t\t\t\tLED1_ON();\t\t\t\t\tsprintf((char *)str_buff, &quot;%d:%d:%d    LED2 打开！\\r\\n&quot;, hh, mm, ss);\t\t\t\tbreak;\t\t\t\t\t\t\t\tdefault:\t\t\t\t\tsprintf((char *)str_buff, &quot;%d:%d:%d    这是一个错误的命令！\\r\\n&quot;, hh, mm, ss);\t\t\t\tbreak;\t\t\t&#125;\t\t\tHAL_UART_Transmit(&amp;huart1, str_buff, sizeof(str_buff), 10000);       //向串口发送缓冲区字符串\t\t\tHAL_UART_Receive_IT(&amp;huart1, Rx_dat, 3);                             //写完发送，就要记得写接收，因为是为了继续接收\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */----------------------------------------------------------------------/* USER CODE BEGIN 2 */    \tCheck_LED();             //需要放到主函数中运行\t\tHAL_UART_Transmit(&amp;huart1, str1, sizeof(str1), 10000);\tHAL_UART_Receive_IT(&amp;huart1, Rx_dat, 3); //非阻塞式接收，接收到的字节放到 Rx_dat，当接收到完整的三个字节后，进入串口接收完成中断，然后调用它的回调函数。\t\tHAL_TIM_Base_Start_IT(&amp;htim2);    //首先启动定时器，定时器里面是指针，所以要给个地址，即加上 &amp;。找到回调函数（重写虚函数），写在上面/* USER CODE END 2 */    \n\nADC 模数转换器的基本工作原理数字系统基本结构\n\n【例】一个恒温锅炉的基本结构：\n\n通过温度传感器，将温度变化转换为电压变化。\n通过 ADC 将模拟的电压变化，转换为数字变化，将其编码。\n中央处理器根据温度数据，进行计算和逻辑控制。\n计算结果通过 DAC 转换为电压&#x2F;电流信号，控制加热和冷却。\n\nAnalog-to-Digital Converter将时间和幅值连续的模拟量转化为时间和幅值离散的数字量，A&#x2F;D 转换一般要经过采样、保持、量化和编码 4 个过程。\n常用 ADC：逐次逼近型（大多数）、双积分型、$\\Sigma-\\Delta$ 型。\nAD 转换器的几个技术指标：\n\n量程（参考电压）：指 ADC 所能输入模拟信号的类型和电压范围。信号类型包括单极性和双极性（差分电压）。\n转换位数：量化过程中的量化位数 n。AD 转换后的输出结果用 n 位二进制来表示。（如 10 位 AD 的输出值为 0~1023，即 1024）\n分辨率：ADC 能够分辨的模拟信号最小变化量。\n公式：分辨率 &#x3D; 量程 &#x2F; $2^n$。（如量程为单极性 0-5V，8 位 ADC 的分辨率是：5&#x2F;256 &#x3D; 0.0195V，意味着能够分辨出 19.5mV 以上的信号变化）\n\n\n转换时间：ADC 完成一次完整的 AD 转换所需要的时间，包括采样、保持、量化、编码的全过程。\n\nADC 数据采样的计算应用有一个温度测控系统，已知温度传感器在 0 到 100 度之间为线性输出，参考电压为 5V，采用 8 位的 AD 转换器，0 度的时候，测的电压是 1.8V，100 度的时候，测的电压是 4.3V。问：系统的分辨率是多少？采集到数据 10010001，表示多大电压？温度是多少？\n\n最小能分辨的电压：0.0195V。\n\n由于温度是线性变化，先求得斜率 K &#x3D; (100-0)&#x2F;(4.3-1.8) &#x3D; 40，得到温度（ $y$ ）和电压（ $x$ ）的关系表达式， $y&#x3D;40\\times(x-1.8)$ 。\n最小能分辨的温度：0.0195 * 40 &#x3D; 0.78 度。\n10010001B &#x3D; 91H &#x3D; 145，所以 0.0195 * 145 &#x3D; 2.83V。\n(2.83V - 1.8V) * 40 &#x3D; 41.2 度。\n\n\nSTM32 的 ADC 开发基础STM32F103ZE 芯片（144 脚）中有 ADC1、ADC2、ADC3 共 3 个 12（4096） 位逐次逼近型模数转换器，具有 18 个测量通道，可测量 16 个外部和 2 个内部信号源（内部温度和内部参考电压）。这两个内部信号源只能连接到 ADC1。\n各个通道的 AD 转换可以单次、连续、扫描或间断模式执行。\n按照 AD 转换的组织形式来划分，ADC 的模拟输入通道分为规则组和注入组两种。\n\n规则组：ADC 可以对一组最多 16 个通道按照指定的顺序逐个进行转换，这组指定的通道称为规则组。\n注入组：在实际应用中，可能需要中断规则组的转换，临时对某些通道进行转换，好像这些通道注入了原来的规则组，故称注入组，最多由 4 个通道组成。\n\nAD 转换结果有 2 种存储方式：左对齐、右对齐（默认）。\nSTM32CubeMX 中关于 ADC 的配置(待补充)\n查询方式和中断方式的 HAL 库函数应用\n查询方式：阻塞式的 AD 转换\nunit16_t ADC_Value = 0;                              //定义一个 16 位的变量，接收 ADC 返回的结果HAL_ADC_Start(&amp;hadc);                                //启动 ADC，给它一个地址（通过参数告诉它启动的是哪一个 ADC）if(HAL_OK == HAL_ADC_PollForConversion(&amp;hadc, 10))   //转换过程函数，第一个参数是表示转换哪个 AD，第二个参数是表示超时的时间，执行完毕返回一个 OK&#123;    ADC_Value = HAL_ADC_GetValue(&amp;hadc);            //读取相应 AD 的转换结果。&#125;\n\n中断方式：非阻塞式的 AD 转换\nuint16_t ADC_Value = 0;HAL_ADC_Start_IT(&amp;hadc);                                  //带有中断功能的启动函数，会调用一个中断回调函数void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc1)   //AD 转换完成回调函数&#123;    ADC_Value = HAL_ADC_GetValue(&amp;hadc);&#125;\n\nDMA\n\n\n实训：ADC 单次数据采样与电压换算在 F429 中进行 STM32 应用开发，完成以下的功能。\n\n将 ADC_IN0 设置为 12 位 ADC，右对齐，启用中断。\n分别用查询和中断这 2 种方式，每隔 0.5 秒采样一次 ADC 数据。\n将每次读取到的 ADC 采样值转换为对应的电压值，发送到上位机。\nLED1 作为采样指示灯，在 ADC 转换过程中点亮，其余时间熄灭。\n\n【注】配置 GPIO、ADC1、USART1。\n\nGPIO 比较好配置，就 LED0、LED1 的引脚设为 Output。\n配置 ADC1，PA0 设为 ADC1_IN0，然后勾选 IN0。参数设置模块的 Data Alignment 默认 Right alignment（右对齐）即可，同样其他都默认，NVIC 中断使能勾选。\n配置 USART1，Mode 选 Asynchronous（异步），参数设置模块波特率改为 9600 Bits&#x2F;s，其他默认。由于串口没有用到中断，所以 NVIC 模块不需要使能。\n\n/* USER CODE BEGIN Includes */#include &quot;stdio.h&quot;                  //为后面 sprintf 做准备/* USER CODE END Includes */------------------------------------------------/* USER CODE BEGIN 0 */#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET)#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET)uint16_t ADC_Value = 0, ADC_Volt = 0;  //定义一个 16 位的变量，接收 ADC1 的采样值和转换后的电压值uint8_t str_buff[64];                  //具有 64 字节的缓冲区，发送void UR1_Send_Info()                   //串口发送函数&#123;\tsprintf((char *)str_buff, &quot;采样值：%d，电压值：%d.%d%d%dv\\r\\n&quot;, ADC_Value, ADC_Volt/1000, (ADC_Volt%1000)/100, (ADC_Volt%100)/10, ADC_Volt%10);       //视频中没有 /1000，是因为下面的 3300 用的是 330。这点要理解。下面少了个 0，所以上面跟着少了个 0，其实是为了计算简便。\tHAL_UART_Transmit(&amp;huart1, str_buff, sizeof(str_buff), 1000);&#125;/*方式2：中断方式void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)  //中断回调函数(启动函数在死循环中)&#123;\tif(hadc-&gt;Instance == ADC1)         //如果有多个 ADC，就要先用 if 来判断是不是 ADC1\t&#123;\t\tADC_Value = HAL_ADC_GetValue(&amp;hadc1);   //得到 ADC1 的值\t\tADC_Volt = ADC_Value * 3300 / 4096;     //转换公式，3300mv = 3.3v，4096 是 2 的 12 次方\t\tUR1_Send_Info();\t\tLED1_ON();      //在下面有写已经灭掉\t&#125;&#125;*//* 方式1：查询方式void ADC1_Get_Value()                  //用来做换算&#123;\tHAL_ADC_Start(&amp;hadc1);               //启动 ADC1\tLED1_OFF();                          //关闭 LED1，表示 ADC 开始转化\t\tif(HAL_ADC_PollForConversion(&amp;hadc1, 10) == HAL_OK)  //转化函数\t&#123;\t\tADC_Value = HAL_ADC_GetValue(&amp;hadc1);   //得到 ADC1 的值\t\tADC_Volt = ADC_Value * 3300 / 4096;     //转换公式，3300mv = 3.3v，4096 是 2 的 12 次方\t&#125;\t\tUR1_Send_Info();\tLED1_ON();\t\tHAL_ADC_Stop(&amp;hadc1);     //关闭 ADC1&#125;*//* USER CODE END 0 */--------------------------------------------------/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123;    /*方式1：查询方式\tADC1_Get_Value();        //查询方式函数执行\tHAL_Delay(500);\t*/        /*方式2：中断方式\tLED1_OFF();                //中断启动前关掉 LED1\tHAL_ADC_Start_IT(&amp;hadc1);  //放在死循环例，每隔 0.5s 以中断的方式启动 ADC1\tHAL_Delay(500);\tHAL_ADC_Stop_IT(&amp;hadc1);   //关闭 ADC1\t*/    /* USER CODE END WHILE *//* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\nSTM32 的 OLED 开发基础OLED 概述\nOrganic Light-Emitting Display，有机发光显示\nOLED 具备自发光、厚度薄、视角广、功耗低、对比度高、响应速度快、可用于挠曲性面板、使用温度范围广、构造及其制作过程较简单等优异特性，并认为是一种比液晶显示更为先进的新一代平板显示技术。\n基于 STM32 的 OLED 应用，要做那些事情\n移植 OLED 的底层驱动函数库（针对不同的芯片，会有不同的库）\n准备需要的中文字符和图片等数据\n调用 OLED 驱动库中的底层函数进行应用开发\n\n\n\nOLED 开发相关资源下载\n基于 STM32CubeMX 的 OLED 屏驱动程序库（内含 4 个文件）\nXMF_OLED_STM32Cube.c：驱动程序的源文件\nXMF_OLED_STM32Cube.h：驱动程序的头文件\nXMF_OLED_Font.h：字库数据文件\nXMF_OLED_BMP.h：图片数据文件\n\n\n取字模软件 PCtoLCD2002：生产字符和图片数据的工具\n\nOLED 底层驱动函数移植\n将 4 个驱动文件拷贝到工程文件中，和 main.c 放在同一目录，并将 XMF_OLED_STM32Cube.c 添加到工程代码文件中，并在 main.c 中引入头文件 XMF_OLED_STM32Cube.h。\n根据所选用的芯片型号，修改 XMF_OLED_STM32Cube.h 头文件中所用的芯片头文件。\n根据硬件电路原理图，修改 XMF_OLED_STM32Cube.h 中 OLED 的引脚定义。\n查看 OLED_Init(void) 初始化函数的源码，根据电路接口和应用需要进行修改。\n\nOLED 驱动库中常用的函数\nOLED 初始化\nvoid OLED_Init(void);\n\n（未完待续……）\nReferenceVideo：【小蜜蜂笔记】基于STM32CubeMX的嵌入式开发基础教程_哔哩哔哩_bilibili\n","categories":["工具"],"tags":["STM32","F429"]},{"title":"上传文件夹到 GitHub","url":"/2022/11/03/005-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%B0-GitHub/","content":"\n创建一个仓库。\n复制仓库地址。\n\n\n\n\n在本地新建一个空文件夹（E:\\C_GitHub_UPLoad）\n在空文件中，Git Bash（Win11 更新后，右键 Git Bash Here 消失了，直接 cd 到文件夹，大小写无所谓）。\n\n\n\n\n克隆远程仓库（git clone 后面跟的上面复制的仓库地址）。\ngit clone git@github.com:Tiramisu-MH/STM32-XMF-Data.git\n\n\n\n\n把需要上传的文件夹放到远程仓库文件夹中\n\n\n\n\n上传文件，依次输入以下命令\ncd STM32-XMF-Data  //输入自己的远程仓库名git initgit add .          //将工作去的文件添加到暂存区（“.”是当前目录下的所有文件，也可以只输入文件夹名称git commit -m &quot;你的提交信息，会浅色显示在文件夹和文件的后面&quot;git push           //提交到远程仓库\n\n\n\n\n上传成功。\n\n\n\nReferencePage：如何上传文件夹到GitHub上（配图详解）？_一只青木呀的博客-CSDN博客_github上传文件夹\n","categories":["工具"],"tags":["Git","Github"]},{"title":"使用阿里云 OSS + PicGo + Typora 搭建图床","url":"/2022/11/03/006-%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91-OSS+PicGo+Typora-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A-/","content":"由于 GitHub 仓库作为图床并不稳定，昨天晚上查看时就挂了。在网上看到大家说那是代码托管仓库，不要浪费它的资源作为图床。于是找到利用阿里云 OSS 作为图床的方法。还有很多其他的，比如腾讯云、七牛等。先试用阿里云半年。用 PicGo + Typora 真的非常丝滑。不用再像 GitHub 那样敲命令上传，再下载贴上网址。属实提升了效率。\n阿里云 OSS\n由于之前注册过，所以此次直接支付宝扫码登录。\n\n在搜索框中输入OSS。\n\n选择【立即购买】。\n\n由于只是用于搭建博客，所以全部选择默认即可。（先选择半年试用）\n\n\n购买完成后需要先【激活控制台】。（此处是一坑，问了客服才知道）\n\n进入【控制台】，创建Bucket。\n\n输入名称。\n【读写权限】改为【公共读】。\n其他默认即可。\n\n\n\n点击侧栏【Bucket 列表】，可以看到自己创建的Bucket。【版本控制】【传输加速】默认即可，不需要开启。\n\n点击【storybeginswhenicu】进入自己的Bucket。\n\n点击侧栏【文件管理】，新建目录img/。\n\n鼠标放到右上角【头像】位置，在下拉菜单中点击【AccessKey 管理】。\n\n点击【查看 Secret】，输入手机验证码，可以看到ID和Secret，等下需要用到。\n\n（2023 年 1 月 22 日，续费一年，9 元，至 2024 年 1 月 28 日）\n\n\nPicGo\n下载稳定版exe文件。下载地址：V2.3.0，选择PicGo-Setup-2.3.0-x64.exe。\n\n配置“阿里云 OSS + PicGo”。\n\n侧栏【图床设置】→【阿里云 OSS】。按要求依次输入。\n\n\n\n\n【存储空间名】是自己的Bucket名称，【存储区域】在Bucket【概览】中的外网访问，复制前段即可。\n依次点击【设为默认图床】→【确定】\n\n\n\nTypora\n依次点击【文件】→【偏好设置】→【图像】，设置如下图所示\n\n\n\n至此，配置完毕。但目前有一个问题，就是可能我用 Typora 写东西（非博客），也可能将图片上传到阿里云。要经常登上去看看，然后删一删。\n","categories":["工具"],"tags":["OSS","PicGo","图床"]},{"title":"使用 Github 搭建图床","url":"/2022/11/03/007-%E4%BD%BF%E7%94%A8-Github-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","content":"博客插入图片问题一直很困扰。之前建立个人主页时，曾用 HTML 方案解决过：\n\n在 GitHub 仓库中，添加文件，把图片拖拽进去。Typora 写好文章后导出为 HTML 格式，浏览器打开，查看源代码，全选复制粘贴到仓库下面的 index.html 文件中。将图片地址替换为 GitHub 仓库中的图片地址即可渲染出来。这种方法并不适用博客写作。\n\n于是有了下面的方法：将图片通过 Git 提交到 GitHub 中，通过产生一个外链，渲染出图片。\n\n在 GitHub 中 New repository\n\n填写项目信息。由于是博客的图片仓库，接下来所有的图片都会放到这个项目中，所以取名为：img_storybeginswhenicu。\n\n建立项目后，将项目 Clone 到自己本地。在本地准备个文件夹，输入以下命令：\ngit clone https://github.com/Tiramisu-MH/img_storybeginswhenicu.git\n\n在项目根路径（如下图所示。注意不是自己建的那个文件夹，而是下一级），\n\n输入以下命令。\ngit add .git commit -am XXXgit push\n\n结果如下图所示：\n\n\n回到 GitHub 项目中，刷新，看到自己提交的信息，找到图片位置（有以下两种方法）\n\n点击 Download，获取图片在 GitHub 上的外链地址。\n复制地址栏，将 blob 改为 raw。\n\n\n打开 Typora，Ctrl + Shift + I插入图片，第一种方法更方便。\n\n\n参考：\n[1] page: 如何在Github提交图片，做一个自己的图片仓库 - SegmentFault 思否\n\n","categories":["工具"],"tags":["Github","图床"]},{"title":"从零搭建 Blog","url":"/2022/11/03/008-%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA-Blog/","content":"本文使用的是 GitHub Page + Hexo 框架 + NexT 主题。\n本地搭建环境安装\n安装 Node.js\n安装 Git\n\n安装完成后，Win+R 输入cmd打开，依次输入node -v、npm -v、git --version并回车，出现程序版本号即可。\n本地安装 Hexo 博客程序首先新建一个文件夹来存放 Hexo 的程序文件，如~&#x2F;Blog&#x2F;。打开该文件夹，右键，Git Bash Here。\n安装 Hexonpm install -g hexo-cli\n\nHexo 初始化hexo init    # 初始化npm install  # 安装组件\n\n启动本地服务器预览hexo g  # 生成页面hexo s  # 启动预览\n\n访问 http://localhost:4000，出现 Hexo 默认页面，本地博客安装成功。\n推送到 Github安装hexo-deployer-git插件\nnpm install hexo-deployer-git --save\n\n运行以下命令：\nhexo cleanhexo g --d\n\n【注】有时会因为网络问题出现错误，再来一次或更换网络后再来一次即可。\nBlog 装修更换主题在本地目录打开 Git Bash Here，输入下面命令行：\ngit clone https://github.com/next-theme/hexo-theme-next.git themes/next\n\n然后编辑站点配置文件中的 theme 为新主题名称 next。\n【注】目前有三个 NexT 主题仓库，分别是不同的作者在做，注意辨别找新版。\n常用命令hexo new &quot;name&quot;   # 新建文章hexo g            # 生成页面hexo d            # 部署hexo s            # 本地预览hexo clean        # 清楚缓存和已生成的静态文件hexo help         # 帮助\n\n添加【关于】【标签】【分类】页在主目录下 Git Bash Here 如下命令：\nhexo new page abouthexo new page tagshexo new page categories\n\n！一定要小写。嫌不美观可以去 .md 文件中修改 title。\n分别在~/source/xxx/index.md中的头文件下面加上↓\ntype: abouttype: tagstype: categories\n\n设置阅读全文\n在文章中使用&lt;!-- more --&gt;手动进行截断\n\n在文章的front-matter中添加description并提供文章摘录\n\n\n对文章进行加密首先安装hexo-blog-encrypt\nnpm install --save hexo-blog-encrypt\n\n将password添加到头文件\ntitle: Hello Worlddate: 2020-03-13 21:12:21password: muyiioabstract: This blog is encryptedmessage: You must enter the password to read\n\n标签图标设置修改文章底部的 # 标签：修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将其中的 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;\n去除默认设置的标题下划线打开并编辑~/themes/next/source/css/_schemes/Gemini/index.styl文件，找到border-bottom，改成0px即可。\n添加字数统计和阅读时长安装hexo-symbols-count-time\nnpm install hexo-symbols-count-time --save\n\n在站点配置文件添加如下配置\nsymbols_count_time:    symbols: true               # 文章字数统计    time: true                  # 文章阅读时长    total_symbols: true         # 站点总字数统计    total_time: true            # 站点总阅读时长    exclude_codeblock: false    # 排除代码字数统计\n\n在主题配置文件添加如下配置（有的话可以直接在上面修改）\n# Post wordcount display settings# Dependencies: https://github.com/next-theme/hexo-symbols-count-timesymbols_count_time:  separated_meta: true    # 是否另起一行（true 的话不和发表时间同一行）  item_text_post: true    # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）  item_text_total: true   # 页面底部统计量前是否显示文字描述（站点总字数、站点阅读时长）  awl: 4                  # 平均字数长度，CN≈2  wpm: 275                # word per minute（每分钟阅读词数）  suffix: “mins.”\n\n【注】如果没有显示出来，hexo clean一下。至于hexo-wordcount不知道为什么一直配置不好。\n本地搜索安装hexo-generator-searchdb --save\nnpm install hexo-generator-searchdb --save\n\n在站点配置文件添加如下配置\nsearch:  path: search.xml  field: post  format: html  limit: 10000\n\n在主题配置文件中，Ctrl + F找到local_search，设置为true\n# Local Search# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false\n\n代码样式修改样式参考：https://theme-next.js.org/highlight/\n编辑站点配置文件，搜索highlight，根据上述网址提示，进行修改。\nhighlight:  enable: true  line_number: true  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: falseprismjs:  enable: false  preprocess: true  line_number: true  tab_replace: &#x27;&#x27;\n\n编辑主题配置文件，搜索codeblock，根据上述网址提示，进行修改。\ncodeblock:  # Code Highlight theme  # All available themes: https://theme-next.js.org/highlight/  theme:    light: default    dark: stackoverflow-dark  prism:    light: prism    dark: prism-dark  # Add copy button on codeblock  copy_button:    enable: true    # Available values: default | flat | mac    style: mac\n\n主题配置文件设置网站图标在主题配置文件中，Ctrl + F找到favicon，对应后面的地址，进行图片替换即可。\n设置头像在主题配置文件中，Ctrl + F找到avatar，对应后面的地址，进行图片替换即可。\n设置菜单在主题配置文件中，Ctrl + F找到menu，将前面的#去掉即可。\nmenu:  home: / || fa fa-home  about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat\n\n添加友情链接编辑主题配置文件，添加：\nlinks_settings:  icon: fa fa-globe  title: 友链  # Available values: block | inline  layout: blocklinks:  #Title: https://example.com  Program-Think: https://program-think.blogspot.com/#/\n\n修改建站时间编辑主题配置文件，Ctrl + F找到since，将#去掉，改年份即可。\nfooter:\tsince: 2022\n\n修改底部跳动的心footer:\ticon:\t\tanimated: true\n\n设置背景动画编辑主题配置文件，Ctrl + F找到canvas，将false修改为true。\ncanvas_ribbon:\tenable: true\n\n添加背景动画【注】这个暂时还未设置成功（2022&#x2F;07&#x2F;23）\n访客统计编辑主题配置文件，Ctrl + F找到busuanzi_count，将false修改为true。\n配置回到顶部按钮编辑主题配置文件，Ctrl + F找到back2top，将false修改为true，边栏和滚动百分比按需求添加。\n隐藏网页底部 Hexo 强力驱动编辑主题配置文件，Ctrl + F找到copyright，将true修改为false。\ncopyright:# Powered by Hexo &amp; NexTpowered: false\n\n文章顶部显示更新时间编辑主题配置文件，Ctrl + F找到updated_at，将false修改为true。\n# Post meta display settingspost_meta:  item_text: true  created_at: true  updated_at:    enable: true    another_day: true  categories: true\n\n编辑文章头文件，增加关键字updated。（NexT 可以根据文章改变时间自动更改）\n---layout: layouttitle: 关于date: 2017-08-18 15:41:18updated: 2017-09-05 20:18:54   #手动添加更新时间\n\n站点配置文件设置作者昵称编辑站点配置文件，设置author为自己的昵称\n站点描述编辑站点配置文件，设置description字段为站点描述。\n","categories":["博客"],"tags":["Hexo","GithubPgae","Next"]},{"title":"Typora 使用说明","url":"/2022/11/03/009-Typora-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","content":"在 Typora 中书写 Markdown 的一些技巧。\nGitHub 主题标题线点击文件 → 偏好设置 → 外观 → 打开主题文件夹\n修改 github.css，Ctrl + F 搜索 border-bottom：\nh1 &#123;    font-size: 2.25em;    line-height: 1.2;    border-bottom: 2px solid #eee;&#125;h2 &#123;    font-size: 1.75em;    line-height: 1.225;    border-bottom: 2px solid #eee;&#125;\n\n如果不想要标题线，border-bottom 后修改为 none 即可。\n","categories":["工具"],"tags":["Typora"]},{"title":"搭建个人博客指南","url":"/2022/11/03/010-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/","content":"扫盲博客、网站搭建相关知识。这个世界上有多少种框架？什么是域名？什么是 IP？什么是服务器？IPv4 和 IPv6 分别是什么？统统解答。\n方式大佬独立博客，有自己网站，自己写代码\n普通人独立博客，有自己的网站，套用模板\n\nWordPress：基于 PHP 和 MySQL 的免费开源内容管理系统。\n\nDocsify\n\nGitbook\n\nVuePress\n\nHugo：用 Go 语言编写的静态网站生成器。\n\nOctopress：使用 Ruby 语言编写，基于 Jekyll 设计的博客框架。\n\nJekyll\n\nHexo：目前在用\n\nPelican：由 Python 语言编写的静态网站生成器\n\nSolo：使用 Java 语言编写\n\n\n懒人社区平台\n\nCSDN\n博客园\nMedium\nSegmentFault\n简书\n知乎\n微博\n公众号\nQQ 空间\n\n知识点扫盲域名、服务器与 IP\n域名是一个网址名，就是当你访问某个网站的首页时，浏览器地址栏里看到的那一串东歘，如 baidu.com\n服务器是一台 24h 不停运转的远程电脑，它有 CPU、内存、硬盘，存放你网站运行所需的所有数据，包括程序脚本和数据库。\n\n这个世界上有那么多服务器，要找到自己的服务器，必然得有一个地址，IP（Internet Protocol Address, 国际协议地址）地址就是服务器的地址。\n域名就好比你的名字，IP 地址就好比你的身份证号码。记住一个人的身份证号码很难，记住他 &#x2F; 她的名字就容易得多。稍有不同的是，人名可以重复，域名是唯一的。\n网域名称（英语：Domain Name，简称：Domain），简称域名、网域，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位。域名可以说是一个 IP 地址的代称，目的是为了便于记忆后者。例如，http://wikipedia.org 是一个域名，和 IP 地址 208.80.152.2 相对应。人们可以直接访问 http://wikipedia.org 来代替 IP 地址，然后域名系统（DNS）就会将它转化成便于机器识别的 IP 地址。这样，人们只需要记忆 http://wikipedia.org 这一串带有特殊含义的字符，而不需要记忆没有含义的数字。\n域名的组成 www. baidu. com三级域 二级域 顶级域\n\n\n顶级域：不是所有的网站都以.com 结尾，比如 996.icu 这个网站，就是 .icu 结尾。尾缀的词汇远比你想象的多得多，比如 .me .io .ink .tech .net .org 等等都可以用来做尾缀，只是没有 .com 那么出名而已，谁让那么多用户都习惯性地在任何网站后面加上 .com 呢。\n\n二级域：你要好好斟酌一下的名字。好名字都被注册光了，尤其 4 个字母的，基本上想都不要想了。其实是支持中文的，但是不建议。\n\n三级域：购买后你可以自由分配。不是所有前缀都是 www. 只是它最出名而已。你也可以用 blog. 甚至 abcd. 没有任何限制，而且你可以同时有多个不同的三级域名。一个服务器可以运行多个网站，你可以让不同的域名指向不同的网站。\n\n\n我们购买的通常是二级域 + 顶级域，也就是如同 http://baidu.com 的形式，至于前缀你可以自由分配，统统属于你。\n什么是域名解析域名解析就是把域名指向服务器的 IP 地址。在你购买完域名和服务器之后，这两者是分离的，你需要在域名提供商的网站里添加一条或几条对应关系。\nIPv4 与 IPv6 是什么？\n网际协议版本 4（英语：Internet Protocol version 4，缩写：IPv4，又称互联网通信协议第四版）是网际协议开发过程中的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。其后继版本为 IPv6，直到 2011 年，IANA IPv4 位址完全用尽时，IPv6 仍处在部署的初期。\n\n\nIPv4 的 IP 位址是由 32 位所组成，分 4 组，每组是 8 位二进制，并以「.」做区隔，不过这样的表示法太长，不便记忆，所以通常都以 10 进制的方法表示，而每个部份的数字会呈现 0 至 255 的整数，譬如本站的 IP 位址为 101.133.211.86。\n而 IPv6 的 IP 位址则是 128 位组成，分 8 组，每组是 4 位十六进制（1 个十六进制位相当于 4 个二进制位）。而区隔每个部分的方式亦与 IPv4 不同，是以「:」表示。譬如 1079:0BD3:6ED4:1D71:414B:2E2A:7144:72BE。\n\nReference[1] Page: 新手建站、搭建个人博客指南 - 知乎 (zhihu.com)\n[2] Page: 搭建个人博客，最想推荐的 10 大框架，强烈建议收藏 - 掘金 (juejin.cn)\n","categories":["博客"],"tags":["域名","IP"]},{"title":"ROG 触控板使用说明","url":"/2022/11/03/011-ROG-%E8%A7%A6%E6%8E%A7%E6%9D%BF%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","content":"一般情况下，大家都认为非 Mac 笔记本的触控板都十分难用。有一部分原因是因为没有认真学习过如何使用 Win 本的触控板。特地从官网扒下来手势教程，供自己学习并熟练掌握。\n单指手势轻触&#x2F;轻触两下\n轻触应用程序以选择该程序\n在应用程序上轻触两下以运行该程序\n\n拖拽与放置轻触两下以选择图标，然后用相同手指在触控板上滑动即可拖拽该图标。放开手指以将图标放至新位置。\n点按左键（与轻触相同）\n点按应用程序以选择该程序\n\n在应用程序上点按两下以运行改程序\n\n\n点按右键（与双指轻触相同）点按此键以开启右键菜单。\n双指手势轻触用两只手指在触控板上点按&#x2F;轻触以模拟鼠标右键功能。\n双指滑动（上&#x2F;下）滑动双指以上下滚动。\n双指滑动（左&#x2F;右）滑动双指以左右滚动。\n缩小&#x2F;放大在触控板上并拢&#x2F;分开两指以缩小画面。\n拖拽与放置选择图标后按住左键，然后用另一只手指在触控板滑动以拖拽该图标，然后放开按键以放置图标于新的位置。\n三指手势轻触用三只手指轻触触控板一下以启动 Windows 搜索。\n左&#x2F;右滑动若您开启多个应用程序，用三只手指左右滑动即可在这些应用程序间切换。\n向上滑动向上滑动检视目前所有开启中的应用程序总览。\n向下滑动向下滑动以显示桌面。\n四指手势轻触用四只手指轻触触控板一下以启动通知中心。\n左&#x2F;右滑动切换桌面。\n向上滑动（与三指操作相同）检视目标所有开启中的应用程序总览。\n向下滑动（与三指操作相同）显示桌面。\n\n【注】在 Windows 搜索框中输入“触摸板设置”，可看到相应的操作及修改。\n","categories":["工具"],"tags":["ROG","触控板"]},{"title":"如何学习蛙泳","url":"/2022/11/03/012-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E8%9B%99%E6%B3%B3/","content":"蛙泳练习步骤，共有七步，分别是换气、漂浮、蛙泳腿、蛙泳腿 + 换气、蛙泳手、蛙泳手 + 换气、蛙泳。每步又各分几小节。须步步为营，扎扎实实进行练习。基本功换气要时刻想着多做。\n练习步骤换气\n 陆上换气\n 水上换气\n 连续换气\n\n\n要点：①抬头的过程中也要一直保持呼气；②抬头出水面也要保持呼气（不过要越练越快）；③嘴巴吸气，吸气后快速低头，把头砸进水里。\n\n漂浮\n 水上固定支撑（扶着池边）漂浮\n 水上不固定支撑（教练扶着或扶着漂浮板）漂浮\n 水上无支撑（noting）漂浮\n\n练习内容：背靠泳池，双手向前伸直，吸气。低头，双脚蹬离池边。\n\n要点：①手向前伸直，肘关节不要弯；②眼睛看池底（下巴贴脖子）；③双腿蹬离池边后伸直并拢（脚也是）。\n\n\nTIP：漂浮怎么站起来\n\n在漂浮的状态下，先把双腿收起来，小腿贴大腿，大腿贴肚子。\n重心使劲向后移，双腿向下伸，下半身直立。\n双手向下压水，同时抬头，上半身挺直。\n\n\n蛙泳腿\n 陆上蛙泳腿动作\n 半陆半水（上半身在池边，下半身在水中）蛙泳腿动作\n 水上蛙泳腿\n\n第一阶段练习三个动作：收腿、翻腿、蹬夹腿。\n\n收腿：小腿收起，脚掌尽量贴紧屁股。大腿不动，小腿收回来。（大腿不必并拢，膝盖是分开的，大概 30°）\n\n小腿收回时，不要求大腿直直对着后面（与上面所述大腿不必并拢是一个意思），这样脚掌容易出水面，往后蹬腿时，就蹬空气了。稍微往下沉一些，大腿与水面夹角大概是 15°~30°。\n\n\n翻腿，大腿仍然尽量保持不动，小腿往两边翻开，此时脚掌要勾起来。这个动作做标准了，从正后方看上去，就是个标准的 W 形。\n\n小腿尽量往两边翻开，尽量往屁股方向贴紧，贴的越紧，蹬腿距离越长，动力更大。一定要脚丫心对着后侧方蹬出去。\n\n\n蹬夹腿：脚一边往两边（侧后方）蹬出去，一边往中间夹紧，伸直并拢，脚掌放松。蹬夹同时进行。\n\n\n第二阶段练习上面的动作熟练后，要开始进阶训练，即两个动作。\n\n直接翻腿：双腿直接由伸直并拢变成 W 形，注意，脚掌要勾起。\n蹬夹腿：脚一边往两边蹬出去一边往中间夹紧，伸直并拢，脚掌放松。\n\n\n练习方法：数 1，做动作 1（停顿 1 秒）；数 2，做动作 2（停顿 3 秒）；然后循环。练 20 次。\n\n第三阶段练习\n练习方法：数 1，做动作 1+2（停顿 3 秒）。然后循环。练 20 次。\n\n蛙泳腿和换气配合\n 水上固定支撑（扶着池边）漂浮蛙泳腿 + 换气（两次腿一次换气）\n 水上不固定支撑（教练扶着或扶着漂浮板）漂浮蛙泳腿 + 换气（渐进到一次腿一次换气）\n\n\n要点及练习方法：永远先低头（下巴贴脖子，把头砸进水里），再蹬腿。有先后次序，不能同时做，但也要连贯。低头马上蹬腿，然后漂三秒，再蹬一次，再漂三秒，然后换气。\n\n\nTIP：如何换气\n只需要把头抬起来，身体是平的，不要立起来；脚也别翘，双手也别压浮板，甚至抬头的时候，肩膀都别出水面，只需动脖子。\n\n蛙泳手\n 陆上蛙泳手\n 水上蛙泳手\n\n\n要点：①划手的动作，小一些，快一些；②一次划手，一次换气；③划手并不能产生多大的推进力，只是为了抬头换气。\n\n动作要领\n外划：手掌对着两侧，手臂往两侧打开略大于肩宽。这一过程几乎不产生推进力。\n内划：从慢动作上来看，是小手臂先往内收，再将手肘往中间并拢（阿弥陀佛手型），手掌在下巴的前下方一点点，就对了。内划的推进力，是靠“夹肘”产生的，而不是后划手。【有抱水的感觉】\n前伸：尽量伸快些，越慢阻力越大。手伸直，手掌最好朝下。\n停顿：三秒，和蛙泳腿一样。\n\n第一阶段练习\n练习方法：数 1，做动作 1；数 2，做动作 2；数 3，做动作 3；停顿。然后循环。练 20 次。\n\n第二阶段练习\n练习方法：数 1，做动作 1+2；数 2，做动作 3；停顿。然后循环。练 20 次。\n\n蛙泳手与换气配合\n 陆上蛙泳手 + 换气\n 水上蛙泳手 + 换气\n\n第三阶段练习\n练习方法：\n准备动作，弯腰，低头，眼睛看地上，双手向前伸直。\n数 1，做动作 1+2。【动作 1，双手分开（外划）的同时，抬头。然后 1+2 是连贯的。动作 2，身体可直立起来，增加节奏感。】\n数 2，做动作 3，同时低头，眼睛看向地面。\n然后循环。练 20 次。\n\n第四阶段练习\n练习方法：\n数 1，做动作 1+2+3，停顿三秒。即分手抬头，伸手低头，停顿三秒。然后循环。练习 20 次。\n\n\n要点：外划不要过大，内划和前伸要足够快，动作连贯有力。低头要低到水里，停顿三秒，可超不可少。\n\n蛙泳（连续换气 + 漂浮 + 蛙泳腿 + 蛙泳手）\n 两次腿 + 一次手 + 换气\n 一次腿 + 一次手 + 换气\n\n\n常见问题原因及解决方法游蛙泳下半身总是沉下去\n参考[1] page: 怎样快速有效地学习游泳？ - 知乎 (zhihu.com)\n","categories":["技能"],"tags":["游泳"]},{"title":"Word 使用说明","url":"/2022/11/03/013-Word-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","content":"在写一篇论文之前，最好先设置页面布局和样式，全文编辑好后，再进行页眉页脚的设置，最后再添加目录。本文慢慢更新，会把写论文时所遇到的排版问题，全部包括。\n页面布局设置\n布局 → 页面设置 → 纸张大小 → A4\n\n布局 → 页面设置 → 页边距 → 自定义边距\n\n\n\n\n样式设置正文此处强烈建议自己创建一个“我的正文”样式，作为论文的正文样式，不要修改 Word 自带的正文样式。因为内置正文样式是其他所有样式的基准，一旦更改，其他样式也会受到影响。\n字体：宋体 &#x2F; Times New Roman\n字号：小四\n段落：两端对齐。首行缩进 2 字符。1.5 倍行距。\n标题一级标题字体：宋体 &#x2F; Times New Roman\n字号：小三（加粗）\n段落：居中。段前段后 0.5 行。1.5 倍行距。\n二级标题字体：宋体 &#x2F; Times New Roman\n字号：四号（加粗）\n段落：两端对齐。1.5 倍行距。\n三级标题字体：宋体 &#x2F; Times New Roman\n字号：小四（加粗）\n段落：两端对齐。1.5 倍行距。\n多级列表链接标题即可。\n\n\n图表设计三线表样式操作：插入表格，选中。点击【表设计】选项卡，在【表格样式】中找到下拉箭头，弹出的窗口中设置【格式】，对样式命名为三线表。\n勾选【基于该模板的新文档】，这样三线表的样式就可以在以后新建的文档中应用。\n磅值要求：标题行上框线 1.5 磅，下框线 0.75 磅；汇总行下框线 1.5 磅。\n操作：接以上操作，点【格式】【边框和底纹】，在弹出的窗口中先设置好磅值，再点击对应的框线，顺序不可逆。\n注意：设置标题行上框线和汇总行下框线时，选择【应用于表格】\n​\t\t\t设置标题行下框线时选择【应用于标题行】\n\n\n\n\n\n\n\n\n\n参考文献全选，然后缩进选择悬挂，1.75 字符。\n","categories":["工具"],"tags":["Word","Office"]},{"title":"配置 Blog 遇到的“坑”","url":"/2022/11/03/014-%E9%85%8D%E7%BD%AE-Blog-%E9%81%87%E5%88%B0%E7%9A%84%E2%80%9C%E5%9D%91%E2%80%9D/","content":"开一篇文章，专门记录踩过的坑。很多问题大概率能够在 GitHub issue 里面找到。扒下来写到自己的博客里面就是自己的了。\n标题下有分割线的问题Typora 编辑器中标题分割线问题Cause：默认的 GitHub 主题默认配置造成的。\nSolution：文件(F) → 偏好设置 → 外观 → 打开主题文件夹 → 打开并编辑 github.css → 找到 h1、h2 字段，将 border-bottom 的样式修改为 none → 重启 Typora 即可。\nReference：Page: Markdown中的二级标题去掉默认的下划线_SoberGit的博客-CSDN博客_markdown 去掉下划线\nNext 主题，文章中标题分隔线问题Cause：Next 主题的默认配置\nSolution：位于 E:\\Blog\\themes\\next-reloaded\\source\\css_schemes\\Gemini 文件夹下，有个 index.styl 文件，用 Notepad++ 打开，找到第 119-140 行 Headers 设置，把 border-bottom 后的数字全部改为 0px。执行 hexo s 即可。\nReference：在网上找了一圈，发现并没有解决方法，自己摸索得到。不过还是参考了其他有关主题配置的文章，如Hexo+Next主题优化 - 知乎 (zhihu.com)\n\n标签问题多个标签问题Solution：首先根据大佬的步骤配置好Tags About Categories，然后按照最后格式书写即可。\nReference：Pages: Hexo 博客 NexT 主题下如何添加分类、标签_mb5fe32930661bd的技术博客_51CTO博客\n标签图标问题Solution：打开 themes/next/layout/_macro/post.swig 文件，搜索 rel=&quot;tag&quot;&gt;# ,将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;\nRefence：Page: Hexo+Next主题优化 - 知乎 (zhihu.com)\n\n！统计字数、阅读时长的问题安装了hexo-wordcount和hexo-symbols-count-time插件，在根目录的配置文件和主题配置文件中都搜索不到相应的字段。但是很玄学地在文章中和博客底部出现了相应的统计，但好像并不怎么准确。而且卸载插件也遇到问题，并不能卸载掉。\n这个问题可以先搁置，等以后阅读到官方文档解决。\n\n！主页文章添加阴影效果问题找不到教程中所说的themes/next/source/css/_custom/custom.styl文件。大概是NexT版本升级，很多地方都给改了。有评论提出在.../css/main.styl文件中修改，但是添加代码后并没有效果。\n2022&#x2F;07&#x2F;17 下午更新：大概是玄学问题，下午刷新的时候直接有了。不是在主页，而是点进去文章有。但是好像并没有多好看。放到这里做个记录吧。在main.styl文件最后直接加上的。\n// 主页文章添加阴影效果.post &#123;   margin-top: 50px;   margin-bottom: 60px;   padding: 25px;   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;\n\n\n","categories":["博客"],"tags":["Hexo","Next","Typora"]},{"title":"Overleaf 使用说明","url":"/2022/11/17/015-Overleaf-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","content":"标题图片表格数学公式参考文献\n新建文件，命名为 ref.bib。\n\n在 \\end&#123;document&#125; 前添加代码：\n\\bibliographystyle&#123;unsrt&#125; % unsrt 表示参考文献按照先后引用排序\\bibliography&#123;ref.bib&#125;\n\n在正文中引用的地方，添加 \\cite&#123;xxx&#125; ，xxx 表示 ref.bib 中 @article&#123;XXX, 。下面为 bib 的引用格式，通过百度或谷歌学术可以直接复制下来。其中 author 部分，人名多的话，可以直接中间加 and，只有最后一个 and 会显示。\n@article&#123;2005Structural,  title=&#123;Structural mechanics for electromagnetic railguns&#125;,  author=&#123; Tzeng, J. T. &#125;,  journal=&#123;IEEE Transactions on Magnetics&#125;,  volume=&#123;41&#125;,  number=&#123;1&#125;,  pages=&#123;246-250&#125;,  year=&#123;2005&#125;,&#125;\n\n","categories":["工具"],"tags":["Overleaf","LaTex"]},{"title":"ChatGPT 注册攻略","url":"/2022/12/05/016-ChatGPT-%E6%B3%A8%E5%86%8C%E6%94%BB%E7%95%A5/","content":"这几天看到大家很快乐地玩耍 ChatGPT，没赶上 AI 绘画，怎么也得玩一玩 AI 写代码。注册流程如下。\n\n需要一个国外手机号，我使用了网上推荐的 sms-activate.org。\n\n先注册。\n注册好后进行充值：选择支付宝支付，1 美元即可。\n\n\n注册 OpenAI 账号。\n这里确实遇到很多坑。比如一开始直接头铁用了 QQ 邮箱，结果显示在当前国家不可用。代理要开全局，为此又重新买了机场，改成了全局，然后清除网站 Cookie，在浏览器的设置中找到 Cookie 和网站权限，然后搜索 OpenAI 即可找到。到了这一步，在这个网址：https://beta.openai.com/signup 进行注册，选择 Continue with Google，我用了自己的 Gmail 邮箱注册，最后需要验证电话号码。\n\n在 sms-activate.org 网站的左侧边栏，搜索服务 OpenAI，选择后即可看到还有印度和巴西在售，随便买一个，付钱后会在右边生成电话号码，复制到刚刚需要验证电话号码的地方，点击验证，等待一会儿，就会收到验证码。网上说如果没有收到也没有关系，可以免费退款，然后再买个新的就行。\n\n打开 ChatGPT 的登录界面：https://chat.openai.com/auth/login，选择 Continue with Google，然后就进了对话界面。可以开始快乐了。\n\n\n","categories":["工具"],"tags":["ChatGPT","SMS-Activate"]},{"title":"将博客从 GitHub 迁移到 Gitee","url":"/2022/12/12/017-%E5%B0%86%E5%8D%9A%E5%AE%A2%E4%BB%8E-GitHub-%E8%BF%81%E7%A7%BB%E5%88%B0-Gitee/","content":"GitHub 被墙，常常部署失败。鉴于本博客不会键政或发涩涩的东西，故迁移到 Gitee（码云）上。\n详细步骤如下：\n\nGitee 注册。百度 Gitee 官网，点击注册即可。\n\n创建仓库。在右上角的加号那里可以找到。如图所示，输入仓库名称即可，其他就不用点，直接创建。\n\n\n创建完成后，可以点初始化 Readme 文件。\n\n点“服务”，选择 Gitee Pages。\n\n\n进行实名认证。等待审核。\n\n\n审核一直不通过，弃\n","categories":["博客"],"tags":["Gitee"]},{"title":"Ubuntu 初体验","url":"/2022/12/14/018-Ubuntu-%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"折腾了两天 Ubuntu，算是理清楚了怎么安装软件，怎么删除软件，以及配置一些环境。\nVMware Tools这个足足折腾了一下午。事实上，在最初装 Ubuntu 的时候，也就是快照 Version 0.1，我应该是点了相应的操作，已经安装好了。不能够拖拽复制的原因大概是新版本的 Ubuntu 不支持，事实上，小文件（如 Word 文档、图片等）可以通过复制粘贴的方式，拷贝到除桌面以外的文件夹中。也支持复制粘贴文字信息。说明 VMware Tools 是通着的。\n下午用了两个多小时，尝试了网上各种卸载、重装的方法，都无法把大文件拷贝过去，主机执行过拷贝动作，虚拟机的资源管理器就很难打开了。整个人都崩溃了。这是一个坑，要谨记。\nFTP 服务VMware Tools 不推荐使用，原因如上。于是就需要使用 FTP 服务来进行文件互传。\n开启 Ubuntu 下的 FTP 服务\nCtrl + Alt + T 打开 Ubuntu 终端，执行以下命令来安装 FTP 服务：\nsudo apt-get install vsftpd\n\n等待软件自动安装，完成后使用以下 VI 命令打开 /etc/vsftpd.conf ：\nsudo vi /etc/vsftpd.conf\n\n打开 vsftpd.conf 文件找到下面两行代码：\nlocal_enable=YESwrite_enable=YES\n\n确保上面两行前面没有“#”，有的话就取消掉。(后面补充 VI 的用法)\n\n修改完 vsftpd.conf 文件后保存退出，使用以下命令重启 FTP 服务：\nsudo /etc/init.d/vsftpd restart\n\nVI 的用法\n直接输入 vi + 文件名，就进入了 vi 的一般模式（也叫作命令模式）。如上面代码。\n在一般模式下，只要按下 i、o、a 等字符，就可以进入输入模式。在编辑模式中，可以发现在左下角状态栏中会出现 -INSERT- 的字样，那就是可以输入任意字符的提示。这个时候，键盘上除了 ESC 按键，其他都可以被视作一般的输入按钮。\n按下 ESC 键回到一般模式，在一般模式下按下 :wq 即可保存离开。\nReference：[Linux vi&#x2F;vim | 菜鸟教程 (runoob.com)](https://www.runoob.com/linux/linux-vim.html#:~:text=直接输入 vi 文件名 就能够进入 vi 的一般模式了。 请注意，记得 vi,a 等字符就可以进入输入模式了！ 在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。 这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。)\n\nWindows 下 FTP 客户端安装使用免费的 FTP 客户端软件：FileZilla 即可，安装 64 位版本。\n\n点击左上角：文件→站点管理器。\n\n点击“新站点(N)”，来创建站点，新建站点以后就会在“我的站点”下出现新建的站点，名称可以修改为 Ubuntu。\n\n选中 Ubuntu 站点，然后对其”常规”（右边）进行设置。如图所示。Ubuntu 系统的 IP 地址就是其 IPV4，在设置→网络→详细信息中可以看到。（也可以使用命令查看，需要先安装 net-tools）\nsudo apt-get install net-toolsifconfig -a //此命令即可查看\n\n\n\n设置好后点连接，保存密码即可。\n\n连接成功后，会看到 Ubuntu 文件目录下的中文目录是乱码的，这是因为编码方式没有选对，先断开连接，点击：服务器(S)→断开连接，然后打开站点管理器，选中要设置的站点 Ubuntu，选择“字符集”，设置为“强制 UTF-8”。\n\n重新连接到 FTP 服务器上，可以看到已显示正常。\n\n\nUbuntu 搜狗输入法安装\n添加中文语言支持。点击：系统设置→区域和语言→管理已安装的语言→在“语言” tab 下→添加或删除语言。弹出“已安装语言”窗口，勾选中文（简体），点击：应用。\n\n回到“语言支持窗口”，在键盘输入法系统中，选择“fcitx”。\n注：如果没有此选项，则打开终端进行手动安装。\nsudo apt-get install fcitx\n\n安装成功后，再执行上述步骤。点击“应用到整个系统”，关闭窗口，重启电脑。\n\n通过命令行安装搜狗输入法（提前下载好安装包，进入安装包所在的文件夹，执行命令。可以通过 tab 进行命令补全）。\nsudo dpkg -i sogoupinyin_版本号_amd64.deb\n\n切记要安装依赖，有两种方法，第一种我没有用，然后导致我不能用，输不了中文，然后网上查到第二种，输入法才能用。这又是一个坑。\nsudo apt -f install\n\nsudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2sudo apt install libgsettings-qt1\n\n现在还是要在右上角进行手动调输入法，不知道有什么快捷键。以后如果有新发现，来填坑（2022&#x2F;12&#x2F;14 凌晨）。Ctrl + 空格 可以切换成半角英文输入状态。\n\n\nUbuntu VSCode 安装Ubuntu 22.10 内置 python3。在终端输入以下命令就能看到：\npython3 --version\n\n\n命令行安装 VSCode，与上述搜狗输入法的第 3 步相同：\nsudo dpkg -i code_版本号_amd64.deb\n\n安装好后，直接在命令行中敲 code 即可打开 VSCode。\n在 VSCode 中安装扩展：Python 套件、C&#x2F;C++ 套件、Markdown 套件。不要装中文插件。\nUbuntu 中使用 Python 的小例子\n直接在命令行中输入 python3 敲回车，可以得到 python 的 IDE，能直接写 Python 代码，如图所示：\n\n\n退出 IDE 的组合键是 Ctrl + Z。\n\n创建 .py 文件（创建文件的方式有很多种，这里只用了一种），执行完第一行命令后，使用文本编辑器打开（也可以用 VSCode 打开写代码），输入代码，Ctrl + S 保存，然后用第二行命令运行编译。\n\n\n\n\nUbuntu 安装 Hexo\n安装 Nodejs。因为 Hexo 是基于 Nodejs 的，所以必须安装。\nsudo apt update //更新软件包索引sudo apt install nodejs npm //安装 nodejs 和 npm……安装完成后，查看是否安装成功nodejs -vnpm -v\n\n\n\n安装 git。\nsudo apt install git……安装完成后，查看是否安装成功git -v\n\n\n\n安装 Hexo。在主文件下新建一个文件夹，命名为 Records（可以不建，在初始化的时候建），然后在这个文件夹中打开终端，输入命令行。\nsudo npm install hexo-cli -g //前面一定要加 sudo，不然报错，又是一个坑\n\n初始化 Hexo。\nhexo init //如果写成 hexo init Records，就会新建一个文件夹。\n\n继续在 Records 文件夹下操作，安装组件。\nsudo npm install\n\n安装完后，出现报错。会提示使用如下命令行修复：\nnpm audit fix --force\n\n\n\n\n\n本地预览，在 localhost:4000 中可查看。\nhexo s //等同于 hexo serve\n\n","categories":["Linux"],"tags":["FTP","Ubuntu","VM"]},{"title":"Zotero + 坚果云","url":"/2023/01/05/019-Zotero-+-%E5%9D%9A%E6%9E%9C%E4%BA%91/","content":"注册 Zotero 账号打开 Zotero 软件，依次点击 编辑 → 首选项 → 同步 → 注册账号，会自动跳转 官网注册地址 。依次输入用户名、邮箱、密码，进行人机身份验证后，点击注册。注册完后在相同的界面登录。（账号密码保存在 iCloud 钥匙串中，搜 Zotero）\n【注】QQ 邮箱不行，不知道为什么，换了 Gmail。之后会给邮箱发一条验证邮件，点击即可完成注册。\n注册坚果云账号打开 坚果云官网，输入电子邮箱、登录密码，点击下一步，输入手机号、验证码，完成注册。登录进入个人账号界面，依次点击 右上角用户名 → 账户信息 → 安全选项，找到 添加应用 按钮，命名为 Zotero，点击 生成密码，复制密码，之后会用到。\n同步Windows 端\n\niPad 端\n","categories":["工具"],"tags":["Zotero","坚果云"]},{"title":"虚拟机安装 Ubuntu","url":"/2023/01/08/020-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85-Ubuntu/","content":"准备\n Ubuntu 22.10 镜像文件（下载 arm64 版本）\n VMware 16.2.3 虚拟机\n\n安装\n打开 VMware，新建虚拟机。\n\n安装方式选择【自定义】（显得高级）。点击下一步。\n\n选择【Workstations 16.2.x】（默认）。点击下一步。\n\n选择【稍后安装操作系统】。点击下一步。\n\n操作系统选择【Linux】，版本选择【Ubuntu 64 位】。点击下一步。\n\n虚拟机名称【（默认）】，位置在 E 盘创建一个新的文件夹【Ubuntu 22.10】。点击下一步。\n\n如果笔记本性能可以的话，就处理器数量【2】，内核数量【2】。点击下一步。\n\n笔记本最大内存为 40G，分配【8G】。点击下一步。\n\n网络类型选择【NAT】。点击下一步。\n\nI&#x2F;O 控制器使用【推荐】。点击下一步。\n\n虚拟磁盘类型使用【推荐】。点击下一步。\n\n选择【创建新虚拟磁盘】。点击下一步。\n\n磁盘大小为【40G】（E 盘为 2T），选择【立即分配所有磁盘空间】【将虚拟磁盘存储为单个文件】。点击下一步。\n\n磁盘文件命名【默认】。点击下一步。\n\n点击完成。\n\n创建完成后，点击【CD&#x2F;DVD(SATA)】，选择【使用 ISO 映像文件】。点击确定。\n\n点击开启虚拟机。根据屏幕提示操作。\n\n进入安装界面。选择【中文（简体）】，点击【安装 Ubuntu】。\n\n键盘布局默认。点击继续。\n\n选择【正常安装】，把【安装 Ubuntu 时下载更新】选项去掉。点击继续。\n\n默认。点击【现在安装】。\n\n\n点击继续。\n\n时区默认【Shanghai】。点击继续。\n\n设置用户名及密码。点击继续。（等待……\n\n安装成功。（由于网络问题，下载语言包&#x2F;软件包过于慢，点击 Skip）\n\n重启电脑。\n\n更改分辨率：设置→显示器，选择【2560x1600（16:10）】。\n\n换源：打开【软件和更新】，选择【下载自：阿里云】。\n\n更新软件及升级系统。\nsudo apt update   //检查更新sudo apt upgrade  //升级更新sudo reboot       //重启系统\n\n折腾一晚上，VMtools 还是一个玄学问题。但是对于桌面的分辨率自动调整，有另外的方案：\nsudo apt install open-vm-toolssudo apt install open-vm-tools-desktop\n\n参考八分钟完成VMware和ubuntu系统安装-哔哩哔哩\n其他安装 Chrome科学上网是很麻烦的一件事情。\n常用命令行\n\n","categories":["工具"],"tags":["Ubuntu","VM"]},{"title":"Win11 软件目录","url":"/2023/01/11/021-Win11-%E8%BD%AF%E4%BB%B6%E7%9B%AE%E5%BD%95/","content":"\n\n\nNo\n名称\n功能\n\n\n\n1\n7-Zip 22.00（x64）\n解压缩\n\n\n2\nAdobe Photoshop CC 2019\n\n\n\n3\nCAJViewer\n\n\n\n4\nClash for Windows 0.19.23\n科学上网\n\n\n5\nCPUID CPU-Z 2.02\n\n\n\n6\nFlieZilla Client 3.59.0\n\n\n\n7\nGit\n\n\n\n8\niTuens\n\n\n\n9\nJava 8 &#x2F; 9.0.1\n\n\n\n10\nKeil\n\n\n\n11\nListary version 6.0\n\n\n\n12\nMathpix Snipping Tool\n识别公式\n\n\n13\nMathType 6.9\n输入公式\n\n\n14\nMicrosoft Office LTSC 专业增强版 2021\n\n\n\n15\nMicrosoft Visio\n流程图\n\n\n16\nMotrix 1.6.11\n磁力下载\n\n\n17\nNode.js 16.16.0\n\n\n\n18\nNotepad++ 8.4.2\n\n\n\n19\nObinsKit 1.2.11\n\n\n\n20\nPicGo 2.3.0\n\n\n\n21\nPotPlayer\n\n\n\n22\nResilio Sync\n\n\n\n23\nSiemens NX 12.0（UG）\n\n\n\n24\nSteam\n\n\n\n25\nSTM32CubeMX\n\n\n\n26\nTypora 1.2\n\n\n\n27\nVMware Workstation 16.2.3\n\n\n\n28\nXMind version 11.1.2\n\n\n\n29\nZLibrary\n\n\n\n30\nZotero\n\n\n\n31\n爱思助手 7.0\n\n\n\n32\n白描桌面版 0.2.6\n\n\n\n33\n百度网盘\n\n\n\n34\n大白菜超级 U 盘装机工具\n\n\n\n35\n火绒安全软件\n\n\n\n36\n搜狗输入法 12.2.0\n\n\n\n37\n腾讯 QQ\n\n\n\n38\n腾讯会议\n\n\n\n39\n网易有道词典\n\n\n\n40\n微信\n社交\n\n\n41\nTranslucentTB（汉化 by tpxxn）\n任务栏透明\n\n\n42\nMagicPods\nAirPods\n\n\n43\nXshell + Xftp\nSSH\n\n\n44\n迅捷视频转换器\nGIF\n\n\n2023&#x2F;03&#x2F;30（补）\n\n\n\nNO\n名称\n功能\n\n\n\n1\nAnaconda3 2022.10（Python 3.9.13 64-bit）\n\n\n\n2\nbalenaEtcher 1.14.3\n\n\n\n3\nCAD 梦想画图 x64\n\n\n\n4\nConnect\n米物鼠标\n\n\n5\nFastStone Capture 9.7\n图片标注\n\n\n6\nlx-music-desktop 2.1.2\n\n\n\n7\nMicrosoft Visual Studio Code（User）\n\n\n\n8\nPower Toys（Preview）x64\n窗口置顶\n\n\n9\nPython 3.11.2（64-bit）\n\n\n\n10\nSakuraFrp 启动器\n内网穿透\n\n\n11\nScreenToGif\n\n\n\n12\nSDFormatter\n内存卡格式化\n\n\n13\nUniversal Adb Driver\n安卓调试工具\n\n\n14\nWin32DiskImager version 0.9.5\n内存卡烧 img 镜像\n\n\n15\n阿里云盘\n\n\n\n16\n阿里旺旺\n\n\n\n17\n欧路词典\n\n\n\n18\n向日葵\n\n\n\n绿色软件（免安装直接启动）\n\n\nNO\n名称\n位置\n\n\n\n1\nSnipaste-2.8.3-Beta-x64\nD:\\Program Files (x86)\n\n\n2\nv2rayN-Core\nD:\\Program Files (x86)\n\n\n3\nBandicam_v4.5.7 免安装版录屏软件\nD:\\Program Files\n\n\n4\nCubox\nD:\\Program Files\n\n\n5\nlx-music-desktop-v2.2.0-win_x64-green\nD:\\Program Files (x86)\n\n\n6\nsteamcommunity_302\nD:\\Program Files\n\n\n7\nventoy-1.0.88-windows\nD:\\Program Files\n\n\n","categories":["工具"],"tags":["软件"]},{"title":"Xshell 连接 VM 虚拟机","url":"/2023/01/19/023-Xshell-%E8%BF%9E%E6%8E%A5-VM-%E8%99%9A%E6%8B%9F%E6%9C%BA/","content":"准备工作\n官网下载 Xshell 和 Xftp。（输入邮箱后，会收到下载地址）\n\n在 Ubuntu 中安装 openssh\nsudo apt install openssh-server\n\n连接步骤\n复制 Ubuntu 的 IP 地址。\n在 Xshell 中新建，填写名称（自己命名）和主机（填 IP），点【连接】。\n输入登录的用户名和密码（Ubuntu 的用户名和密码）。\n连接成功后可以使用命令行对虚拟机进行操作。\n右键【名称】，点【用 Xftp 打开】，就可以互相传文件了（类似 FileZilla）。\n\n","categories":["工具"],"tags":["Xshell","Xftp"]},{"title":"Git 版本控制","url":"/2023/01/24/024-Git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","content":"\n进入文件夹，右键 Git Bash Here\n\n初始化，让 git 帮助我们管理当前文件夹。\ngit init\n\n检测状态：查看可以用 Git 管的文件。\ngit status\n\n使用 Git 管理具体文件。\ngit add 具体文件名\n\n使用 git status 查看，发现被管理的文件变绿了，没有被管理的还是红色的。\n\n红色：新增文件 &#x2F; 或修改的老文件 → 需要 git add 文件名\n绿色：git 已经管理起来了 → 需要 git commit -m &#39;描述信息&#39;\n透明色（看不到）表示已经全部被管理起来了。\n\n\n使用 Git 管理所有文件的快捷命令（add 后面加个点）。\ngit add .\n\n生成版本。\ngit commit -m &#x27;version 1&#x27;\n\n使用 git status 查看，发现什么都没有了，意味着所有的文件已经被管理起来，并生成版本了。\n\n对文件内容进行修改。使用 git status 查看，检测到有文件被修改。需要继续使用 git add 的命令将其管理起来，可以后面接具体的文件名，也可以使用【点】，把所有被修改的文件都管理起来。管理起来后，使用 git commit -m &#39;描述信息&#39; 生成版本。\ngit commit -m &#x27;version 2&#x27;\n\n查看版本记录。\ngit log\n\n报错！需要生成个人的信息配置。\ngit config --global user.email &quot;you@example.com&quot;git config --global user.nam &quot;Your Name&quot;\n\n命令行生成文件。\ntouch test.py\n\n回滚功能，回滚到之前的版本（版本号使用 git log 查看）。\ngit reset --hard 版本号\n\n回滚到之后的版本。\ngit refloggit reset --hard 版本号\n\n\n\n使用 git checkout -- 文件名 或 git restore 文件名 将工作区对文件的修改撤销。\n\n使用 git reset HEAD 文件名 或 git restore --staged 文件名 将暂存区的文件撤回到工作区。\n\n主干线 Master。\n\n查看 &#x2F; 创建 &#x2F; 切换分支\ngit branchgit branch 分支名git checkout 分支名\n\n将分支合并到 Master：首先将分支切换回 Master，然后执行合并代码，之后删除该分支。\ngit checkout master //注意一定要切换分支，分清楚谁来合并谁git merge 要合并的分支名git branch -d 已合并的分支名\n\n合并时报错：产生冲突，需要手动解决。解决完后，使用 git status 检测到有文件被修改，使用 git add . 进行管理，使用 git commit -m &#39;描述信息&#39; 进行提交。\n\n工作流，一般不在 Master 分支写代码，都在 dev 上写。稳定了再合并到 Master 分支。\n\n\nGithub\n流程 1：注册账号→创建仓库→本地代码推送。\ngit remote add origin 远程仓库地址 //起别名，可以叫 origin，也可以叫别的git push -u origin mastergit push -u origin dev    //有几个分支推送几个分支\n\n流程 2：从 Github 拉到本地\ngit clone 远程仓库地址\n\n在新电脑上开发，切换到 dev 分支，保证 dev 分支中的代码是最新的。\ngit checkout devgit merge master //把 master 中的代码合并到 dev 中 [仅执行一次]\n\n写完后还要推送到 Github 上。\ngit push origin dev //把 -u 简写掉\n\n回到家中，先切换到 dev 分支，再把代码从远程仓库拉下来。\ngit checkout devgit pull origin dev\n\n写完后，再执行一系列的命令。如下：\ntouch a2.pygit add .git commit -m &#x27;在家深夜写的代码 a2.py&#x27;git push origin dev\n\n到公司后，又要把家里写的代码从远程仓库拉下来。\ngit pull origin dev\n\n……（重复以上步骤）\n\n开发完毕后，上线。\ntouch a3.pygit add .gigit checkout mastergit merge devgit push origin master//把 dev 分支也推送到远程仓库git checkout devgit merge dev //一个习惯，其实都已经是最新的了git push origin dev\n\n偶然事件：在公司忘记推送代码。在家又写了新的代码推送到了远程仓库中。到了公司将远程仓库的代码拉下来，会和之前在公司忘记推送的代码产生冲突，需手动合并。\n\n\nrebase（变基）命令使 git log 简洁。注意：如果有已推送到远程仓库的代码，就不要合并它了。\n\n将自己的提交记录合并，合并的是文件版本号之后的所有版本。多个记录合并成一个记录。\ngit rebase -i 文件的版本号\n\n强行将 dev 分支插入到 master 分支中去。(没有弄懂)\ngit log --graph --pretty=format:&quot;%h %s&quot; //图形化查看分支提交记录//在 dev 分支中写代码git checkout devtouch s1.pygit add .git commit -m &#x27;s1&#x27;//在 master 分支中写代码git checkout mastertouch s2.pygit add .git commit -m &#x27;s2&#x27;//切回到 dev 分支中 rebasegit checkout devgit rebase master//切回到 master 分支中把 dev 的代码 merge 过来git checkout mastergit merge dev//以上即可完成\n\n云端和本地代码的合并。\ngit pull origin dev↓git fetch origin devgit rebase origin/dev\n\n多人协作工作流\n在 Github 中创建组织，在组织中创建项目。（需要收费）\ngit remote add origin 远程仓库地址git push -u origin master\n\n基于 tag 做版本控制。相当于把一长串的哈希值用标签来表示。\ngit tag -a 版本号 -m &#x27;描述信息&#x27;\n\n把 tag 也推送到远程仓库中\ngit push origin --tags\n\n创建并切换到 dev 分支。\ngit checkout -b dev\n\n把 dev 分支推送到远程仓库。\ngit push origin dev\n\n给开源软件贡献代码\nfork 源代码（可以导到自己的个人账户里面）。\n\n在自己的仓库中修改，然后上传到自己的远程仓库中。\ngit clone 远程仓库地址cd tensorflow/  //进入该文件夹touch bug.py    //修改了bug，假设是创建了文件git add .git commit -m &#x27;xxx&#x27;git push origin master\n\n给源代码作者提交修改 bug 的申请（pull request）。\n\n\n其他\n三个配置文件 local  global  system。\n\n项目配置文件：项目&#x2F;.git&#x2F;config\ngit config --local user.name &#x27;xxx&#x27;git config --local user.name &#x27;xxx@xx.com&#x27;\n\n全局配置文件：~&#x2F;.git&#x2F;config\ngit config --global user.name &#x27;xxx&#x27;git config --global user.name &#x27;xxx@xx.com&#x27;\n\n系统配置文件：&#x2F;etc&#x2F;.git&#x2F;config\n     git config --system user.name &#x27;xxx&#x27;     git config --system user.name &#x27;xxx@xx.com&#x27;          需要有 root 权限2. 应用场景3. 免密登录   - URL 中体现   - SSH 实现   - git 自动管理凭证4. gitignore 忽略文件   让 Git 不再管理当前目录下的某些文件，更多可参考 github 中的 ignore（搜索即可）\n\n*.h!a.hfiles&#x2F;*.py[c|a|d]\n\n\n\n任务管理\n\nissues：文档以及任务管理，也可以作为查找遇到的问题的方式。\nwiki：项目介绍\n\n\n\n参考\n01 git是什么？_bilibili_哔哩哔哩_bilibili\n\n","categories":["工具"],"tags":["Git"]},{"title":"Git Bash 的字体背景和颜色显示","url":"/2023/01/29/025-Git-Bash-%E7%9A%84%E5%AD%97%E4%BD%93%E8%83%8C%E6%99%AF%E5%92%8C%E9%A2%9C%E8%89%B2%E6%98%BE%E7%A4%BA/","content":"终端显示字体背景和字体颜色在命令行下能产生五颜六色的字体和图案，只需要加上一些颜色代码，如：\necho -e &quot;\\033[0;40;32m正在为您备份博客中……\\033[0m Hello&quot;\n\n\necho ：bash 解释的脚本，需要用 -e 表示反斜线转义打开\n\\033 ：声明转义序列的开始，后面用 \\033[0m 关闭转义序列\n[x;xx;xxm ：后面开始定义颜色\n0 表示终端默认设置（黑底白字）；40 表示字的背景颜色（40–47）；32 表示字体颜色（30–37）\n\n\n\n\n\n\n字的特殊属性\n字的背景颜色\n字体颜色\nColor\n\n\n\n0：终端默认，黑底白字\n40\n30\n黑\n\n\n1：加粗\n41\n31\n红\n\n\n4：使用下划线\n42\n32\n绿\n\n\n5：闪烁\n43\n33\n黄\n\n\n7：反白显示\n44\n34\n蓝\n\n\n8：不可见\n45\n35\n紫\n\n\n\n46\n36\n深绿\n\n\n\n47\n37\n白\n\n\n示例echo -e &quot;\\033[30;40m正在为您备份博客中……\\033[0m&quot;  //颜色一样就不会显示echo -e &quot;\\033[31;40m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[32;40m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[33;40m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[34;40m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[35;40m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[36;40m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[37;40m正在为您备份博客中……\\033[0m&quot;\n\n\necho -e &quot;\\033[40;30m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[41;30m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[42;30m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[43;30m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[44;30m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[45;30m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[46;30m正在为您备份博客中……\\033[0m&quot;echo -e &quot;\\033[47;30m正在为您备份博客中……\\033[0m&quot;\n\n\n","categories":["工具"],"tags":["Git","Linux"]},{"title":"把 Ubuntu 22.04 LTS 安装到移动硬盘","url":"/2023/02/10/026-%E6%8A%8A-Ubuntu-22.04-LTS-%E5%AE%89%E8%A3%85%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98/","content":"准备工作\nU 盘：金士顿 64G USB3.2\n移动硬盘：三星 250G SSD 970 EVO Plus\n镜像文件：ubuntu-22.04.1-desktop-amd64.iso（3.56G）\n烧录工具：balenaEtcher-Setup-1.14.3.exe\n\n安装步骤\n烧录，创建安装介质。插入准备好的 U 盘，选择镜像文件和 U 盘，按提示进行操作。\n\n\n\n\n关机。分别插入烧录好的 U 盘和准备装系统的移动硬盘。\n\n开机。闪过 Logo 时，按 ESC 键，选择带有 Kingston 的选项。（注：本次操作的硬件平台为华硕幻 16 笔记本电脑，ESC 选择启动项，F2 进入 Bios 面板）\n\n进入选择是否安装 Ubuntu 界面，按下 e 键，进入编辑开机指令的模式，找到 quite splash 字样，在后面加上 nomodeset 字样，用于屏蔽独立显卡，以免出现黑屏或死机的情况。 按 Ctrl + X 组合键启动系统。\n\n\n进入 Ubuntu 22.04 安装界面，按照提示操作。\n\n\n\n\n\n\n\n\n找到想要安装系统的移动硬盘，将下面的分区全部删掉或新建分区表，得到下图所示的情况。\n\n\n对空闲的 20G 空间进行操作。点击 + 创建分区。一般情况下，需要一个 EFI 分区，用于系统启动的引导，分配 1G 就可以；需要一个交换空间，笔记本的内存多大，它分配多大就行；需要一个 &#x2F; 根目录分区，分配剩余空间即可。主分区最多只能有 4 个，但一般只分配三个，为了之后好划分逻辑分区。注意最后一步，安装启动引导器的设备，一定要选类型为 efi 的 /dev/sda1 的分区。\n\n\n\n\n\n\n\n\n\n\n\n\n\n按照提示依次点击“继续”。\n\n\n\n\n\n\n\n\n安装完毕。（注：如果用虚拟机安装，则不需要进行自定义安装，不然无法读取 EFI 分区，进不了系统。本文使用 VMware Workstation 16 Pro 进行演示截图）\n\n\n\n\n新装 Ubuntu 后必做的小事查看窗口系统窗口系统为 Wayland，22.04 默认开启。注销后可点击右下角的齿轮图标更换成 X11（点击用户名，在输入密码的界面才有小齿轮）。\n\n\n换源打开软件和更新，选择最佳服务器，进行换源。点击关闭后会自动更新软件缓存。\n\n\n\n\n命令行更新软件包打开终端，输入以下命令：\nsudo apt updatesudo apt upgrade\n\nAPT 介绍：\n\n\n在 Dock Click 上启用最小化即单击任务栏应用图标可以最小化界面。默认是关闭的，在命令行窗口中使用以下命令激活：\ngsettings set org.gnome.shell.extensions.dash-to-dock click-action &#x27;minimize&#x27;\n\n更改主目录文件名为英文先更改系统语言为英文，在询问是否将目录转化为英文的窗口中选择同意。然后将系统语言再改回中文，关机重启，在询问是否将目录转化为中文的窗口中选择不同意。\nexport LANG=en_USxdg-user-dirs-gtk-update---export LANG=zh_CN\n\n如何更改系统语言参考：如何使Ubuntu的语言变成中文？？ - 腾讯云开发者社区-腾讯云 (tencent.com)\n提示：拖拽移动。\n安装 opensshsudo apt install openssh-server\n\n安装 Clash虚拟机方式：\n通过 XShell 连接虚拟机，打开 Xftp，将 Clash 安装包传到 Ubuntu。\ntar -xzvf file.tar.gz //解压tar.gz\n\n物理机方式\n从官网下载：Releases · Fndroid&#x2F;clash_for_windows_pkg (github.com)\ntar -xzvf file.tar.gz //解压tar.gz\n\n解压后，双击 CFW 文件即可使用。\n安装 Pigcha\n官网地址：https://run.pigcha.com\n\n根据提示安装缺失的 fuse2 库。\nsudo apt install libfuse2 -y\n\n解压下载的安装包（.zip）\nunzip PigchaClient_deb.zip\n\n安装 Pigcha：注意查看文件夹里的文档\nsudo dpkg --add-architecture i386 &amp; sudo dpkg -i PigchaClient.deb\n\n安装 Chrome 浏览器\n官网下载 &#x2F; 命令行下载\nwget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\n\n安装 deb 软件包\nsudo mv google-chrome-stable_current_amd64.deb /usr/local //第三方软件一般安装到这个目录cd /usr/localsudo dpkg -i google-chrome-stable_current_amd64.deb---//如果提示有依赖库未安装sudo apt --fix-broken installsudo dpkg -i google-chrome-stable_current_amd64.deb\n\n安装 Zotero\n官网下载 deb 包镜像地质：https://mirror.mwt.me/zotero/deb/\n安装步骤与上述 Chrome 浏览器的一致。可能会提示有依赖库未安装，执行以上命令即可。\n\n\n卸载 Snap参考：技术|怎样在 Ubuntu Linux 中移除 Snap 软件包\n注：由于命令过多，可使用 Shell 自动化完成。\n安装新立得可以解决有些软件包无法升级的问题。\n\n\n参考：Ubuntu 软件包管理利器 - 新立得 (Synaptic)_新立得软件包管理器_iBlackAngel的博客-CSDN博客\nShell 编程小知识如果使用 Windows 系统中的 Notepad++ 编写，则要转为 Unix 格式，才能在 Linux 中运行。\n\n\n#!/bin/sh命令1命令2\n\n执行\n./filename.sh\n\n安装 Ubuntu-restricted-extras 包：编码器、微软字体sudo apt install ubuntu-restricted-extras \n\n在安装过程中，使用 Tab 来选择 OK，并按 Enter。\n参考：安装完 Ubuntu 22.04 后推荐做的11件事情_ubuntu22.04安装后_鸠摩智首席音效师的博客-CSDN博客\n\n\n安装 GNOME tweakssudo apt install gnome-tweaks -y\n\n\n\n安装 open-vm-toolssudo apt install open-vm-toolssudo apt install open-vm-tools-desktopreboot\n\nopen-vm-tools：这个装上之后虚机就有了显示驱动，屏幕可以自适应大小\nopen-vm-tools-desktop：作用主要是主机和虚拟机之间的复制粘贴（共享粘贴板，大文件不行）。\n参考：安装Vmware Tools和open-vm-tools_强钦钦的博客-CSDN博客_open-vm-tools\n安装 Gnome 扩展管理器sudo apt install gnome-shell-extension-manager -y\n\n\n","categories":["Linux"],"tags":["Ubuntu","Linux"]},{"title":"成为尊贵的 ChatGPT Plus 用户","url":"/2023/02/19/027-%E6%88%90%E4%B8%BA%E5%B0%8A%E8%B4%B5%E7%9A%84-ChatGPT-Plus-%E7%94%A8%E6%88%B7/","content":"准备工作\n一个可用的 ChatGPT 账号\n一条日本或美国地区的线路\n一张虚拟信用卡\n一些 USDT（加密货币）\n\n操作步骤\n登录 ChatGPT，检测升级资格\n平时无论怎样更换线路登录，都会显示 ChatGPT is at capacity right now 或者 429 You are being rate limited。看到网上有人说使用无痕浏览模式可以进去，尝试发现此方法可行。\n我的登录方式：使用设备为一台 iPhone 13，打开 Shadowrocket，选择一条日本或美国线路，全局路由改为代理。打开 Safari 浏览器，选择无痕浏览模式，登录 ChatGPT，经过一系列检测和输账号密码后，成功进入熟悉的界面。点击左上角的三条杠，看到可以升级 Plus（自 2023&#x2F;02&#x2F;11 起，Plus 资格不再排队）。点击该按钮，看到为 $20&#x2F;mo，升级该计划，进入输信用卡的界面。这里我用的是日本的线路，不知道为什么使用美国的线路，该界面显示不出来，请注意避坑。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n创建虚拟信用卡\n默认无海外信用卡（发卡地区为国外，非大陆、香港）。\n使用 Depay 虚拟信用卡，打开 Depay 官网，完成正常注册。注册成功后下载 APP，iOS 需要国外 AppStore 账号。打开该 APP，在个人选项中将语言设置为中文。点击申请卡。我选择了不需要开发费的。1 USDT（泰达币）≈ 1 USD（美元）≈ 7 CNY（人民币）。需要进行 KYC 验证，即实名认证，根据提示操作。通过实名认证后，再次回到首页，点击申请卡，会向手机或邮箱发送一条验证码，填上即可申请得到一张虚拟信用卡。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n购买 USDT\nDepay 无法直接通过国内渠道付款，因此需要通过在其它平台购买 USDT 泰达币，提现到自己的 Depay 账户中（最好的方式是找朋友熟人帮忙转账，因为平台购买 USDT，需要 24h 才能提现），之后把 USDT 兑换成美元，兑换完成后会自动提示已转到虚拟信用卡中。\n由于没有朋友或者熟人玩加密货币，根据网友提供的信息，最后选择在 OKX（欧易）交易平台购买 USDT，这是其官网（不含邀请链接）。注册登录后，在网站上方的导航栏中选择【买币→快捷买币】，汇率是浮动的，不过大概需要 160 元左右。接下来按提示进行交易，最后会与个人卖家进行微信或支付宝转账。\n 注意：购买 ChatGPT 需要 20 美元&#x2F;月，由于 OKX 的提现手续费为 2 美元，Depay 的标准卡 USDT 转 USD 手续费为 1 美元，因此共计需要充值 23 个 USDT。另外，购买时也会有相应的损耗，因为汇率是不一样的，第一张图显示 6.9 CNY，第二张图为 7 CNY，等到付款时还可能是 7.01 CNY。千万不要充少了，不然二次充值后转账必须大于5美元，会非常非常亏！！ \n\n\n\n\n\n\n\n\n\n\n\n提现\n经过漫长的 24h 等待，终于可以提现了。\n打开 Depay APP，依次选择【钱包→USDT→充币→复制串码】。\n打开 OKX APP（同样需要国外 AppStore 账号，已提前下载好），依次选择【资产→提币→USDT→链上提币】，将复制好的串码粘贴到【提币地址】，提现网络选择【USDT-TRC20】，选择【提取全部】，按提示进行输入验证码，预计到账时间 4 分钟。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n兑换\n打开 Depay APP，可以看到钱包中已有 22.14 USDT，点击兑换，发现可兑换 21.89 USD，兑换成功后，提现扣除 1 美元手续费，卡内余额为 $20.89。\n\n\n\n\n\n\n\n\n\n\n\n购买 ChatGPT Plus\n让 ChatGPT 自动生成日本的地址：生成一个日本东京的地址。\n依次填写银行卡信息和地址，最后点确认。完成后会重新登录，之后就会看到自己已经成为了尊贵的 ChatGPT Plus 用户。\n完结，撒花✿✿ヽ(°▽°)ノ✿✿\n\n\n\n\n\n\n\n\n\n\n参考\nChatGPT Plus注册全攻略 — btc大糊涂 (mirror.xyz)\nChatGPT Plus 增值版申请付费流程-步骤、支付方式、注意事项 ｜ openAI\n\n","categories":["工具"],"tags":["ChatGPT","加密货币","虚拟信用卡"]},{"title":"Hexo 如何优雅地隐藏文章","url":"/2023/02/20/028-Hexo-%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%9A%90%E8%97%8F%E6%96%87%E7%AB%A0/","content":"本文介绍一款插件：hexo-hide-posts。这款插件可以在博客中隐藏指定的文章，但又不完全隐藏。\n当一篇文章被设置为 hidden: true 时，它将不会出现在任何列表中，包括首页、存档、分类、标签等，也不会被搜索引擎索引到（前提是搜索引擎遵守 noindex 标签）。只能通过该文章链接进行访问。\n下面介绍如何安装、配置、使用。\n\n安装：在站点根目录下执行以下命令。\nnpm install hexo-hide-posts --save\n\n配置：在站点根目录下的 _config.yml 中，添加如下配置：\n# hexo-hide-postshide_posts:  enable: true  # 可以改成其他你喜欢的名字  filter: hidden  # 指定你想要传递隐藏文章的 generator，比如让所有隐藏文章在存档页面可见  # 常见的 generators 有：index, tag, category, archive, sitemap, feed, etc.  public_generators: []  # 为隐藏的文章添加 noindex meta 标签，阻止搜索引擎收录  noindex: true\n\n使用：在文章的 Front-matter 中添加 hidden: true 即可隐藏文章。\n---title: &#x27;Lorem Ipsum&#x27;date: &#x27;2019/8/10 11:45:14&#x27;hidden: true---Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n\n参考\n插件的 GitHub 地址\nHexo 如何隐藏文章 - 咖里De (garryde.com)\n\n","categories":["博客"],"tags":["Hexo","Hidden"]},{"title":"Excel 使用说明","url":"/2023/02/27/029-Excel-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","content":"求和公式=SUM(XX:xx)\n操作\n在 Excel 表格中输入 =SUM(\n选中要相加的表格区域\n输入相应的右括号 ) 并按下回车。\n\n演示\n","categories":["工具"],"tags":["Office","Excel"]},{"title":"使用 Python 爬取大乐透中奖号码","url":"/2023/02/28/030-%E4%BD%BF%E7%94%A8-Python-%E7%88%AC%E5%8F%96%E5%A4%A7%E4%B9%90%E9%80%8F%E4%B8%AD%E5%A5%96%E5%8F%B7%E7%A0%81/","content":"准备工作安装所需要的库\n执行 win+R，输入 cmd，调出命令行，执行以下程序。\npip install requestspip install BeautifulSouppip install pandas---#可通过 help 命令查看该库的使用方法import requestshelp(requests)\n\n爬取网站\n【超级大乐透历史数据】_超级大乐透历史数据_体彩大乐透历史数据-500彩票网\n该网站源代码并非是通过页面跳转来查找不同数据，通过 F12 查找 network 栏找到真正储存所有历史开奖结果的网页：http://datachart.500.com/dlt/history/newinc/history.php?start=07001&amp;end=230202\n爬取步骤\n源代码\n# 这三个是第三方库，需安装后才能使用from bs4 import BeautifulSoupimport requestsimport pandas as pd# 下面三个是 python 标准库import osimport csvimport codecslst = []url = &#x27;http://datachart.500.com/dlt/history/newinc/history.php?start=07001&amp;end=230202&#x27;r = requests.get(url)r.encoding = &#x27;urf-8&#x27;text = r.textsoup = BeautifulSoup(text, &quot;html.parser&quot;)tbody = soup.find(&#x27;tbody&#x27;, id = &quot;tdata&quot;)tr = tbody.find_all(&#x27;tr&#x27;)td = tr[0].find_all(&#x27;td&#x27;)for page in range(0, 100):    td = tr[page].find_all(&#x27;td&#x27;)    lst.append([td[0].text, td[1].text, td[2].text, td[3].text, td[4].text, td[5].text, td[6].text, td[7].text])    with open(&quot;Lottery_data_2.csv&quot;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as csvfile: # 如果不写 encoding，下面的汉字会显示乱码        writer = csv.writer(csvfile)        writer.writerow([&#x27;期号&#x27;, &#x27;号码 1&#x27;, &#x27;号码 2&#x27;, &#x27;号码 3&#x27;, &#x27;号码 4&#x27;, &#x27;号码 5&#x27;, &#x27;号码 6&#x27;, &#x27;号码 7&#x27;])        writer.writerows(lst)csvfile.close()\n\n运行成功后，会在该目录下生成一个 csv 文件，点击查看。\n\n\ncsv 转 Excel 有很多种方法，最直接的可以找在线网站转一下：CSV 转换为 Excel - 在线表格转换工具 \n\n\n参考\npython爬取分析超级大乐透历史开奖数据 - 知乎 (zhihu.com)\n\n","categories":["Python"],"tags":["爬虫","大乐透"]},{"title":"使用 Docker 搭建 Memos","url":"/2023/03/01/031-%E4%BD%BF%E7%94%A8-Docker-%E6%90%AD%E5%BB%BA-Memos/","content":"虚拟机 + 内网穿透准备工作\n虚拟机：Ubuntu 22.04 LTS 系统\nSakuraFrp 工具\n\nDocker 安装默认是一台没有装过 Docker 的机器。如果存在旧版本的 Docker 并且想要卸载，请执行以下命令（非必要）：\nsudo apt remove docker docker-engine docker.io containerd runc\n\n设置存储库更新 apt 包索引，并安装包以允许 apt 通过 HTTPS 使用存储库：\nsudo apt updatesudo apt install ca-certificates curl gnupg lsb-release\n\n添加 Docker 的官方 GPG 密钥：\nsudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n使用以下命令设置存储库：\necho \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\  $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n安装 Docker 引擎更新 apt 包索引。安装最新版本的 Docker Engine、containerd 和 Docker Compose：\nsudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n验证 Docker 运行情况当 Active: active (running) 为 running 时，说明 Docker 运行正常：\nsystemctl status docker.service\n\n\n\n当进行到这一步的时候，说明 Docker 服务已经成功安装。\nMemos 服务部署Memos 的仓库：https://github.com/usememos/memos\n创建存储卷切换到 root 用户，在根目录下创建一个目录用来存储 Memos 数据（也可以创建到用户目录里）：\nxiaoma@xiaoma-vm:~$ sudo -iroot@xiaoma-vm:~# mkdir memos\n\n然后需要将创建的目录挂载到 Docker 的容器里。先查看 memos 的路径，下面启动 Memos 时需要指定此路径：\nroot@xiaoma-vm:~/memos# pwd---/root/memos\n\n运行容器启动 Memos 容器：\nroot@xiaoma-vm:~/memos# docker run -d --name memos -p 5230:5230 -v /root/memos/:/var/opt/memos neosmemo/memos:latest\n\n这条命令的参数意思是：将容器内的 5230 端口映射到宿主机（指虚拟机）的 5230 端口上，同时将容器内 /var/opt/memos 路径下的内容挂载到宿主机（指虚拟机）的 /root/memos 路径下，路径映射的好处是防止容器被误删导致数据丢失。\n查看容器运行状态：\nroot@xiaoma-vm:~/memos# docker ps -a\n\n\n看到容器状态为 Up（红框）时，说明已成功部署好 Memos 服务。在浏览器中访问 127.0.0.1:5230 或 localhost:5230 就可以打开 Memos 的初始界面了。\n\n\n体验 Memos输入用户名和密码，创建管理员账号。进入后可以体验完整服务。可在设置中改为中文。\n\n\n\n注：Memos 的数据存储在本地 /root/memos 路径下名为  memos_prod.db 的文件（包括用户名密码等），每次升级前请做好备份。\n\n内网穿透由于目前我们只能通过内网（127.0.0.1:5230、localhost:5230 或虚拟机 IP：192.168.43.190:5230）访问该服务，如果我们没有公网 IP 又该如何实现可以 Memos 的公网访问呢？这就引出了一个技术——内网穿透。什么是内网穿透？简单的说，内网穿透就是使用一台具有公网 IP 地址的电脑（服务器）作为“中间人”来与没有公网 IP 的设备建立连接，实现数据连通。此处选择别人提供的内网穿透服务。\n本方案使用 Windows 平台。\n注册 SakuraFrp 账号注册入口：https://openid.13a.com/register\n\n\n用户中心点击 Sakura Frp 跳转链接。\n\n\n实名认证根据提示进行操作。支付宝扫码支付 1 元钱，然后人脸识别验证。免费用户可创建两条隧道，创建隧道需要下载客户端。\n\n\nSakura Frp 启动器\n下载位置如图所示：\n\n\n\n\n安装成功后运行，需要访问密钥登录。在官网首页点击【查看访问密钥】复制。\n\n\n\n\n点击客户端 + 创建隧道。\n\n\n\n\n本地 IP 填写虚拟机的 IP 192.168.43.190。\n\n端口填 5230。\n\n隧道名称随便写三个字母就可以。\n\n备注（可空）。\n\n隧道类型为 TCP。远程端口默认 0。\n\n选择穿透节点时，先延迟测试，选择一条延迟低的。\n\n国内节点需要开启 HTTPS（如下图）。国外节点不需要但访问慢。\n\n\n\n\n\n\n\n\n打开隧道开关，查看日志，找到公网 IP。\n\n\n\n\n\n\n在浏览器中输入公网地址或 IP（红框内容），可以成功访问到内网的页面。\n\n\n\n服务器准备工作\n一台轻量服务器。\nXShell 工具（其他能够远程 SSH 的工具也可以）。\n\n购置服务器登录阿里云，选择购买轻量应用服务器。地址：轻量应用服务器_web服务器_个人建站_弹性计算-阿里云 (aliyun.com)\n\n\n\n实例类型：服务器示例\n地区和可用区：亚太 → 新加坡（香港 24 元&#x2F;月的已售罄）\n镜像：系统镜像 → Ubuntu 20.04\n套餐配置：24 元&#x2F;月\n数据盘：0GB\n购买时长&#x2F;数量：按需\n\n配置服务器进入所购买的服务器界面：\n\n左菜单栏中选择 远程连接。采用第 2 种方法，设置密钥，使用 XShell 连接。（XShell 用法见：Xshell 连接 VM 虚拟机）。\n左菜单栏中选择 防火墙，添加规则，打开 5230 端口。\n\n\n\n在 XShell 中对服务器进行配置，与上述在虚拟机 Ubuntu 22.04 LTS 系统中的操作一致。最后在浏览器中输入 IP:5230 就可以访问 Memos 了。\n# 查看服务器 IPcurl ip.sb\n\n备份与迁移正如前面所说：\n\n注：Memos 的数据存储在本地 /root/memos 路径下名为  memos_prod.db 的文件（包括用户名密码等），每次升级前请做好备份。\n\nsudo -i            //切到管理员命令（如果已经是 # 则不需要切）docker ps -a       //查看 docker 运行情况docker stop memos  //停止 memos 服务（容器）docker rm -f memos //删除 memos 容器cp -r ~/memos ~/memosarchive //备份数据，切记rm -rf ~/memos/memos_prod.db  //删除数据tar -czvf memosarchive.tar.gz memosarchive //打包scp -p 22 -r memosarchive.tar.gz root@192.248.190.156:/root //迁移到新地址tar -zxvf memosarchive.tar.gz //解包mv memosarchive memos  //把 memosarchive 重命名为 memos//切到根目录下，开启 memos 服务（容器）docker run -d --name memos -p 5230:5230 -v /root/memos/:/var/opt/memos neosmemo/memos:latestdocker ps -a //查看 docker 运行情况\n\n参考\nMemos 一个开源且免费的自托管知识库 - 少数派 (sspai.com)\n分享我日常使用的两种内网穿透方案 - 少数派 (sspai.com)\n【好玩儿的Docker项目】10分钟搭建一个碎片化知识卡片管理工具——Memos (laoda.de)\n【有用的小知识】Docker容器如何更新？如何迁移应用？如何卸载？ (laoda.de)\n\n","categories":["工具"],"tags":["Docker","Memos","服务器","内网穿透"]},{"title":"使用向日葵实现全平台联动","url":"/2023/03/05/032-%E4%BD%BF%E7%94%A8%E5%90%91%E6%97%A5%E8%91%B5%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B9%B3%E5%8F%B0%E8%81%94%E5%8A%A8/","content":"硬件\n一台 Windows 11 笔记本电脑：华硕幻 16\n一台 Ubuntu 22.04 LTS 笔记本电脑：华硕 K501LB\n一部 iPhone 13：iOS 16.3.1\n一台 iPad Air 3：iPadOS 16.3.1\n\n软件\n向日葵官网\nWindows 平台：SunloginClient_13.1.0.48900_x64.exe\nLinux 平台：SunloginClient_11.0.1.44968_amd64.deb（注：Ubuntu 需切换到 X11 桌面系统，不能使用 Wayland 桌面系统。右上角点 注销，在登录界面点右下角 齿轮。必须是注销才行，挂起不行）\niPhone &#x2F; iPad 平台：向日葵远程控制-桌面协助软件（注：控制端软件）\n\n\n\n使用方法注册账号，登录。在每个设备上都登录，设备列表中只会显示两台笔记本设备。这是因为 iPhone &#x2F; iPad 上是控制端软件，笔记本电脑上是控制端 &#x2F; 被控制端软件。其关系如下图所示。\n\n\n\niPhone &#x2F; iPad 可远程控制 Windows &#x2F; Linux（显示桌面），可向 Windows &#x2F; Linux 上传和下载文件。\nWindows 与 Linux 可相互控制（显示桌面），相互上传下载文件。\n更多功能有待探索……\n\n意义实现了全平台联动真的让人很开心！！！\n","categories":["工具"],"tags":["向日葵","硬件"]},{"title":"使用腾讯云 DNSPod 解析域名","url":"/2023/03/06/033-%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF-DNSPod-%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D/","content":"本来想把本网站从 Github Pages 迁移到自己买的云服务器上，但迁移失败并导致原来的解析也无法使用，所以重新在腾讯云上解析，阿里云应该也是同理。\n准备工作\n腾讯云 DNSPod：管理控制台 - DNSPod\nNamesilo：Cheap Domain Names &amp; Web Hosting Starting at $0.99! | NameSilo\n\n解析步骤\n打开 DNSPod，登录。左菜单栏找到 我的域名。\n点击 添加域名，输入域名，根据提示操作。\n提示要求换成腾讯云自家的解析服务器。打开 namesilo，登录。\n点击 My account →domain manager。\n选中域名那一栏，点击 Change NameServers。将其改为腾讯云提供的两个服务器。\n\n\n\n\n如果之前有解析记录，点击蓝色球，进去后全部删掉即可。\n\n回到 DNSPod，对域名添加记录，只需要两条。\n主机记录：@（默认）|www记录类型：A（IPV4）|CNAME线路类型：默认 | 默认记录值：185.199.109.153 | username.github.io\n\nIPV4 可选四条，其实填一个就行。选了 CNAME 后，一定要在 public 文件夹下创建一个 CNAME 文件，里面只需要写一行自己的域名。\nstorybeginswhen.icu\n\n设置好后等待即可。解析验证需要时间。我设置好后，出去吃了个晚饭，回来就可以了。\n\n\n","categories":["工具"],"tags":["域名","DNS 解析"]},{"title":"快速入门 HTML 语言","url":"/2023/03/08/034-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-HTML-%E8%AF%AD%E8%A8%80/","content":"一个网页包括 HTML、CSS、JavaScript。\n\nHTML：定义网页的结构和信息\nCSS：定义网页的样式\nJavaScript：定义用户和网页的交互逻辑\n\nHTML 是什么&lt;!DOCTYPE HTML&gt; //告知浏览器这是一个 HTML &lt;html&gt;    xxx //往里面填内容&lt;/html&gt;\n\nHTML 常用标签标题&lt;h1&gt;这是一个一级标题&lt;/h1&gt;&lt;h2&gt;这是一个二级标题&lt;/h2&gt;&lt;h3&gt;这是一个三级标题&lt;/h3&gt;&lt;h4&gt;这是一个四级标题&lt;/h4&gt;&lt;h5&gt;这是一个五级标题&lt;/h5&gt;&lt;h6&gt;这是一个六级标题&lt;/h6&gt;\n\n文本段落&lt;p&gt;给岁月以文明&lt;/p&gt;&lt;p&gt;而不是给文明以岁月&lt;/p&gt;---换行的方式：1.给多个&lt;p&gt;xxx&lt;/p&gt;标签2.在换行处加入&lt;br&gt;标签。---文本操作：&lt;b&gt;加粗&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;\n\n图片、链接&lt;img src=&quot;xxx&quot; width=&quot;500px&quot; height=&quot;500px&quot;&gt;&lt;a href=&quot;xxx&quot; target=&quot;_self&quot;&gt;xxx&lt;/a&gt;//前面 xxx 是地址，后面 xxx 是你想要它显示的名字//属性（可填可不填）target=&quot;_self&quot;：表示在当前页面打开;target=&quot;_blank&quot;：表示在新页面打开\n\n容器&lt;div&gt;    &lt;a href=&quot;xxx&quot;&gt;div元素下的链接1&lt;/a&gt;    &lt;a href=&quot;xxx&quot;&gt;div元素下的链接2&lt;/a&gt;&lt;/div&gt;---&lt;span&gt;    &lt;a href=&quot;xxx&quot;&gt;span元素下的链接1&lt;/a&gt;    &lt;a href=&quot;xxx&quot;&gt;span元素下的链接2&lt;/a&gt;&lt;/span&gt;---行内&lt;a href=&quot;xxx&quot;&gt;我是&lt;div style=&quot;background-color:red;&quot;&gt;一个&lt;/div&gt;红色&lt;div style=&quot;background-color:red;&quot;&gt;链接&lt;/div&gt;&lt;/a&gt;&lt;a href=&quot;xxx&quot;&gt;我是&lt;span style=&quot;background-color:red;&quot;&gt;一个&lt;/span&gt;红色&lt;span style=&quot;background-color:red;&quot;&gt;链接&lt;/span&gt;&lt;/a&gt;\n\n把标签放到容器里，这样做的一个好处是，如果想要全部应用 CSS 样式，可以直接在容器上添加。\n两者的区别是 div 是块级元素，独占一行，span 是内联元素，一行可以有多个元素。\n有序 &#x2F; 无序列表&lt;ol&gt;    &lt;li&gt;语文&lt;/li&gt;    &lt;li&gt;数学&lt;/li&gt;    &lt;li&gt;英语&lt;/li&gt;&lt;/ol&gt;---&lt;ul&gt;    &lt;li&gt;语文&lt;/li&gt;    &lt;li&gt;数学&lt;/li&gt;    &lt;li&gt;英语&lt;/li&gt;&lt;/ul&gt;---//ol=ordered list//ul=unordered list//li=list\n\n表格&lt;table&gt; //表格    &lt;thead&gt; //表头        &lt;tr&gt; //定义表格行            &lt;td&gt;表头1&lt;/td&gt; //定义单元格数据            &lt;td&gt;表头2&lt;/td&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt; //表主体        &lt;tr&gt;            &lt;td&gt;111&lt;/td&gt;            &lt;td&gt;333&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;222&lt;/td&gt;            &lt;td&gt;444&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;---//属性：可以给表格加边框&lt;table border=&quot;2&quot;&gt;    xxx&lt;/table&gt;\n\nclass 属性帮助分组。如\nclass=&quot;content&quot;class=&quot;review&quot;\n\n","categories":["工具"],"tags":["HTML","扫盲"]},{"title":"Python 爬虫入门","url":"/2023/03/09/035-Python-%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/","content":"爬虫扫盲练习。\n实战练习：豆瓣电影 TOP250源码：\nimport requestsfrom bs4 import BeautifulSoupheader = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Mobile Safari/537.36 Edg/110.0.1587.63&quot;&#125;for start_num in range(0, 250, 25):    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=header)    html = response.text    soup = BeautifulSoup(html, &quot;html.parser&quot;) #html.parser 是一个解析器    all_titles = soup.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)    for title in all_titles:        title_string = title.string        if &quot;/&quot; not in title_string:            print(title_string)\n\n实现步骤\n安装 Requests 和 BeautifulSoup 库。\npip install Requestspip install BeautifulSoup\n\n导入 Requests 库，并爬取豆瓣电影 TOP250\nimport requestsresponse = requests.get(&quot;https://movie.douban.com/top250&quot;)print(response.status_code) #直接打印 response 或 response.status_code 都可以\n\n运行代码，返回 418，表示豆瓣不想理你。\n\n加入请求头（headers）将代码伪装成浏览器。\n\n浏览器打开豆瓣电影 Top 250 (douban.com)，点击右键→选择【检查】→选择【网络】，在【名称】中找到【top250】，查看【标头】→【请求标头】→【User-Agent】，复制冒号后面的内容。\n\n\n在代码中加入 headers。\n\n\nimport requestsheader = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Mobile Safari/537.36 Edg/110.0.1587.63&quot;&#125;response = requests.get(&quot;https://movie.douban.com/top250&quot;, headers=header)print(response.status_code) #返回值 200，表示正常访问print(response.text) #可以看到打印下来 HTML 代码\n\n可以把 reponse.text 的返回值命名为 html，使用 BeautifulSoup 去解析，返回值命名为 soup，然后调用 soup 的属性 findAll，返回值命名为 all_title。\nimport requestsheader = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Mobile Safari/537.36 Edg/110.0.1587.63&quot;&#125;response = requests.get(&quot;https://movie.douban.com/top250&quot;, headers=header)html = response.textsoup = BeautifulSoup(html, &quot;html.parser&quot;)all_titles = soup.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)for title in all_titles:\tprint(title) ---    #打印结果 &lt;span class=&quot;title&quot;&gt;疯狂动物城&lt;/span&gt;&lt;span class=&quot;title&quot;&gt; / Zootopia&lt;/span&gt;---#如果只想要文字元素，则改为for title in all_titles:\tprint（title.string)---#打印结果疯狂动物城 / Zootopia---#这时候会有原名，分析发现原名前面都有 /，使用 if 语句判断，即可剔除掉for title in all_titles:    title_string = title.string    if &quot;/&quot; not in title_string:        print(title_string)---#打印结果疯狂动物城---\n\n我们注意到，这里只打印了前 25 个结果，如果想要打印 250 个结果，那么就要分析网站地址，发现第二页的网站地址是这样的：\nhttps://movie.douban.com/top250?start=25&amp;filter=\n\n在后面写上 ?start=xx 即可。于是可以写一个 for 循环来完成：\nfor start_num in range(0, 250, 25):    print(start_num)---#打印结果0 25 50 …… 225\n\n将 request.get() 里面的网址字符串格式化。f 表示字符串格式化，它可以将大括号 {} 中的变量值替换为实际的值。在这个网址中，&#123;start_num&#125; 会被替换为实际的数字，从而实现动态生成网址的功能。\n再将前面打印前 25 电影名的代码，写进 for 循环体。\nfor start_num in range(0, 250, 25):    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=header)    html = response.text    soup = BeautifulSoup(html, &quot;html.parser&quot;)    all_titles = soup.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)    for title in all_titles:        title_string = title.string        if &quot;/&quot; not in title_string:            print(title_string)---#打印结果肖申克的救赎霸王别姬阿甘正传泰坦尼克号这个杀手不太冷…… （一直到第 250 个）\n\n完成！\n\n\n拓展练习以上是根据 B 站一位 Up 主的教程，手把手教着写的。现在只是在终端里打印下来了这 250 个名字，如果我想要做个表格，有序号、中文名、原名、年份、评分、时长、简介。于是开始折腾……\n加入了电影原名（第 3 列）import requestsfrom bs4 import BeautifulSoupfrom openpyxl import Workbookheader = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Mobile Safari/537.36 Edg/110.0.1587.63&quot;&#125;wb = Workbook()ws = wb.activews.title = &quot;豆瓣电影TOP250&quot;ws[&quot;A1&quot;] = &quot;序号&quot;ws[&quot;B1&quot;] = &quot;电影名称&quot;ws[&quot;C1&quot;] = &quot;电影原名&quot;ws[&quot;D1&quot;] = &quot;其他名称&quot;row_num = 2for start_num in range(0, 250, 25):    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=header)    html = response.text    soup = BeautifulSoup(html, &quot;html.parser&quot;)    all_titles = soup.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)    all_other_titles = soup.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;other&quot;&#125;)    for i, title in enumerate(all_titles):        title_string = title.string        if &quot;/&quot; not in title_string:            ws.cell(row=row_num, column=1, value=i+1+start_num)            ws.cell(row=row_num, column=2, value=title_string)            last_row_num = row_num            row_num += 1        else:            ws.cell(row=last_row_num, column=3, value=title_string.split(&#x27;/&#x27;)[1].strip())wb.save(&quot;douban_top250_5.xlsx&quot;)\n\n\n\n又加入了别名（第 4 列）import requestsimport refrom bs4 import BeautifulSoupfrom openpyxl import Workbookheader = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Mobile Safari/537.36 Edg/110.0.1587.63&quot;&#125;wb = Workbook()ws = wb.activews.title = &quot;豆瓣电影TOP250&quot;ws[&quot;A1&quot;] = &quot;序号&quot;ws[&quot;B1&quot;] = &quot;电影名称&quot;ws[&quot;C1&quot;] = &quot;电影原名&quot;ws[&quot;D1&quot;] = &quot;其他名称&quot;row_num = 2last_row_num = 2for start_num in range(0, 250, 25):    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=header)    html = response.text    soup = BeautifulSoup(html, &quot;html.parser&quot;)    all_elements = soup.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: [&quot;title&quot;, &quot;other&quot;, &quot;&quot;]&#125;)    for i, element in enumerate(all_elements):        element_string = element.string        ws.cell(row=row_num, column=1, value=i+1+start_num)        if element.has_attr(&quot;class&quot;) and &quot;other&quot; in element[&quot;class&quot;]:            element_string = re.sub(r&quot;\\s*/\\s*&quot;, &quot;&quot;, element_string, count=1)            element_string = re.sub(r&quot;\\s*/\\s*&quot;, &quot;/&quot;, element_string, count=1)            ws.cell(row = last_row_num, column = 4, value=element_string)        else:            if &quot;/&quot; not in element_string:                ws.cell(row=row_num, column=2, value=element_string)                last_row_num = row_num                row_num += 1            else:                ws.cell(row=last_row_num, column=3, value=element_string.split(&#x27;/&#x27;)[1].strip())wb.save(&quot;douban_top250_18.xlsx&quot;)\n\n又加入了年份、国家（第 5、6 列）import requestsimport refrom bs4 import BeautifulSoupfrom openpyxl import Workbookheader = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Mobile Safari/537.36 Edg/110.0.1587.63&quot;&#125;wb = Workbook()ws = wb.activews.title = &quot;豆瓣电影TOP250&quot;ws[&quot;A1&quot;] = &quot;序号&quot;ws[&quot;B1&quot;] = &quot;电影名称&quot;ws[&quot;C1&quot;] = &quot;电影原名&quot;ws[&quot;D1&quot;] = &quot;其他名称&quot;ws[&quot;E1&quot;] = &quot;年份&quot;ws[&quot;F1&quot;] = &quot;国家&quot;ws[&quot;G1&quot;] = &quot;评分&quot;ws[&quot;H1&quot;] = &quot;简介&quot;row_num = 2last_row_num = 2for start_num in range(0, 250, 25):    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=header)    html = response.text    soup = BeautifulSoup(html, &quot;html.parser&quot;)    all_elements = soup.select(&quot;p, span.title, span.other&quot;)    for element in all_elements:        element_string = element.string        if element.name == &quot;p&quot;:            text = element.text.strip()            match = re.search(r&quot;\\d&#123;4&#125;\\s*/\\s*\\S+&quot;, text)            if match:                year_country = match.group(0)                year, country = map(str.strip, year_country.split(&quot;/&quot;))                ws.cell(row=last_row_num, column=5, value=year)                ws.cell(row=last_row_num, column=6, value=country)        elif element.name == &quot;span&quot; and &quot;title&quot; in element[&quot;class&quot;]:            if &quot;/&quot; not in element_string:                ws.cell(row=row_num, column=2, value=element_string)                last_row_num = row_num                row_num += 1            else:                ws.cell(row=last_row_num, column=3, value=element_string.split(&#x27;/&#x27;)[1].strip())        elif element.name == &quot;span&quot; and &quot;other&quot; in element[&quot;class&quot;]:            element_string = element.text.strip()            element_string = re.sub(r&quot;\\s*/\\s*&quot;, &quot;&quot;, element_string, count=1)            element_string = re.sub(r&quot;\\s+&quot;, &quot;&quot;, element_string)            ws.cell(row = last_row_num, column = 4, value=element_string)wb.save(&quot;douban_top250_20.xlsx&quot;)\n\n又加入了简介（第 7 列）import requestsimport re #用于正则匹配from bs4 import BeautifulSoupfrom openpyxl import Workbook #用于生成 Excel 表格#加入请求头，伪装成浏览器header = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Mobile Safari/537.36 Edg/110.0.1587.63&quot;&#125;#表头wb = Workbook()ws = wb.activews.title = &quot;豆瓣电影TOP250&quot; #这张表格的名字，在左下角显示ws[&quot;A1&quot;] = &quot;序号&quot;ws[&quot;B1&quot;] = &quot;电影名称&quot;ws[&quot;C1&quot;] = &quot;电影原名&quot;ws[&quot;D1&quot;] = &quot;其他名称&quot;ws[&quot;E1&quot;] = &quot;年份&quot;ws[&quot;F1&quot;] = &quot;国家&quot;ws[&quot;G1&quot;] = &quot;评分&quot;ws[&quot;H1&quot;] = &quot;简介&quot;row_num = 2 #从第二行开始往里面填充内容last_row_num = 2 #用于在上一行填充列元素#第一个循环体，按页索引，写在 ?start= 后面for start_num in range(0, 250, 25):    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=header) #爬取内容，后面要加上伪装    html = response.text #得到 HTML 网页，属性为 text    soup = BeautifulSoup(html, &quot;html.parser&quot;) #通过解析器解析，可以找到各种属性    all_elements = soup.select(&quot;p, span.title, span.other, span.rating_num, span.inq&quot;) #选择不同的属性，span.xxx 表示在 span 标签里面的 xxx 类（class）    #第二个循环体，爬取当前页的所有（↑上面标签中的）元素，    for element in all_elements:        if element.name == &quot;p&quot;: #P 标签            text = element.text.strip() #输出文本，.strip() 是为了去除字符串开头和结尾的空白字符。空白字符包括空格、制表符和换行符等。            match = re.search(r&quot;\\d&#123;4&#125;\\s*/\\s*\\S+&quot;, text)            if match:                year_country = match.group(0)                year, country = map(str.strip, year_country.split(&quot;/&quot;))                ws.cell(row=last_row_num, column=5, value=year)                ws.cell(row=last_row_num, column=6, value=country)        elif element.name == &quot;span&quot; and &quot;title&quot; in element[&quot;class&quot;]:            title_string = element.string            if &quot;/&quot; not in title_string:                ws.cell(row=row_num, column=2, value=title_string)                last_row_num = row_num                row_num += 1            else:                ws.cell(row=last_row_num, column=3, value=title_string.split(&#x27;/&#x27;)[1].strip())        elif element.name == &quot;span&quot; and &quot;other&quot; in element[&quot;class&quot;]:            other_string = element.text.strip()            other_string = re.sub(r&quot;\\s*/\\s*&quot;, &quot;&quot;, other_string, count=1)            other_string = re.sub(r&quot;\\s+&quot;, &quot;&quot;, other_string)            ws.cell(row=last_row_num, column=4, value=other_string)        elif element.name == &quot;span&quot; and &quot;rating_num&quot; in element[&quot;class&quot;]:            rating_value = float(element.string.strip())            ws.cell(row=last_row_num, column=7, value=rating_value)        elif element.name == &quot;span&quot; and &quot;inq&quot; in element[&quot;class&quot;]:            inq_string= element.string.strip()            ws.cell(row=last_row_num, column=8, value=inq_string)wb.save(&quot;douban_top250_26.xlsx&quot;)\n\n但是！它只显示一个国家，而有的作品制片国家不止一个，有两个三个四个的情况，经过一天的努力，通过任务分解法（先去掉一部分，再去掉一部分，再完成替换），于是有了下面的最终完成版！！！\n拓展的最终版（注释完全版）import requestsimport re #用于正则匹配from bs4 import BeautifulSoupfrom openpyxl import Workbook #用于生成 Excel 表格#加入请求头，伪装成浏览器header = &#123;    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Mobile Safari/537.36 Edg/110.0.1587.63&quot;&#125;#表头wb = Workbook()ws = wb.activews.title = &quot;豆瓣电影TOP250&quot; #这张表格的名字，在左下角显示ws[&quot;A1&quot;] = &quot;序号&quot; #这一项会比较混乱，不填充，在表格中下拉填充，刚好 250 条ws[&quot;B1&quot;] = &quot;电影名称&quot; #titlews[&quot;C1&quot;] = &quot;电影原名&quot; #title→判断带&quot;/&quot;,输出ws[&quot;D1&quot;] = &quot;其他名称&quot; #otherws[&quot;E1&quot;] = &quot;年份&quot; #正则匹配 \\d&#123;4&#125;ws[&quot;F1&quot;] = &quot;国家&quot; #正则匹配，通过两次去除，一次替换完成ws[&quot;G1&quot;] = &quot;评分&quot; #rating_numws[&quot;H1&quot;] = &quot;简介&quot; #quote→inqrow_num = 2 #从第二行开始往里面填充内容last_row_num = 2 #用于在上一行填充列元素#第一个循环体，按页索引，写在 ?start= 后面，第一页是 0，第二页是 25……依次类推for start_num in range(0, 250, 25):    response = requests.get(f&quot;https://movie.douban.com/top250?start=&#123;start_num&#125;&quot;, headers=header) #爬取内容，后面要加上伪装    html = response.text #得到 HTML 网页，属性为 text    soup = BeautifulSoup(html, &quot;html.parser&quot;) #通过解析器解析，可以找到各种属性    all_elements = soup.select(&quot;p, span.title, span.other, span.rating_num, span.inq&quot;) #选择不同的属性，span.xxx 表示在 span 标签里面的 xxx 类（class）    #第二个循环体，爬取当前页的所有（↑上面标签中的）元素，    for element in all_elements:        if element.name == &quot;p&quot;: #判断是否为 P 标签            text = element.text.strip() #输出文本，.strip() 是为了去除字符串开头和结尾的空白字符。空白字符包括空格、制表符和换行符等。                        #输出年份            pattern = r&#x27;\\d&#123;4&#125;&#x27; #正则匹配            match = re.search(pattern, text)            if match: #还是要加依据判断，如果有错误会报一下                year = match.group(0)                ws.cell(row=last_row_num, column=5, value=year) #由于是先输出 title，这里 last_row_num 都表示和 title 在同一行                        #输出国家            if &#x27;\\n&#x27; in text: #一开始用了&quot;导演&quot;这个词，匹配到《哈利波特与阿兹卡班的囚徒》时，它的 quote（也是 p 标签）是“不一样的导演，不一样的哈利·波特。”，导致运行下面的代码时匹配不到 \\d&#123;4&#125; 等内容，出现报错。通过一步步断点调试才发现这个问题。最后选了一个 \\n，表示 &lt;br&gt;，这个在 quote 里面是没有的，因此顺利运行。                if title_string != &quot;大闹天宫&quot; and title_string != &quot;茶馆&quot;: #《大闹天宫》和《茶馆》的年份与别的条目都不一样，出现报错。直接 if 语句判断，出现他俩就不输出国家了。                    pattern = r&#x27;\\d&#123;4&#125;\\s*/\\s*(.*)&#x27; #正则匹配，表示只匹配 \\d&#123;4&#125;（指年份）及之后的内容                    match = re.search(pattern, text)                     country = match.group(1).split(&#x27;/&#x27;)[0].strip().replace(&#x27; &#x27;, &#x27;/&#x27;) #三行代码简化合并而来：首先是去除 \\d&#123;4&#125; 之前的内容，但是通过 group(1)，直接匹配到了 / 后面的内容，这是因为（0）表示整个内容，（1）表示第一个括号里的内容。第二步去除国家 / 后面的内容。第三步把国家之间的空格用 / 代替。                    ws.cell(row=last_row_num, column=6, value=country) #同样插入与 title 同一行        elif element.name == &quot;span&quot; and &quot;title&quot; in element[&quot;class&quot;]:            title_string = element.string            if &quot;/&quot; not in title_string:                ws.cell(row=row_num, column=2, value=title_string)                last_row_num = row_num                row_num += 1 #注意：全部代码只有这里是加了 1，这是因为它先匹配 title，匹配完后，行数加 1，但是其他的元素都还是用的这一行，即 last_row_num            else:                ws.cell(row=last_row_num, column=3, value=title_string.split(&#x27;/&#x27;)[1].strip())        elif element.name == &quot;span&quot; and &quot;other&quot; in element[&quot;class&quot;]: #别名，其他名称            other_string = element.text.strip() #去掉了字符串两端的空格和换行符，留下了&quot;/ 月黑高飞(港)  /  刺激1995(台)&quot;            other_string = re.sub(r&quot;\\s*/\\s*&quot;, &quot;&quot;, other_string, count=1) #这里的正则匹配是用空字符代替第一个 / 及其左右空格，留下了第二个 /：&quot;月黑高飞(港)  /  刺激1995(台)&quot;            other_string = re.sub(r&quot;\\s+&quot;, &quot;&quot;, other_string) #这里的正则匹配是用空字符代替所有空格，刚好使 / 留下：&quot;月黑高飞(港)/刺激1995(台)&quot;            ws.cell(row=last_row_num, column=4, value=other_string)        elif element.name == &quot;span&quot; and &quot;rating_num&quot; in element[&quot;class&quot;]:            rating_value = float(element.string.strip()) #这里用不用 float 都是可以的，无所谓            ws.cell(row=last_row_num, column=7, value=rating_value)        elif element.name == &quot;span&quot; and &quot;inq&quot; in element[&quot;class&quot;]:            inq_string= element.string.strip() #去除字符串两端的空格和换行符            ws.cell(row=last_row_num, column=8, value=inq_string)wb.save(&quot;douban_top250_1.xlsx&quot;)\n\n算下来花了有两天的功夫，其中昨天（2023&#x2F;03&#x2F;09）上午跟着 Up 主学，下午开始写拓展，到了晚上的时候完成。结果快下班的时候发现了国家和地区那里出了问题，一开始想一行代码就完成正则匹配，奈何一直无解，困扰了今天（2023&#x2F;03&#x2F;10）一整个上午。下午去车管所回来四点，更新了思路，一步一步实现。又遇到了大闹天宫、茶馆年份和别的条目不太一样的问题，让师弟看了一下，加了 if 判断，搞定！然后又遇到了哈利波特与阿兹卡班的囚徒那里报错，原来是它的 quote 里面有导演这个词，引用就进入了国家的条目，匹配不到，就报错，换了 \\n 解决了问题！断点调试流程如下图。（刚刚想起来：年份那里有个 if 判断，而我在国家那里没有加，所以才报错！换成下面的代码就不报错了，即使用导演也没有关系。哎呀，被自己蠢到。）\n\n\n#输出国家if &#x27;导演&#x27; in text:     if title_string != &quot;大闹天宫&quot; and title_string != &quot;茶馆&quot;:         pattern = r&#x27;\\d&#123;4&#125;\\s*/\\s*(.*)&#x27;         match = re.search(pattern, text)         if match:            country = match.group(1).split(&#x27;/&#x27;)[0].strip().replace(&#x27; &#x27;, &#x27;/&#x27;)            ws.cell(row=last_row_num, column=6, value=country)\n\n\n\n完结撒花✿✿ヽ(°▽°)ノ✿✿\n参考\nhttps://b23.tv/svWjQBz\n\n","categories":["Python"],"tags":["爬虫","豆瓣"]},{"title":"ADB 与 Anaconda 使用","url":"/2023/03/12/036-ADB-%E4%B8%8E-Anaconda-%E4%BD%BF%E7%94%A8/","content":"概念扫盲ADBADB（Android Debug Bridge）是 Android 开发工具包（SDK）中的一个工具，它提供了与 Android 设备通信的桥梁，可以在计算机和 Android 设备之间建立连接，并以命令行的方式执行一些操作，例如安装应用程序、发送文本消息、复制文件等。在使用 adb 前，需要确保已经将 Android SDK 安装在计算机上。\nAnocondaAnaconda 是一个 Python 的发行版，它包含了 Python 解释器、一堆常用的 Python 库以及一个可视化的集成开发环境（IDE）。Anaconda 中包含的 Python 库包括了科学计算、数据分析、机器学习等领域常用的各种库，如NumPy、Pandas、Matplotlib、SciPy、Scikit-learn 等等，这些库的版本和依赖都已经被管理好了，用户可以非常方便地进行安装、更新、切换等操作。除此之外，Anaconda 还提供了 conda 这一包管理工具，通过它，用户可以非常方便地管理安装在自己电脑上的 Python 包，这也是 Anaconda 相较于 Python 官方发行版的一大优势。总之，Anaconda 是一个非常强大、易于使用的 Python 发行版，适用于科学计算、数据分析、机器学习等领域的从业者和爱好者。\n驱动（软件&#x2F;环境）安装配置本次测试使用平台：Windows 11（22H2） + Redmi Note 8（MIUI 12.0.3）。\nADB\n下载 ADB 驱动，下面两个地址的 Windows 包都是一样的，第二个日期更新一些。我使用了第二个。\n\nSDK 平台工具版本说明  | Android 开发者  | Android Developers\nUniversal ADB Drivers (clockworkmod.com)\n\n\n安装 Python。由于之前已经安装过，所以这一步略过。\n\nDownload Python | Python.org\n\n\n配置环境变量。将 adb 的安装路径保存到 PATH 变量中，确保 adb 命令可以被识别到。\n\nWin + s 搜索【控制面板】→【系统】→【高级系统设置】→【环境变量】\n在【环境变量】窗口找到【系统变量】下的【path】变量→【编辑】→【新建】\n输入 adb 的安装路径：在资源管理器的地址栏复制该路径，粘贴到【编辑环境变量】窗口。\n依次点【确定】，关闭所有窗口。\nwin + R  搜索 cmd，打开命令行窗口，输入 adb，返回 Android Debug Bridge version 1.0.31 …… 表示已成功安装 adb。输入 adb devices，返回 List of devices attached，下面显示设备序列号号，表示已连接，否则为空。\n\n\n\nAnaconda\n考虑到生产环境的规范性，实验与项目之间不受干扰，请尽量使用新的虚拟环境来完成实验。\n\nWindows 开辟新的虚拟环境操作步骤：\n\n下载 Anaconda：Anaconda | The World’s Most Popular Data Science Platform\n\n安装 Anaconda：下图为勾选配置的选项，第一项意思是不推荐勾选，将 Anaconda 添加到 PATH 环境变量中会让计算机上的其他程序（如 Python Tools for Visual Studio、PyCharm、Wing IDE、PyDev 和 MSI 二进制软件包）自动将 Anaconda 检测为系统上的主要 Python 3.9 版本，可能导致一些问题，需要卸载重装 Anaconda 才能解决。第二项的意思是允许其他程序（同上）自动检测 Anaconda 作为系统上的主要 Python 3.9。（安装时我没有细读，全部勾选了）\n\n\n创建虚拟环境\n\n第一种方式：安装好后，在应用程序中找到 Anaconda 打开，找到【Environment】进行创建。\n\n第二种方式：使用命令行创建虚拟环境，需以管理员身份运行 cmd（win + s 搜索【命令提示符或 cmd】，右键【以管理员身份运行】（今天测试，不用管理员身份也可以）\n\n\nconda info --envs #查看所有虚拟环境conda create -n wechat_env python=3 #创建名为 wechat_env 的虚拟环境，且使用 Python3activate wechat_env #Windows 下激活虚拟环境conda install package_name #安装所需要的包，如 matplotlib 等#进入虚拟环境会有前置符号表示如下(wechat_env) 路径名conda deactivate #退出虚拟环境，之前的 deactivate wechat_env 已经不适用了conda remove -n wechat_env --all #需要先退出，才能删除虚拟环境\n\n完全卸载 Anaconda：【控制面板】→【所有控制面板项】→【程序和功能】→【Anaconda】→右键【卸载】\n\n\nAndroid 手机配置Redmi note 8（MIUI 12.0.3）操作步骤：\n\n【设置】→【我的设备】→【全部参数】，找到【MIUI 版本】，连续点击多次，进入【开发者模式】\n【设置】→【更多设置】→【开发者选项】，打开【USB 调试】、【USB 调试（安全设置）】、USB 设置为 MTP 模式。\n使用数据线连接电脑与手机。打开 cmd，执行 adb devices，返回设备 ID 表示成功连接。\n\nADB 测试\n连接手机与电脑，选择 MTP 模式。（MIUI 自动弹出）\n\n运行 cmd。输入 adb devices。返回设备 ID，测试成功。\n\n在 cmd 中分别输入以下命令：\nadb shell screencap -p /sdcard/test.png #截图adb pull /sdcard/test.png . #将截图上传到电脑（目录为当前命令行显示的目录）---#返回结果显示1120 KB/s (259599 bytes in 0.226s)\n\n在电脑当前所在目录下看到名为 test.png 的截图，测试成功。\n\n打开抖音，输入以下命令：\nadb shell input swipe 540 1265 540 965 200#这个命令在Android设备的屏幕上执行了一个从坐标（540,1265）到坐标（540,965）的滑动手势，耗时200毫秒。\n\n抖音切换视频，测试成功。\n\n监听设备输入事件，并输出到命令行窗口：\nadb shell #进入设备的 shell 环境getevent -l #开始监听。触摸设备屏幕，命令行窗口会输出一些信息，包括触摸事件的坐标（16 进制）---#输出结果dev/input/event2: EV_ABS       ABS_MT_TRACKING_ID   00008ea1/dev/input/event2: EV_ABS       ABS_MT_PRESSURE      0000002f/dev/input/event2: EV_ABS       ABS_MT_TOUCH_MAJOR   00000003/dev/input/event2: EV_ABS       ABS_MT_POSITION_X    000003ec/dev/input/event2: EV_ABS       ABS_MT_POSITION_Y    00000533/dev/input/event2: EV_KEY       BTN_TOUCH            DOWN/dev/input/event2: EV_SYN       SYN_REPORT           00000000/dev/input/event2: EV_ABS       ABS_MT_PRESSURE      0000002e/dev/input/event2: EV_SYN       SYN_REPORT           00000000/dev/input/event2: EV_ABS       ABS_MT_TRACKING_ID   ffffffff/dev/input/event2: EV_KEY       BTN_TOUCH            UP/dev/input/event2: EV_SYN       SYN_REPORT           00000000\n\n其他命令\nadb shell wm size #宽度和高度adb shell wm density #手机屏幕密度adb shell input tap x y #根据（x, y）坐标点按屏幕\n\n经过测试，在 Redmi Note 8 1080x2340 的屏幕上，抖音 APP 点赞按钮的坐标是（1004, 1331），关注按钮的坐标是（933, 1100）。\n参考\nAndroid 和 iOS 操作步骤 · wangshub&#x2F;wechat_jump_game Wiki (github.com)\n小米（Mi） 红米（Redmi）Note 8小米（Mi） 红米（Redmi）Note 8 如何打开“开发者选项”和“USB调试”图文教程刷机解锁 (onfix.cn)\n\n","categories":["工具"],"tags":["ADB","Anaconda"]},{"title":"使用 OpenCV 自动点赞抖音小猫","url":"/2023/03/15/037-%E4%BD%BF%E7%94%A8-OpenCV-%E8%87%AA%E5%8A%A8%E7%82%B9%E8%B5%9E%E6%8A%96%E9%9F%B3%E5%B0%8F%E7%8C%AB/","content":"看到有人分享 Python 抖音机器人，论如何在抖音上找到漂亮小姐姐？ (github.com)，Git Clone 下来，发现由于腾讯云人脸识别的接口无法连接，导致截图完停止，不继续往下运行了，没啃下来官方提供的教程（Flag：以后会啃下来的）。于是自己使用 OpenCV 重新写了一个 Python 脚本，不过是识别“猫猫”的哦。\n特性\n 自动翻页\n 猫脸识别\n 自动点赞\n\n原理\n打开抖音 APP，进入主界面；\n获取手机截图；\n使用 OpenCV 提供的 xml 文件[1]进行检测；\n当检测到是猫猫时，自动点赞；\n滑到下一页。重复上述步骤。\n\n使用教程\nPython 版本 3.9.16（理论上其他的也可以）；\nAnaconda 安装和虚拟环境创建[2]；\nadb 安装[2]；\n下载 OpenCV 提供的 xml 文件[1]。\n\n源码（注释完全版）import subprocess #用于执行 shell 命令import cv2import timeimport shutil #用于复制、移动、删除文件和目录等操作import os #提供与操作系统进行交互的功能# 指定设备序列号device_serial = &quot;xxx&quot; #在 cmd 中运行 adb devices 查看并复制# 定义计数器变量count = 0 #本项目为测试项目，所以只刷 12 次就停止。如果不想，在整个代码中删掉 count 就可以了while True:        # 等待两秒    time.sleep(2)    # 指定时间戳    timestamp = int(time.time())    # 将时间戳转换为本地时间    local_time = time.localtime(timestamp)    # 将时间格式化为字符串    time_str = time.strftime(&quot;%Y-%m-%d-%H-%M-%S&quot;, local_time)    # 生成唯一的文件名    screenshot_filename = f&quot;douyin_screenshot_&#123;time_str&#125;.png&quot;    # 截取屏幕上正在播放的抖音视频的截图，并上传保存到计算机上    screenshot_cmd = f&quot;adb -s &#123;device_serial&#125; shell screencap -p /sdcard/&#123;screenshot_filename&#125;&quot;    subprocess.run(screenshot_cmd, shell=True)    pull_cmd = f&quot;adb -s &#123;device_serial&#125; pull /sdcard/&#123;screenshot_filename&#125; .&quot;    subprocess.run(pull_cmd, shell=True)    # 加载截图并进行图像识别    screenshot = cv2.imread(f&quot;&#123;screenshot_filename&#125;&quot;) #注意写 f，用于将变量值嵌入到字符串中    gray = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)    cat_cascade = cv2.CascadeClassifier(&quot;haarcascade_frontalcatface.xml&quot;)    cats = cat_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30)) #参数解释在下方    if len(cats) &gt; 0:        # 如果识别出小猫，则模拟点击点赞按钮        # 测试使用设备：Redmi Note8，2340x1080，其他手机自行适配参数        like_cmd = f&quot;adb -s &#123;device_serial&#125; shell input tap 1004 1331&quot;        subprocess.run(like_cmd, shell=True)        # 等待 2 秒        time.sleep(1)        # 屏幕上滑（参数解释见下文）        swipe_cmd = f&quot;adb -s &#123;device_serial&#125; shell input swipe 540 1500 540 1000 100&quot;        subprocess.run(swipe_cmd, shell=True)    else:        # 屏幕上滑        swipe_cmd = f&quot;adb -s &#123;device_serial&#125; shell input swipe 540 1500 540 1000 100&quot;        subprocess.run(swipe_cmd, shell=True)    # 指定源文件路径和目标文件夹路径（这是为了把截的图存放到专门的文件夹中，用于检测识别准确度）    source_file = f&quot;&#123;screenshot_filename&#125;&quot;    target_folder = &quot;cved&quot; #文件夹自行创建，在本 python 脚本的文件夹中就可以    # 构建目标文件路径    target_file = os.path.join(target_folder, source_file)    # 移动文件到目标文件夹    shutil.move(source_file, target_file)    # 计数器加 1    count += 1    # 完成 12 次截图，退出循环    if count &gt;= 12:        break\n\n\nsacleFator：这个参数控制图像金字塔的缩放比例。较小的 scaleFactor 值会导致更多的金字塔层级，从而增加检测准确性，但也会增加计算量，使检测速度变慢。较大的 scaleFactor 值则会减少金字塔层级和计算量，提高检测速度，但可能降低检测准确性。通常情况下，scaleFactor 的值在 1.01 到 1.5 之间。\nminNeighbors：这个参数控制检测到的物体的矩形框之间应该有多少个相邻矩形框。较大的 minNeighbors 值可以减少误报率（错误检测），但可能导致一些真实物体被错过（降低检测准确性）。较小的 minNeighbors 值可能会增加误报率，但也可能提高检测准确性。这个参数的最佳值取决于具体的应用场景和数据集。通常情况下，minNeighbors 的值在 3 到 10 之间。\nminSize：这个参数用于设置检测到的物体的最小尺寸（宽度和高度）。较大的 minSize 值可以减少误报率，但可能导致一些较小的真实物体被错过。较小的 minSize 值可能会增加误报率，但能检测到更小的物体。设置适当的 minSize 取决于你希望检测到的物体的实际尺寸和应用场景。例如，如果你只关心较大的猫脸，可以将 minSize 设置为一个较大的值。\ninput swipe 540 1500 540 1000 100：这部分命令是要在设备上执行的实际 shell 命令。input 是一个 Android shell 命令，用于模拟用户输入。swipe 是 input 命令的一个子命令，用于模拟滑动操作。接下来的四个数字参数表示滑动操作的起点和终点坐标：(500, 1500) 是滑动的起点，(500, 80) 是滑动的终点。坐标系统的原点位于屏幕的左上角，x 轴向右延伸，y 轴向下延伸。100 是指延时 100ms，从第一个坐标滑到第二个坐标用时 100ms。\n\n测试\n抖音 Up 主：怀特喵先生\n\n\n\n\n抖音 Up 主：电波波波\n\n\n总结使用的haarcascade_frontalcatface.xml 这个模型，必须截图截到猫的正脸才可以，而且在视频播放时截图是随机的，可能这个镜头是猫猫的正脸，下个镜头就不是了，具有较大的不确定性。虽然没有达到 100% 识别率，但这个数据已经很好了。\n下一步工作接入腾讯 Ai 人脸识别，对人脸进行检测分析。\n参考[1] opencv&#x2F;data&#x2F;haarcascades at master · opencv&#x2F;opencv (github.com)\n[2] ADB 与 Anaconda 使用 | Story Begins…… (storybeginswhen.icu)\n","categories":["工具"],"tags":["Python","OpenCV","抖音"]},{"title":"Redmi AX6S 路由器刷 Openwrt","url":"/2023/03/17/038-Redmi-AX6S-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7-Openwrt/","content":"随着使用设备越来越多，每台设备上都要安装相应的科学上网软件，变得越来越麻烦。看到网上有给软路由的刷机教程，顺藤摸瓜，找到了给路由器刷机的教程[3]。看得十分心痒痒，直接开搞。\n准备工作\n一台红米 AX6S（京东购入，￥279，自带网线）\nAX6S 刷机包[1]\n\n操作步骤路由器刷入有漏洞的固件版本开箱新买来的红米 AX6S，插上电源，插上网线，等待前面指示灯亮起（共两个，System 和 Internet），其中可能是因为刚买来的缘故，Internet 灯是黄色的，System 等是蓝色的（正常）。\n打开笔记本电脑的无线网络设置，找到【xiaomi-router-rb03_miap3395】的 WiFi 名称，连接（开放式，不需要密码）。\n连接成功后，打开浏览器，在地址栏输入 192.168.31.1，进入 AX6S 路由器的后台。按照提示进行初始设置，设置完成后。重新进入路由器的后台，密码为你刚刚所设置的路由器密码。\n点击右上角【Redmi_AX6S】，点击【系统升级】→【手动升级】→【浏览】，找到 AX6S 刷机包，选择 miwifi_rb03_firmware_stable_1.2.7（内测版）.bin 文件，点击【开始升级】。\n等待路由器指示灯变蓝色后，在无线网络设置中找到这台 AX6S 对应的 WiFi 名称（如果没修改还是之前的），输入密码，打开浏览器，输入上述地址，重新进入后台。如图，可以看到界面有水印，版本为开发版 1.2.7。刷入成功！\n\n\n计算路由器 Root 密码网址：Xiaomi Router Developer Guide &amp; Tools (miwifi.dev)\n打开该网址，输入自己路由器设备的 SN 码，如上图右下角或路由器背面。计算得到 Root 密码。（最好复制到记事本或者哪里，方便之后查看和输入）\n使用 Putty 工具解锁 SSH打开 AX6S 刷机包，找到 putty 文件夹，双击打开 putty_x64_0.70汉化版.exe。按下图依次输入和点击，端口会自动从 22 变成 23，这个不用管。\n\n打开后输入用户名 root，密码：刚刚计算所得到的（不显示）。（小技巧：复制该密码，回到登录界面，右键直接粘贴，然后回车）。可以看到大大的 ARE U OK。\n\n\n复制粘贴下面的代码进去，然后敲回车。即可解锁 SSH。\nnvram set ssh_en=1 &amp; nvram set uart_en=1 &amp; nvram set boot_wait=on &amp; nvram set bootdelay=3 &amp; nvram set flag_try_sys1_failed=0 &amp; nvram set flag_try_sys2_failed=1nvram set flag_boot_rootfs=0 &amp; nvram set &quot;boot_fw1=run boot_rd_img;bootm&quot;nvram set flag_boot_success=1 &amp; nvram commit &amp; /etc/init.d/dropbear enable &amp; /etc/init.d/dropbear start\n\n使用 WinSCP 工具刷入 Openwrt 底包打开 AX6S 刷机包，找到 WinSCP 文件夹，双击打开 WinSCP.exe，按下图依次选择、输入和点击。密码依然是刚刚算出来的密码。点击登录后，会跳出【警告】，选择【跳过】即可。\n\n\n进入后，依次点击右侧栏的 … → tmp 文件夹。打开 AX6S 刷机包，找到 ax6s 文件夹，把 factory.bin 文件拖拽到 tmp 文件夹空白处，等待上传。上传成功后，打开刚刚的 Putty 界面，复制粘贴以下命令，敲回车。然后等待路由器重启（Rebooting……）。\nmtd -r write /tmp/factory.bin firmware\n\n\n\n路由器自动重启完成后，即路由器指示灯变蓝色。进入无线网络设置，找到 Openwrt5G &#x2F; Openwrt 连接，如果需要密码就是 12345678。\n配置 Openwrt打开浏览器，输入 192.168.6.1（如果不知道这个地址，可以打开 cmd 命令行，输入 tracert www.baidu.com，看到的第一个网络（ImmortalWrt.lan，后面的 IP 就是它的网关）。进入 Openwrt 后台登录界面，依次输入用户名：root，密码：password，进入管理界面（简陋版）。\n在左边栏依次点击【系统】→【备份&#x2F;升级】，找到【刷写新的固件】，取消勾选【保留配置】，点击【浏览】，选择 AX6S 刷机包下 ax6s 文件夹中的 sys.bin，点击【刷写固件】→【处理】。等待刷写固件。待路由器指示灯变蓝，在 WiFi 列表中找到 Openwrt5G &#x2F; Openwrt 连接，重新进入后台管理界面，可以看到左边栏多了很多东西。刷写成功！\n上网配置（下一篇详细讲解）\n无线配置[2]左边栏依次点击【网络】→【无线】，可以看到有两个配置，一个是普通，一个是 5G。分别对其设置：点击【基本设置】，修改名称、加密（选最长的 WPAPSKWPA2PSK）、密码，然后点击【保存&amp;应用】。修改成功后，在左边栏依次点击【系统】→【重启】，等待路由器指示灯变蓝色，再连接即可。\n\n增加新的固件[4]。\n参考[1] AX6S 刷机包 - 蓝奏云 (lanzouf.com)\n[2] openwrt&#x2F;lede无线WIFI名称及密码设置教程图文教程 - OpenWrt &#x2F; LEDE - 你好多多DIY (nihaodd.com)\n[3] 红米AX6S路由器刷OpenWrt固件，实现软路由功能，科学上网速度起飞 - YouTube\n[4] ax6s-openwrt固件.zip - 蓝奏云 (lanzoul.com)\n","categories":["折腾"],"tags":["Openwrt","AX6S"]},{"title":"PassWall-入门及进阶","url":"/2023/03/17/039-PassWall-%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6/","content":"Openwrt 上网配置在左栏点开【服务】，可以看到已经预装了很多插件。这篇文章详细讲解 PassWall 的基本使用和进阶教程。左图是我的，右图是参考链接博主[1]的。可以看出来很明显的不一样。\n\n\n\n\n\n\n\n\nPassWall 基本使用教程打开 PassWall，可以看到上方菜单栏有非常多的选项。而我们不需要关注那么多，只需要了解【基本设置】、【节点列表】、【自动切换】、【高级设置】、【节点订阅】、【规则列表】、【访问控制】。\n\n\n订阅机场链接打开机场，复制订阅链接。如果有多个订阅链接，选择复制 SSR 订阅链接。\n回到 PassWall，打开【节点订阅】，拉到最下面，点击添加，依次输入备注（可选）、订阅 URL（必填）。其他一概默认即可。点击保存&amp;应用。返回至【节点订阅】界面后，点击上面的手动订阅，会跳转到【查看日志】界面，订阅成功后会显示一共解析出多少个节点。【节点订阅】界面内容一概默认即可，尤其不要勾选通过代理订阅。打开【节点列表】界面，可以看到解析出的所有节点。另外，Ping 值没有任何意义。一般考虑带宽和拥堵情况来判断节点的好坏。\n使用节点打开【基本设置】界面，点开主要，TCP 节点选择一个节点，UDP 节点选择与 TCP 节点相同，勾选主开关。点击右下角保存&amp;应用，然后测试谷歌连接，有数值即可，不必在意数值大小，没有参考意义。此时就可以打开 YouTube。\n\n\n\n关于【基本设置】界面的几点说明：\nDNS：不要去动它。\n模式：如果想要调整，只调整TCP 默认代理模式 即可，其他都不要去动它。①不代理：字面意思；②全局代理：字面意思；③GFW 列表：仅那些被防火墙屏蔽的网站才走代理；④中国列表外：国内的所有网站都不走代理，国外的所有网站都走代理（不管是否屏蔽）；⑤中国列表：回国模式，国外网友想翻回国内。\n日志：不要去动它。\nFAQ：小提示，不需要去管它。\n\nPassWall 进阶使用教程自动切换自动切换 &#x3D; 故障转移。比如说正在使用 A 节点，A 突然不能用了，自动切换到 B，B 突然不能用了，自动切换到 C。\n打开【自动切换】界面。勾选启用，添加TCP 备用节点的列表。勾选TCP 恢复切换，意思是当 TCP 主节点恢复可以使用后，自动切换到主节点。点击保存&amp;应用。设置好后，【自动切换】就会去帮我们自动循环使用这些节点。\n\n\n规则列表打开【规则列表】界面。直连列表 &#x3D; 不代理的网站列表（无论之前在【基本设置】界面选择了什么模式）。代理列表与之相反。\n访问控制【访问控制】控制的是局域网内的设备，也就是连接到该路由器的设备。主要是来决定是否让它科学上网？使用什么节点科学上网？使用什么模式科学上网？\n专业名词：桥接、AP、有线中继……（必须在同一网段才能控制）。\n高级设置我的这个 PassWall 好像是被阉割过的。但是高级设置并用不到。和访问控制搭配食用。用于决定某设备走哪个节点，走什么模式等。\n分流打开【节点列表】界面，点击添加，类型选择 V2ray（Xray 目前可直接兼容 V2ray 并使用），协议选择分流，然后对分流规则里提供的网站分别选择节点，前置代理勾选就是使用默认节点，所以关闭即可。然后回到【基本设置】界面，在主要→TCP 节点中可以选择 Xray 分流：[分流总节点]，下面又是对给网站的一个配置。（好像也不需要）\n\n\n参考[1] 「275」 小白必看！OpenWrt下科学插件PassWall&amp;SSRP家教级入门和进阶使用 - YouTube\n","categories":["工具"],"tags":["PassWall","节点"]},{"title":"路由器测速报告","url":"/2023/03/21/040-%E8%B7%AF%E7%94%B1%E5%99%A8%E6%B5%8B%E9%80%9F%E6%8A%A5%E5%91%8A/","content":"硬件\nH3C Magic RC3000 千兆双频 WIFi6+ 路由器（电信送）\nRedmi AX6S（京东购入）\n\n测速网站\n测速网\n中国电信宽带助手\n\n测速结果\n\n\nMagic RC3000\n测速网\n电信宽带助手\n\n\n\n有线\n\n\n\n\n无线\n\n\n\n\n\n\n\nRedmi AX6S\n测速网\n电信宽带助手\n\n\n\n有线\n\n\n\n\n无线\n\n\n\n\n","categories":["工具"],"tags":["路由器","测速"]},{"title":"单片机名词解释","url":"/2023/03/23/041-%E5%8D%95%E7%89%87%E6%9C%BA%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/","content":"引脚英文缩写解释GNDGND 是 Ground 的缩写，通常翻译为“地”或“接地”，是电路中的一个重要概念。在电路中，GND 通常指代电路的零电位或参考电位，它是一个共同的参考点，用于给电路中的各个部分提供一个共同的电位基准。\n在单片机中，GND 通常是微控制器芯片的引脚之一，用于连接到电路板的地线。在连接外设和其他电路元件时，通常需要将这些元件的 GND 连接到微控制器芯片的 GND 引脚上，以确保整个电路的电势参考是相同的，从而保证电路正常运行。\n5V &amp; 3.3V5V 和 3.3V 是单片机常用的两种电压。它们分别代表着 5 伏特和 3.3 伏特的电压水平。在单片机中，这些电压通常用于给微控制器芯片和其他电路元件提供电源电压。\n5V 通常是较高的电压，可以提供更大的电流和更高的功率，适合驱动需要较大功率的元件，如大型电机、继电器、LED 灯等。在单片机中，5V 通常是由外部电源提供的，比如 AC 电源经过整流、滤波、稳压等步骤得到的直流电源。\n而 3.3V 则是较低的电压，通常用于驱动数字电路、存储器、传感器等低功率元件。相较于 5V，3.3V 可以降低功耗，减少电路中元件的发热和寿命损耗。在单片机中，3.3V 通常是由内部稳压器产生的，通过对 5V 电压进行稳压而得到的。\n需要注意的是，单片机中的 5V 和 3.3V 电源引脚的电流输出能力是有限的，不能超过其规定的最大值，否则会造成电路故障或烧毁元件。因此，在设计电路时需要根据实际需求和元件的规格选择适当的电源电压。\nRXD &amp; TXDRXD 和 TXD 分别是串行通信中的接收器数据线和传输器数据线，它们通常是单片机芯片上的引脚之一。在串行通信中，TXD 用于发送数据位序列，RXD 用于接收数据位序列。\n当一个设备向另一个设备发送数据时，发送器将数据位序列传输到 TXD 引脚，然后将这些数据位序列转换成一个数据帧，该数据帧包含用于标识和检测数据的同步和校验位。接收器通过 RXD 引脚接收数据帧，并根据同步和校验位确定是否正确接收了数据。如果接收器成功接收了数据，则可以将这些数据用于后续操作。\n在单片机系统中，TXD 和 RXD 引脚通常用于与外部设备进行串行通信，例如与传感器、显示屏、GPS 接收器等设备进行通信。单片机可以使用内置串行通信模块或外部串行通信芯片来实现与这些设备的通信。\n需要注意的是，不同的串行通信协议（如 UART、SPI、I2C 等）具有不同的数据传输方式和电信号特性，因此需要根据实际情况来选择正确的串行通信协议和接口引脚。\nDAC、ADC &amp; TPADDAC、ADC 和 TPAD 都是单片机中常见的模拟电路模块，分别用于数字信号到模拟信号的转换、模拟信号到数字信号的转换和触摸检测。\nDAC（Digital-to-Analog Converter，数字模拟转换器）是一种电路，用于将数字信号转换为模拟信号。DAC 可以将数字数据（例如二进制数据）转换为模拟信号，如电压或电流。在单片机应用中，DAC 通常用于输出模拟电压，以控制电路的各种操作，例如输出音频信号、控制电机转速等。\nADC（Analog-to-Digital Converter，模拟数字转换器）是一种电路，用于将模拟信号转换为数字信号。ADC 可以将模拟电压或电流转换为数字数据（例如二进制数据），以便单片机可以使用这些数据进行数字信号处理。在单片机应用中，ADC 通常用于读取传感器输出的模拟信号、检测电池电压、读取温度传感器等。\nTPAD（Touch Pad，触摸检测器）是一种用于检测触摸的电路模块。TPAD 通常使用传感器或电容触摸技术来检测用户触摸板上的位置和动作。在单片机应用中，TPAD 可以用于设计触摸开关、触摸屏、触摸按钮等应用场景。\nPWR在单片机系统中，PWR 通常是指电源或电源管理电路。PWR 是提供单片机系统所需电压的电源电路或芯片，它可以提供不同电压级别的电源输出，以满足单片机和外部电路的不同电源需求。\nPWR 的主要功能包括：稳定电压输出、保护电路和检测电源状态。PWR 通常包括稳压器、滤波器、过压保护、欠压保护和电源监测等功能，以确保单片机系统在不同的工作条件下都能正常工作。\nVEXTVEXT 通常是指在某些嵌入式系统或单片机板上的扩展电源引脚，用于提供外部设备的电源。\n在一些嵌入式系统或单片机板上，VEXT 可能是一个电源引脚，通常用于提供外部设备的电源。VEXT 通常会被设计为可编程的，以便用户可以根据需要设置电源的电压和电流，以满足外部设备的电源要求。VEXT 通常需要在代码中进行配置和初始化，以确保其正确工作。\nTX &amp; RXTX 和 RX 是串行通信中常用的引脚名称，分别表示发送（Transmit）和接收（Receive）数据的引脚。\n在串行通信中，TX 引脚用于将数据从发送端发送到接收端，而 RX 引脚用于将数据从接收端接收到发送端。这种通信方式通常使用串行通信协议，如UART、SPI、I2C等。\n例如，在UART通信中，数据通过TX引脚从发送器发送到接收器的RX引脚。在SPI通信中，数据通过主设备的TX引脚发送到从设备的RX引脚。在I2C通信中，数据通过SDA引脚进行双向传输，而SCL引脚用于时钟同步。\nCLKCLK 是时钟信号的缩写，通常用于指示系统中的时钟引脚或时钟信号。在数字系统中，时钟信号是一种特殊的信号，它用于同步系统中的各种操作和数据传输。\n在单片机系统中，CLK 通常用于指示时钟引脚或时钟信号。时钟信号通常由时钟发生器或外部时钟源产生，用于同步单片机内部操作和外部设备之间的数据传输。\n时钟信号的频率通常被称为时钟频率，它表示时钟信号在单位时间内变化的次数。时钟频率越高，系统的运行速度就越快，但同时也会增加系统的功耗和干扰。\n在单片机系统中，CLK 引脚通常用于连接时钟信号源或时钟发生器，以提供系统所需的时钟信号。CLK 引脚的特性和功能取决于具体的单片机型号和应用要求，有些单片机还可能具有多个 CLK 引脚，以支持不同的时钟频率和操作模式。\nDIODIO 是数字输入&#x2F;输出（Digital Input&#x2F;Output）的缩写，通常用于指示数字信号输入&#x2F;输出引脚或数字信号输入&#x2F;输出模块。\n在电子系统中，数字信号是用离散的、二进制的方式表示的信号，通常由 0 和 1 两个状态组成。数字信号输入&#x2F;输出通常用于连接数字传感器、执行器、开关等数字设备或模块，用于接收或输出数字信号。\nDIO 引脚通常用于连接数字输入&#x2F;输出设备或模块，以实现数字信号的输入或输出。数字输入&#x2F;输出设备通常由数字电路和数字信号转换电路组成，可以将输入的数字信号转换为电压或电流信号，或者将输出的电压或电流信号转换为数字信号。\n在单片机系统中，DIO 引脚通常用于连接数字输入&#x2F;输出设备或模块，以实现与外部数字设备的通信和控制。DIO 引脚的数量、特性和功能取决于具体的单片机型号和应用要求，有些单片机还可能具有多个 DIO 引脚，以支持更多的数字输入&#x2F;输出设备或模块。\nTRST &amp; NRSTTRST 和 NRST 都是芯片或系统的复位引脚，但两者有着不同的特点和用途。\nTRST 是 Test Reset 的缩写，通常用于调试接口或测试引脚中的复位信号。TRST 引脚通常用于测试和调试芯片或系统，以实现调试和测试的目的。TRST 通常是一个可选的引脚，不是所有的芯片或系统都支持 TRST 功能。\nNRST 是 Negative Reset 的缩写，通常用于将芯片或系统复位到初始状态。NRST 引脚通常用于连接复位电路或复位按钮，以实现芯片或系统的复位。NRST 通常是必选的引脚，所有的芯片或系统都需要支持 NRST 功能。\n另外，TRST 和 NRST 的电平和信号特性也有所不同。TRST 通常需要提供低电平或负电平的复位信号，而 NRST 则需要提供高电平或正电平的复位信号。在使用 TRST 或 NRST 引脚时，需要根据具体的芯片或系统规格和需求，选择合适的电平和信号特性，以确保复位信号的正确性和可靠性。\nTDI &amp; TDOTDI 是 Test Data Input 的缩写，通常用于指示调试接口或测试引脚中的测试数据输入引脚。TDI 通常用于在调试或测试过程中向目标系统或芯片输入测试数据，以进行测试或调试操作。\nTDO 是 Test Data Output 的缩写，通常用于指示调试接口或测试引脚中的测试数据输出引脚。TDO 通常用于在调试或测试过程中从目标系统或芯片输出测试数据，以进行测试或调试操作。\nTMSTMS 是 Test Mode Select 的缩写，通常用于指示调试接口或测试引脚中的测试模式选择引脚。TMS 通常用于在调试或测试过程中控制目标系统或芯片的测试模式，以进行测试或调试操作。\nTCKTCK 是 Test Clock 的缩写，通常用于指示调试接口或测试引脚中的测试时钟引脚。TCK 通常用于在调试或测试过程中提供目标系统或芯片的时钟信号，以进行测试或调试操作。\nNCNC 通常是 Not Connected 的缩写，表示该引脚没有连接到任何电路或设备，即未连接（Not Connected）。在电路设计或器件规格中，NC 通常用于表示某些引脚或端口不需要使用，或者暂时没有使用。\n其他英文缩写解释JTAG、SWD &amp; STPJTAG 是 Joint Test Action Group 的缩写，也称为 IEEE 1149.1 标准，是一种用于测试和调试集成电路的标准接口协议。JTAG 通常用于连接调试工具和测试设备，实现对芯片或系统的测试和调试操作。\nJTAG 接口标准定义了一组标准化的测试和调试信号，包括 Test Clock (TCK)、Test Mode Select (TMS)、Test Data Input (TDI)、Test Data Output (TDO) 和 Test Reset (TRST) 等信号。这些信号通常通过一个标准的接口进行连接，以实现芯片或系统的测试和调试功能。\nJTAG 接口通常包括两种工作模式，一种是测试模式，用于对芯片或系统进行测试和调试；另一种是生产模式，用于生产过程中的编程和测试。JTAG 接口也支持芯片或系统的在线编程和调试，以及实时监测芯片或系统的运行状态和性能指标。\nSWD 是 Serial Wire Debug 的缩写，是一种用于调试嵌入式系统的接口协议。SWD 接口是 ARM 公司开发的，通常用于连接调试工具和目标芯片，实现对芯片的调试和测试操作。\nSWD 接口包括两根线：SWDIO 和 SWCLK。其中，SWDIO 是双向数据线，用于在芯片和调试工具之间传输数据，包括调试命令和数据；SWCLK 是单向时钟线，用于提供时钟信号，控制数据的传输和接收。\nSWD 接口通常采用 2 线模式或 4 线模式。在 2 线模式下，只需要使用 SWDIO 和 SWCLK 两根线；在 4 线模式下，除了 SWDIO 和 SWCLK，还需要使用另外两根线，分别是 RESET 和 SWO。RESET 用于芯片的复位，SWO 用于从芯片输出调试数据。\nSTP 是 Serial Test and Programming 的缩写，是一种用于调试和编程集成电路的接口协议。STP 接口是 TI 公司开发的，通常用于连接调试工具和目标芯片，实现对芯片的调试和编程操作。\nSTP 接口包括两根线：STPDI 和 STPDO。其中，STPDI 是双向数据线，用于在芯片和调试工具之间传输数据，包括调试命令和数据；STPDO 是单向数据线，用于芯片从调试工具读取数据。\nSTP 接口支持多种操作模式，包括调试模式、编程模式、读出模式等。调试模式用于实时监测芯片的运行状态和性能指标；编程模式用于对芯片进行在线编程和调试；读出模式用于从芯片读取数据。\n三者的区别主要在于接口协议的实现方式、连接线的数量和接口功能的不同。它们的联系主要在于都是用于调试和编程集成电路的接口协议，都需要连接调试工具和目标芯片，实现对芯片的调试和编程操作。此外，JTAG、SWD 和 STP 的应用和实现也受到芯片和系统的具体要求和规格的影响。\nJ-LinkJ-Link 是一种由 SEGGER 公司开发的通用 JTAG&#x2F;SWD 调试器和仿真器，用于连接调试工具和目标芯片，实现对芯片的调试、测试和编程操作。J-Link 支持多种调试接口协议，包括 JTAG、SWD、STP 等，可以实现对多种芯片和系统的调试和编程功能。\nJ-Link 通常包括硬件和软件两部分。硬件部分包括 J-Link 调试器本身，以及与芯片和目标系统连接的接口线。J-Link 调试器可以提供高速、稳定的调试和仿真功能，支持多种工作模式和操作模式，包括在线调试、离线调试、仿真模式等。接口线通常包括不同的接口头和线缆，以适配不同的芯片和目标系统。\n软件部分包括 J-Link 调试器驱动程序和调试工具软件。J-Link 调试器驱动程序用于与操作系统和调试工具软件通信，以实现对芯片和目标系统的调试和编程操作。调试工具软件包括多种调试工具和 IDE，如 J-Link GDB Server、J-Link Flash Programmer、J-Link Integrated Development Environment（IDE）等，以提供全面的调试和编程功能。\nIDEIntegrated Development Environment（IDE）是一种集成的开发环境，用于开发、调试和测试软件应用程序。IDE 通常包括多个组件，如源代码编辑器、编译器、调试器、版本控制工具、图形界面设计工具、文档生成工具等，以提供全面的软件开发和测试功能。\nIDE 主要用于软件开发过程中的集成化、协同化和自动化，可以提高开发效率和软件质量，减少错误和重复工作。IDE 通常提供多种功能和工具，如代码自动补全、语法检查、代码重构、调试跟踪、性能分析、测试工具等，可以帮助开发人员在更短的时间内开发出高质量的软件应用程序。\nIDE 的实现和应用广泛，适用于多种软件开发环境和语言，如 C、C++、Java、Python 等。不同的 IDE 也具有不同的特点和优势，可以根据具体的软件开发需求和环境进行选择和使用。\nWinbond W9825G6KH-6Winbond W9825G6KH-6 是一种 SDRAM 存储器，属于 Winbond 公司生产的 W98 系列产品。该产品具有 256M 位的容量，数据传输速度为 166MHz，采用 4 个银河内部银行和 4 个独立外部银行的设计，支持 4bit 和 8bit 的预取数据。此外，W9825G6KH-6 还采用了低功耗设计，具有广泛的应用和优秀的性能特点。\nW9825G6KH-6 适用于各种存储设备和系统中，如智能手机、平板电脑、网络通讯、工业控制、汽车电子等领域。该产品采用了高速、稳定、可靠的设计，可以满足客户的不同需求，并且具有优秀的性能和可靠性，得到了广泛的应用和好评。\n（Winbond 是一家专门从事闪存存储器、DRAM 存储器、语音 IC、微控制器和系统软件等领域的半导体公司。其总部位于台湾，成立于1987年，目前已经成为全球领先的半导体公司之一。\nWinbond 公司主要的产品包括闪存存储器、DRAM 存储器、语音 IC、微控制器和系统软件等，广泛应用于智能手机、平板电脑、数码相机、网络通讯、工业控制、汽车电子等领域。其中，闪存存储器和DRAM 存储器是 Winbond 公司的核心业务之一，具有高速、稳定、可靠等优点，被广泛应用于各种存储设备和系统中。）\nUSARTUSART，全称为 Universal Synchronous&#x2F;Asynchronous Receiver Transmitter，是一种串行通信接口协议，用于实现数据的收发和传输。USART 接口通常包括 TXD（发送端）、RXD（接收端）和时钟等信号线，支持同步和异步两种通信方式，以及多种数据格式和传输速率。\nUSART 接口主要应用于嵌入式系统中，可用于与外设或者其他设备进行数据的交换和通信。\nUSB&#x2F;CANUSB&#x2F;CAN 是一种 USB 和 CAN 通信接口的组合，用于实现 USB 和 CAN 总线之间的数据交换和通信。USB&#x2F;CAN 接口通常包括 USB 接口和 CAN 总线接口两部分，可以通过 USB 端口与计算机或其他设备相连，实现数据的读写和传输。\nUSB&#x2F;CAN 接口通常用于嵌入式系统中，可以用于与外设或其他设备进行数据的交换和通信。\n","categories":["STM32"],"tags":["名词解释","单片机"]},{"title":"ChatGPT Plus 续费失败及解决方案","url":"/2023/03/24/042-ChatGPT-Plus-%E7%BB%AD%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"最近到了续订 ChatGPT Plus 的日期，没有任何提示，Depay 钱包也没有任何付款记录。打开 ChatGPT Plus 订阅界面，发现付款失败了。提示“您最近的付款失败了。更新您的支付方式，以继续该方案。”\n点击更新支付方式，重新输入显示“银行卡被拒绝”。\n看网上说 Depay 被风控了。于是找了国外的朋友，使用他们的信用卡&#x2F;借记卡。通通显示拒绝该银行卡。以为是账单地址的问题，于是修改账单地址，再填写银行卡，依然不行。\n点击取消方案，看到可以用到 4 月 19 日（白嫖 1 个月）。意思是取消 Plus 方案也还可以再用一个月。\n去闲鱼找代付，要我账号和密码。去 Telegram 找代付，要我 70 手续费。我都想着白嫖完这一个月到时候买成品号了。\n直到昨晚睡前刷一下知乎，看到了有人和我遇到了同样的问题[1]，并解决了它。顺藤摸瓜找到了 Twitter 大神的解决方案。\n\n\n首先使用日本节点、加拿大朋友的借记卡，经过一系列【我是人类】的验证后，失败。更换为韩国节点，继续使用加拿大朋友的借记卡，经过一次【我是人类】的验证，等待……付款成功！\n不清楚 Stripe 风控的什么，反正能续一个月是一个月，这次又能用到 5 月 19 日了。\n参考[1] 续订ChatGPT Plus失败，如何解决？ - 知乎 (zhihu.com)\n","categories":["工具"],"tags":["ChatGPT","Plus","国外信用卡"]},{"title":"Ubuntu 安装 Anaconda","url":"/2023/03/24/043-Ubuntu-%E5%AE%89%E8%A3%85-Anaconda/","content":"步骤\n下载 Anaconda 打开文件夹，在想要下载 Anaconda 的位置，右键打开终端：\nwget &lt;https://mirrors.bfsu.edu.cn/anaconda/archive/Anaconda3-2023.03-Linux-x86_64.sh&gt; --no-check-certificate\n\n注意：在镜像网站（ https://repo.anaconda.com/archive/?C=M&amp;O=A ）查看 Anaconda 的版本信息，然后更改命令。\n\n安装 Anaconda 下载完成后发现是一个 .sh 脚本。 首先给他可执行权限，然后执行：\nchmod +x Anaconda3-2023.03-Linux-x86_64.sh./Anaconda3-2023.03-Linux-x86_64.sh\n\n回车后查看许可证，按 q 退出许可证，然后输入 yes 表示同意。确认安装的路径，默认即可。 安装完毕后，输入 yes 来确认使用 conda init 来启动。 \n\n退出 Anaconda3 的基础环境（base）\nconda deactivate\n\n打开 Anaconda 图形化界面 首先将 Anaconda 的 bin 目录添加到系统的 PATH 环境变量中。如果不知道 Anaconda 的路径，可以先用命令行查找。\nwhich conda //查看 Anaconda 路径export PATH=&quot;/path/to/anaconda/bin:$PATH&quot; //修改成 bin 的路径anaconda-navigator //启动图形化界面，有警告不用理会\n\n安装 VSCode\n下载 deb 安装包：Download Visual Studio Code - Mac, Linux, Windows\n\n安装 VSCode\nsudo dpkg -i code_(tab) //使用 Tab 键补全\n\n参考[1] Ubuntu 安装 conda - 知乎 (zhihu.com)\n","categories":["工具"],"tags":["Ubuntu","Anaconda","Python"]},{"title":"树莓派入门","url":"/2023/03/27/044-%E6%A0%91%E8%8E%93%E6%B4%BE%E5%85%A5%E9%97%A8/","content":"从淘宝购得树莓派一套，型号为 Raspbeey Pi 4B 8G。首先组装亚克力外壳[1,2]。\nSSH 连接Ctrl + Alt + T 打开终端，输入 ipconfig 查看树莓派 IP 地址。\n但是下次启动时可能由于路由器采取的是 DHCP，自动分配未使用的 IP 地址。下次登录时就不知道 IP 地址了。可以通过【搭建开发环境所需的工具与系统镜像】文件夹中的 Advanced IP Scanner 来查找树莓派 IP 地址。\n参考[1] 树莓派4代 透明亚克力外壳安装（兼容红外遥控模块）bilibili\n[2] 【树莓派】树莓派摄像头安装教程！超详细！bilibili\n","categories":["树莓派"],"tags":["入门","组装"]},{"title":"无线打印机使用教程","url":"/2023/03/27/045-%E6%97%A0%E7%BA%BF%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","content":"型号：HP Laser Jet MFP M227fdw\n步骤：\n\n笔记本电脑连接 WiFi：505_5G\n\n（Win11）打开【设置】→【蓝牙和其他设备】→【打印机和扫描仪】→【添加设备】\n\n\n\n\n使用 Ctrl + P 进行打印，打印机选项选择 NPI02ACF7。\n\n\n","categories":["工具"],"tags":["打印机"]},{"title":"WordPress 入门","url":"/2023/03/27/046-WordPress-%E5%85%A5%E9%97%A8/","content":"安装阿里云提供了非常方便的安装方式。使用之前创建 Memos 时购买的轻量应用服务器。点击【重置系统】（或者新买一台），在镜像那一栏，选择【应用镜像】→【WordPress】（可以选版本），然后确认即可，等待几秒钟，重置完成。\n\n\n在左栏点击【应用管理】→【应用详情】，可以看到 WordPress 的使用方式。\n\n\n登录根据上述提示，打开 WordPress 管理界面。\n\n输入账号密码登录。成功进入后台。（管理员邮箱的事情其实不必管它）\n\n","categories":["工具"],"tags":["WordPress","博客"]},{"title":"Keil5 DAP 仿真器设置","url":"/2023/03/29/047-Keil5-DAP-%E4%BB%BF%E7%9C%9F%E5%99%A8%E8%AE%BE%E7%BD%AE/","content":"使用 DAP 仿真器的设置（来自正点原子旗舰店技术支持）：\n\n\n注意：下图默认的 Connect 和 Reset 改为上图所示。\n\n\n设置完 Debug 栏后，再设置一下 Utilities。\n\n","categories":["STM32"],"tags":["Keil5","DAP"]},{"title":"jupyter 入门","url":"/2023/03/29/048-jupyter-%E5%85%A5%E9%97%A8/","content":"安装此处使用最简单的方式。（OS：Win11）\n打开 Anaconda Navigator，在 Enviroments 页面创建一个新的虚拟环境。回到 Home 页，点击 JupyterLab 下的 Install。等待安装完成。\n启动选择想要使用的 Enviroment，回到 Home 页，点击 JupyterLab 下的 Launch，会直接跳转到浏览器页面，如下图所示。\n\n使用每一个 .ipynb 文件都是 Jupyter Notebook（Jupyter 笔记本）。里面有一个个的 Cell，每个 Cell 都是一段独立的程序，运行它，就会在下面显示输出结果。\n（……后续补充）\n快捷键命令模式（按 Esc 键进入）\nEnter：进入编辑模式\nShift + Enter：执行当前单元格，并跳转到下一个单元格\nCtrl + Enter：执行当前单元格，不跳转\nAlt + Enter：执行当前单元格，并在下面插入一个新单元格\nY：将当前单元格转换为代码单元格\nM：将当前单元格转换为 Markdown 单元格\nA：在上面插入一个新单元格\nB：在下面插入一个新单元格\nX：剪切当前单元格\nC：复制当前单元格\nV：粘贴到下方\nShift + V：粘贴到上方\nD + D：删除当前单元格\nZ：撤销删除操作\nShift + M：合并当前单元格和下方的单元格\nCtrl + S：保存当前笔记本\nF：查找和替换\n\n编辑模式（按 Enter 键进入）\nShift + Enter：执行当前单元格，并跳转到下一个单元格\nCtrl + Enter：执行当前单元格，不跳转\nAlt + Enter：执行当前单元格，并在下面插入一个新单元格\nCtrl + /：注释当前行或取消注释\nCtrl + ]：缩进当前行\nCtrl + [：取消缩进当前行\nTab：代码补全\nShift + Tab：获取当前变量的帮助文档\nCtrl + Shift + -：在当前光标位置拆分单元格\nEsc：返回到命令模式\n\n停止正在运行的程序在 Jupyter Notebook 中，要停止正在运行的程序，可以使用以下方法：\n\n在运行程序的单元格上按 Interrupt the kernel 按钮。这个按钮的图标是一个黑色的方块，在 Jupyter Notebook 的工具栏上。点击该按钮后，程序将被中断并停止运行。\n在 Jupyter Notebook 中的 Kernel 菜单中选择 Interrupt 命令。这个命令将中断正在运行的程序并停止它。\n在 Jupyter Notebook 中的 Kernel 菜单中选择 Restart 命令。这个命令将重新启动 Jupyter Notebook 的内核，并且所有正在运行的程序将被终止。\n\n","categories":["工具"],"tags":["Python","jupyter"]},{"title":"Stable Diffusion WebUI 入门","url":"/2023/03/30/049-Stable-Diffusion-WebUI-%E5%85%A5%E9%97%A8/","content":"Stable-Diffusion-WebUI 安装网上各种配置着实麻烦，可能因为网络崩掉。幸好，有秋叶大佬：秋葉aaaki的个人空间-哔哩哔哩\n启动器启动器[1]下载链接：https://pan.baidu.com/s/1XHOx7zgO0IQVL-01opwXjA?pwd=uvdy\n整合包整合包[2]下载链接: https://pan.baidu.com/s/1qWggi0qMMTdMpqCNCRcjoQ提取码: a241\nSDW 启动打开如图所示，点击【一键启动】。（刚开始启动时会要求填写同意书，按提示操作即可）\n\n\n第二次启动，在浏览器中打开 Stable Diffusion WebUI。\n\n\n\n\nAI 绘画网站收集[1] Civitai | Stable Diffusion models, embeddings, hypernetworks and more\n[2] Stability AI\n参考[1] 【AI绘画】启动器正式发布！一键启动&#x2F;修复&#x2F;更新&#x2F;模型下载管理全支持！-哔哩哔哩\n[2] 【AI绘画】Stable Diffusion 最终版 无需额外下载安装！可更新✓ 训练✓ 汉化✓ 提供7G模型 NovelAI-哔哩哔哩\n","categories":["工具"],"tags":["SD","AI 绘画"]},{"title":"无线投影仪使用教程","url":"/2023/03/31/050-%E6%97%A0%E7%BA%BF%E6%8A%95%E5%BD%B1%E4%BB%AA%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","content":"硬件\nEPSON TW740&#x2F;750\n笔记本电脑（Win11 系统）\n\n操作步骤EPSON 投影仪端\n使用遥控器或投影仪面板的 Menu 键进入菜单[1]，找到【网络】，将【无线电源】设置为【无线 LAN 开】，进入【网络配置】。\n选择【无线 LAN】，将连接模式改为【高级】，进入【搜索接入点】，选择要连接的 WiFi 名称，输入密码，点【Finish】连接。在【IP 设置】中将【DHCP】设置为 开（可选项）。\n\n笔记本电脑端\n连接名称相同的 WiFi。（505 与 505_5G 同属于一个路由器，所以都可以使用）\n按下快捷键[2] Win + K，选择出现的投影仪名称连接即可。\n\n参考[1] 移动设备通过路由器实现无线投影方法 - 爱普生产品常见问题 - 爱普生中国 (epson.com.cn)\n[2] EPSON 官方电话：4008109977\n","categories":["工具"],"tags":["投影仪","无线"]},{"title":"使用 VLC 拉取视频流","url":"/2023/03/31/051-%E4%BD%BF%E7%94%A8-VLC-%E6%8B%89%E5%8F%96%E8%A7%86%E9%A2%91%E6%B5%81/","content":"准备工作软件\nVLC media player：v3.0.17.4\nOS：Win11\n\n硬件\n摄像头：SONY FCB-CV7520\n无线模块 1：\n无线模块 2：\n\n操作步骤参考[1] 跟踪板 产品详情 (sumboy.cn)\n","categories":["工具"],"tags":["VLC","网络摄像头"]},{"title":"手指机器人实现","url":"/2023/04/01/052-%E6%89%8B%E6%8C%87%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AE%9E%E7%8E%B0/","content":"参考[1] 关耳极创的个人空间 bilibili\n[2] SG90系列 MG系列马达_wonull的博客-CSDN博客\n","categories":["项目"],"tags":["控制","建模"]},{"title":"STM32 HAL 库实现舵机旋转","url":"/2023/04/03/053-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0%E8%88%B5%E6%9C%BA%E6%97%8B%E8%BD%AC/","content":"引言舵机有一种电机可以在程序的控制下，在一定范围内连续改变输出轴角度并可以保持住。 这种电机最早被用在航模和船模等遥控模型中，控制各种舵面的转动，这就是舵机。 \n舵机控制基本原理舵机的控制一般需要一个 20ms 周期的 PWM 信号，该脉冲的高电平部分一般为 0.5ms~2.5ms 范围内的角度控制脉冲部分。以 180° 角度伺服为例，对应关系如下所示：\n\n0.5 ms 高电平 ——– 0°\n1.0 ms 高电平 ——– 45°\n1.5 ms 高电平 ——– 90°\n2.0 ms 高电平 ——– 135°\n2.5 ms 高电平 ——– 180°\n\n顺时针还是逆时针转动需要自己试。\n准备工作硬件\nSTM32F429IGT6 开发板\nSG90 9 克舵机\n\n软件\nSTM32CubeMX\nKeil5\n\n计算180° → 2ms。那么 3μm → 0.27°。意味着这个舵机的控制精度为 0.27°。\n推导公式：n&#x2F;90(ms) + 0.5ms，n 为想要转到的角度。\n实操步骤\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置（参考：成为点灯大师 LED Master | Story Begins ）完成后。选择针脚，查阅手册可知 PA6 可通过 TIM3_CH1 开启。配置 TIM3 的 CH1，完成后可以看到右边 PA6 引脚变为绿色。③ 的原理参考：xx。\n\n\n\n图 1 TIM3_CH1 配置\n\n\n进行 STM32CubeMX 通用配置 [2]的第 5 步。\n\n打开工程文件。按照 Keil5 MDK 通用配置 [2]完成后开始编写代码。\n打开 main.c 文件。在 main 函数中开启 PWM。\n/* USER CODE BEGIN 2 */HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1);/* USER CODE END 2 */\n\n输出 PWM。此处输出为正转 180° 后反转 180°，以此往复。\n/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123;    /* USER CODE END WHILE */    /* USER CODE BEGIN 3 */    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_6);    __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, 500);    HAL_Delay(1000);    __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, 2500);    HAL_Delay(1000);&#125;/* USER CODE END 3 */\n\n进行 Keil5 MDK 通用配置 [2]的第 5 步。\n\n\n\n上述例程成功运行。\n\n参考[1] 基于cubemx的舵机加减速控制方法_bilibili\n[2] 成为点灯大师 LED Master | Story Begins \n","categories":["STM32"],"tags":["HAL","PWM"]},{"title":"STM32CubeMX-Keil 通用配置","url":"/2023/04/11/054-STM32-%E5%BC%80%E5%8F%91%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/","content":"在实际项目开发中，我们会发现，有很多配置是通用的，有很多代码是复用的。本文总结了 STM32CubeMX 和 Keil5 MDK 的一些通用设置，以供 STM32 项目开发时查阅，帮助开发者快速配置好所需环境。\nSTM32CubeMX 通用配置创建工程打开 STM32CubeMX 软件，点击 ACCESS TO MCU SELECTOR，在左上搜索框输入芯片型号（如 429ig），在右下角选择自己的芯片，右上角点击 Start Project。\n\n\n图 1.1 芯片型号选择\n\n配置 SYSDebug 选择 Serial Wire(SW)。\n\n\n图 1.2 SYS 配置\n\n配置 RCCHSE 选择 Crystal/Ceramic Resonator。\n打开 Clock Configuration 界面，配置如图，选择 HSE 和 PLLCLK，在 HCLK(MHz) 框中输入 168 后回车，自动配置所有数据。\n\n\n图 1.3 RCC 配置\n\n\n\n图 1.4 Clock Configuration 界面配置\n\n配置工程配置包括工程名称、存储位置、IDE 选择、代码生成等选项，如下图所示。\n\n\n图 1.5 工程文件名称等配置\n\n\n\n图 1.6 代码生成配置\n\n生成代码右上角点击 GENERATE CODE，接着点击 Close。（如果直接点 Open Project，Keil5 中没有代码提示。）\n\n\n图 1.7 生成代码操作\n\nKeil5 MDK 通用配置打开项目工程文件找到存储位置，路径：E:\\Data\\DuoJi\\TEST\\MDK-ARM，双击打开 xxx.uvprojx 文件。\n\n\n图 2.1 项目工程文件位置\n\n编译代码打开项目后的第一件事：编译代码，关联出头文件。\n\n\n图 2.2 编译代码\n\n仿真器连接配置点击 魔法棒 → Debug → 选择 DAP → Setting，可以看到已经识别到了芯片。然后点击 Flash Download → Reset and Run，为了能够下载进程序后，就开始运行代码，不用手动再去点一下复位键。配置完成后，点 OK。\n\n\n\n\n\n\n\n\n\n\n\n\n图 2.3 仿真器连接配置\n\n下载程序写完代码后，先编译一下，再下载到开发板。\n\n\n图 2.4 下载程序流程\n\n宏定义 LED 灯写在 main.c 文件中的 main() 函数外。\n/* USER CODE BEGIN 0 */#define LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET) //LED0 亮#define LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET) //LED0 灭#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET) //LED1 亮#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET) //LED1 灭#define LED0_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1) //LED0 闪烁#define LED1_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0) //LED1 闪烁/* USER CODE END 0 */\n\n宏定义按键写在 main.c 文件中的 main() 函数外。判断按键是否按下，使用 if(KEY0 == 0)。\n/* USER CODE BEGIN 0 */# define KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)# define KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)# define KEY2 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)/* USER CODE END 0 */\n\n","categories":["STM32"],"tags":["Keil5","CubeMX"]},{"title":"PWM 从入门到入土","url":"/2023/04/07/055-PWM-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/","content":"引言在嵌入式开发中，除了对电路进行简单的数字量控制（如【打开&#x2F;关闭】，也就是“状态”控制），还会进行一些模拟电路控制（也就是“程度”控制）。举个栗子：比如现在控制一盏灯，简单的开关灯，就是对数字量（0、1）的控制；而控制灯的亮度，如把灯调得暗一些，就是对模拟量的控制。PWM 就是用来做“程度”控制的一种技术。\n概念PWM（Pulse Width Modulation，脉宽调制）是一种调制技术，用于控制模拟信号的幅度、频率和相位等特性。PWM 技术通过改变信号的脉冲宽度，来控制信号的平均电压值和电平持续时间，从而实现对模拟信号的控制。\n在 PWM 技术中，一个周期的时间被分为若干个等分的时间片，每个时间片内的电平状态由信号的脉冲宽度决定，通常用占空比（Duty Cycle）表示，即高电平时间与一个周期的比值。例如，如果一个周期的时间为 1 秒，高电平时间为 0.5 秒，则占空比为 50%。\n\n\n图 1.1 PWM 输出原理图\n\n图注：定时器工作模式为向上计数，当 CNT&lt;CCRx 时，输出低电平，当 CNT&gt;CCRx 时，输出高电平。当 CNT&#x3D;ARR 时，重新归零，然后重新向上计数，依次循环。改变 CCRx 的值，就可以改变 PWM 的占空比。改变 ARR 的值，就可以改变 PWM 的输出频率。\n举栗：定时器 TIM2 的 APB1 桥频率为 84MHz，PSC &#x3D; 84 -1，经过预分频器，频率变成了 1MHz（&#x3D;1&#x2F;106&#x3D;0.001ms），ARR 设置为 1000-1，则相当于 1KHz（&#x3D; 1ms）重载一次，也就意味着 1ms 产生一次中断。①如果想要 0.2s 产生一次中断，则将 ARR 的值设为 200x103-1，如果想要 0.5s 产生一次中断，则将 ARR 的值设为 500x103-1。②如果想要占空比为 50%，则将 CCRx 的值设置为 ARR 的一半。\n实操例程 1：PWM 呼吸灯步骤\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置[1]配置完成后。将 PB0、PB1 引脚分别设置为 TIM3_CH3、TIM3_CH4。接着配置 TIM3 的 CH3、CH4，如图所示：\n\n\n\n图 3.1 LED 灯引脚定时器功能配置\n\n\n\n配置完成后生成代码。打开 Keil5 MDK 工程文件，按照 Keil5 MDK 通用配置[1]配置完成后，开始编写代码。\n打开 main.c 文件。在【main】函数中开启 PWM。\n/* USER CODE BEGIN 2 */HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_4);/* USER CODE END 2 */\n\n在【main】函数中的【while】循环中写 PWM 控制呼吸灯功能。\n/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123;    /** LED0 配置 **/    /* LED0 逐渐熄灭 */    for(uint16_t pwmVal=0; pwmVal&lt;1000; pwmVal++)    &#123;        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_4, pwmVal);        HAL_Delay(1);    &#125;    /* LED0 逐渐点亮 */    for(uint16_t pwmVal=1000; pwmVal&gt;0; pwmVal--)    &#123;        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_4, pwmVal);        HAL_Delay(1);    &#125;    /** LED1 配置 **/    /* LED1 逐渐熄灭 */    for(uint16_t pwmVal=0; pwmVal&lt;1000; pwmVal++)    &#123;        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_3, pwmVal);        HAL_Delay(1);    &#125;    /* LED1 逐渐点亮 */    for(uint16_t pwmVal=1000; pwmVal&gt;0; pwmVal--)    &#123;        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_3, pwmVal);        HAL_Delay(1);    &#125;    /* USER CODE END WHILE */    /* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n编译代码，下载到开发板。例程成功运行。\n\n\n总结Q1：pwmVal 变量的值与 LED 灯亮度的关系？\nA1：当 pwmVal 的值从 0 到 1000 变化时，PWM 波形的占空比会从 0% 逐渐变化到 100%。具体来说，当 pwmVal 为 0 时，PWM 波形的占空比为 0%，即输出为低电平；当 pwmVal 为 1000 时，PWM 波形的占空比为 100%，即输出为高电平。正点原子阿波罗这款开发板的 LED 等是低电平亮、高电平灭，因此，当 pwmVal 的值增加时，占空比增加，高电平增加，亮度变暗。当 pwmVal 的值减小时，占空比减小，低电平增加，亮度变亮。pwmVal 的值与 LED 灯亮度呈反比关系。\n\n\n\npwmVal\n占空比\n高电平\n亮度\n\n\n\n↑\n↑\n↑\n↓\n\n\n↓\n↓\n↓\n↑\n\n\nQ2：【HAL_Delay】函数的作用？ \nA2：【HAL_Delay】函数的作用是产生延时，使程序在逐渐增加或降低 LED 亮度的过程中，能够有足够的时间让人眼观察到亮度变化。如果没有 Delay 函数，LED 的亮度会在很短的时间内逐渐变亮或变暗，人眼很难察觉到亮度变化。延时时间越长，越能充分观察到 LED 亮度的变化。但是如果延时时间过长，则会影响程序的响应速度。另外，建议使用【HAL_Delay】作为延时函数而不是另外写一个，因为这个更准确，可以产生 1ms 延时。如下面这个函数，通过循环计数的方式实现延时，即在一个循环中执行一定的操作，直到计数器减为 0，从而产生一定的延时，但是其单位是 CPU 时钟周期或者是毫秒，就不够准确了，所以还是不要用了。\nvoid Delay(unsigned int t)&#123;    while(t--);&#125; \n\n例程 2：PWM 舵机\n功能实现：①使用 TIM2 中断控制 LED0 的闪烁，用于检测显示程序正在实时运行。②使用 TIM3_CH1 控制 PA6 引脚输出 PWM，控制舵机（SG90 180°）。③使用按键 KEY0 控制 PWM 输出。④使用按键 KEY1 控制 LED1 的亮灭，用于检测显示程序正在实时运行。\n\n步骤\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置[1]配置完成后。将 LED 灯引脚 PB0、PB1 引脚设置为 GPIO_Output，将按键引脚 PH2、PH3 引脚设置为 GPIO_Input，将 PA6 引脚设置为 TIM3_CH1。\n\n\n\n图 3.2 LED 灯、按键、PWM 引脚设置\n\n\n将按键引脚 PH2、PH3 改为上拉（Pull-up）输入。\n\n\n\n图 3.3 按键引脚配置\n\n\n定时器 TIM3 配置。\n\n180° 舵机周期为 20ms，则 ARR &#x3D; 20*103-1。\n\n\n\n\n\n图 3.4 定时器 TIM3_CH1 配置\n\n\n定时器 TIM2 配置。\n\n\n每 200ms 翻转一次 LED0 电平，ARR &#x3D; 200*103-1。\n\n使能中断。\n\n\n\n\n\n\n\n图 3.5 定时器 TIM2 ARR 配置\n\n\n\n图 3.6 定时器 TIM2 中断使能\n\n\n配置完成后生成代码。打开 Keil5 MDK 工程文件，按照 Keil5 MDK 通用配置[1]配置完成后，开始编写代码。\n分步代码：\n① 开启定时器中断和 PWM：打开 main.c 文件。\n-----------------------↓↓↓注：main() 函数内↓↓↓-----------------------  /* USER CODE BEGIN 2 */HAL_TIM_Base_Start_IT(&amp;htim2); //开启定时器中断HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1); //开启 PWM/* USER CODE END 2 */\n\n② 使用定时器 TIM2 中断控制 LED0 的闪烁：打开 main.c 文件。\n-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN 0 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;\t/* TIM2--LED0 每 20ms 翻转一次电平 */\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);&#125;/* USER CODE END 0 */\n\n③ KEY1 控制 LED1 亮灭：打开main.c 文件。\n-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN 0 *//* 宏定义 KEY0、KEY1 */# define KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)# define KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)void Scan_Keys()&#123;\t/* KEY1--LED1 按下控制亮灭 */\tif(KEY1 == 0)\t&#123;\t\tHAL_Delay(200); //延时函数去抖动\t\tif(KEY1 == 0)\t\t&#123;\t\t\tHAL_GPIO_TogglePin(GPIOB,GPIO_PIN_0);\t\t\twhile(KEY1 == 0);\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */-----------------------↓↓↓注：main() 函数内↓↓↓-----------------------   /* USER CODE BEGIN WHILE */while (1)&#123;    Scan_Keys();/* USER CODE END WHILE */     /* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n④ KEY0 控制 PWM 输出：打开 main.c 文件。\n-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN 0 *//* 宏定义 KEY0、KEY1 */# define KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)# define KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)void Scan_Keys()&#123;\t/* KEY0--PWM 按下控制舵机旋转 90° */\tif(KEY0 == 0)\t&#123;\t\tHAL_Delay(200); //延时函数去抖动\t\tif(KEY0 == 0)\t\t&#123;            /* 运行逻辑：开始舵机在 0° 位置，1500 表示转到 90°，500 表示转到 0°，此处代码的意思是按下 KEY0，舵机由初始位置 0° 旋转到 90°，然后再回到初始位置 0° */            __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, 1500);\t\t\tHAL_Delay(1000); // 延时 1s，为了让舵机旋转到 90° 时停一下再旋转\t\t\t__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, 500);\t\t\twhile(KEY0 == 0);\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */-----------------------\n\n完整代码\n-----------------------↓↓↓注：main() 函数外↓↓↓-----------------------  /* USER CODE BEGIN 0 */# define KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)# define KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2) /* TIM2 中断回调函数：控制 LED0 闪烁 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;\t/* TIM2--LED0 每 20ms 翻转一次电平 */\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);&#125;/* 功能函数：扫描按键 */void Scan_Keys()&#123;\t/* KEY0--PWM 按下控制舵机旋转 90° */\tif(KEY0 == 0)\t&#123;\t\tHAL_Delay(100); //延时函数去抖动\t\tif(KEY0 == 0)\t\t&#123;\t\t\t/* 运行逻辑：开始舵机在 0° 位置，1500 表示转到 90°，500 表示转到 0°，此处代码的意思是按下 KEY0，舵机由初始位置 0° 旋转到 90°，然后再回到初始位置 0° */\t\t\t__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, 1500);\t\t\tHAL_Delay(1000); // 延时 1s，为了让舵机旋转到 90° 时停一下再旋转\t\t\t__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_1, 500);\t\t\twhile(KEY0 == 0);\t\t&#125;\t&#125;\t\t/* KEY1--LED1 按下控制亮灭 */\tif(KEY1 == 0)\t&#123;\t\tHAL_Delay(200); //延时函数去抖动\t\tif(KEY1 == 0)\t\t&#123;\t\t\tHAL_GPIO_TogglePin(GPIOB,GPIO_PIN_0);\t\t\twhile(KEY1 == 0);\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */-----------------------↓↓↓注：main() 函数内↓↓↓----------------------- /* USER CODE BEGIN 2 */HAL_TIM_Base_Start_IT(&amp;htim2); //开启定时器中断HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_1); //开启 PWM/* USER CODE END 2 *//* USER CODE BEGIN WHILE */while (1)&#123;    Scan_Keys();/* USER CODE END WHILE *//* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n编译代码，下载到开发板。例程成功运行，各功能均已实现。\n\n\n总结参考[1] 成为点灯大师 LED Master | Story Begins…… \n[2] STM32 HAL 库实现舵机旋转 | Story Begins…… \n","categories":["STM32"],"tags":["PWM"]},{"title":"STM32 HAL 库实现串口通信","url":"/2023/04/10/056-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/","content":"引脚定义在 STM32F429IGT6 这块开发板中：\n\nUSART1_TX 与 PA9 复用，USART1_RX 与 PA10 复用。\nUSART2_TX 与 PA2 复用，USART2_RX 与 PA3 复用。\nUSART3_TX 与 PB10 复用，USART3_RX 与 PB11 复用。\n\nHAL 库串口发送重要函数\n阻塞式发送函数（新手推荐使用）\n阻塞式发送函数是指在向设备发送数据时，函数会一直阻塞（即一直等待）直到数据发送完毕后才返回。在这种发送方式下，发送函数会一直等待直到发送缓冲区中的数据全部被发送出去，才会返回函数执行结果。\nHAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, unit32_t Timeout);/* 参数解释 */句柄（哪个外设），指针，数据长度，超时时间\n\n非阻塞式发送函数（不推荐使用）\n非阻塞式发送函数是指在向设备发送数据时，不会一直等待数据全部发送完毕后才返回，而是在发送数据时，将数据放入发送缓冲区中，然后立即返回函数执行结果，继续执行后续代码。这种方式下，发送函数不会阻塞当前线程或任务，可以提高系统的实时性和响应能力。但是，需要在发送函数中添加相应的错误处理机制，以避免因为发送过程中出现错误导致数据未发送完成的问题。\nHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);/* 可以看到这个函数里面多了 IT（interrupt 中断），且没有了 Timeout（超时）参数 */\n\n发送完毕中断回调函数\n发送完毕中断回调函数指的是当使用 UART 或者其他通信方式向外部设备发送数据时，当数据全部发送完毕后，会产生一个发送完成中断（或称为发送完毕中断）。这个中断是外部设备向处理器发送的一种通知，用于告诉处理器数据已经全部发送完成，可以进行其他操作了。当发送完成中断触发时，可以通过调用对应的中断回调函数来处理这个中断事件。中断回调函数是在中断服务程序之后执行的一种特殊函数，它负责处理中断服务程序中未处理完的任务。\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart);\n\n举个🌰1要求：使用（非）阻塞式的串口发送函数，将发送缓存数组 dat_Txd 中的前 5 个数据发送到 USART1，在数据发送完成后，翻转 PB1（LED0）引脚的输出电平。\n代码：\n/* 使用非阻塞式串口 1 发送函数 */HAL_UART_Transmit_IT(&amp;huart1, dat_Txd, 5); //因为 dat_Txd 是数组，前面不用加 &amp;（取地址符号）/* 发送完成后，使用中断回调函数来控制 LED0 */void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);&#123;    if(huart-&gt;Instance == USART1)    &#123;        HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);    &#125;&#125;---------------------------------------------------------/* 使用阻塞式串口 1 发送函数 */HAL_UART_Transmit(&amp;huart1, dat_Txd, 5, 10000);/* 发送完成后，直接使用 Toggle 控制 LED0 */HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);\n\nHAL 库串口接收重要函数\n阻塞式接收函数（不推荐使用）\n阻塞式接收函数是指在从设备接收数据时，函数会一直阻塞（即一直等待）直到接收到完整的数据后才返回。在这种接收方式下，接收函数会一直等待直到接收缓冲区中的数据长度达到预定长度，或者接收超时时间到达后才返回函数执行结果。如果接收数据长度过短或者接收速率过慢，会导致阻塞时间较长，从而影响系统的实时性和响应性能。\nHAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, unit32_t Timeout);/* 参数解释 */句柄（哪个外设），指针，数据长度，超时时间\n\n非阻塞式接收函数（推荐使用）\n非阻塞式接收函数是指在从设备接收数据时，不会一直等待数据接收完成后才返回，而是在接收数据时，将接收到的数据存入接收缓冲区中，然后立即返回函数执行结果，继续执行后续代码。这种方式下，接收函数不会阻塞当前线程或任务，可以提高系统的实时性和响应能力。但是，需要在接收函数中添加相应的错误处理机制，以避免因为接收过程中出现错误导致数据未接收完成的问题。\nHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);/* 可以看到这个函数里面多了 IT（interrupt 中断），且没有了 Timeout（超时）参数 */\n\n接收完毕中断回调函数\n接收完毕中断回调函数指的是当使用UART或者其他通信方式接收到完整的数据后，会产生一个接收完成中断（或称为接收完毕中断）。这个中断是外部设备向处理器发送的一种通知，用于告诉处理器数据已经接收完成，可以进行其他操作了。当接收完成中断触发时，可以通过调用对应的中断回调函数来处理这个中断事件。中断回调函数是在中断服务程序之后执行的一种特殊函数，它负责处理中断服务程序中未处理完的任务。\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart);\n\n举个🌰2要求：使用非阻塞式的串口接收函数，接收USART1中的一个字节，将其保存在 dat_Rxd 变量中，在数据发送完成后，若该字节为 0x5A，则翻转 PB0（LED1） 引脚的输出电平。\n代码：\n/* 使用非阻塞式串口 1 发送函数 */HAL_UART_Receive_IT(&amp;huart1, &amp;dat_Rxd, 1);//因为 dat_Rxd 是地址，前面需要加 &amp;（取地址符号）/* 接收完成后，使用中断回调函数来控制 LED1 */void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);&#123;    if(huart-&gt;Instance == USART1)    &#123;        if(dat_Rxd == 0x5A)        &#123;            HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);        &#125;    &#125;&#125;\n\n例程 1：通过串口通信开关灯要求：在 STM32F429IGT6 中进行 STM32 应用开发，完成以下功能。\n\n开机后，向串口 1 发送”Hello World!”。\n串口 1 收到字节指令”0xA1”，打开 LED0（PB1），发送”LED0 Opened!”。\n串口 1 收到字节指令”0xA2”，关闭 LED0（PB0），发送”LED0 Closed!”。\n在串口发送过程中，打开 LED1 作为发送数据指示灯。\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置[1]配置完成后。将 PB0、PB1 引脚分别设置为 GPIO_Out。接着配置 USART1 的模式、参数及使能中断，如图所示：\n\n\n\n图 4.1 串口 USART1 配置\n\n\n\n图 4.2 使能 USART1 中断\n\n\n进行 STM32CubeMX 通用配置 [1]的第 5 步：生成代码。\n\n打开工程文件。按照 Keil5 MDK 通用配置 [1]完成后开始编写代码。\n\n打开 usart1.c 文件，可以看到 huart1 的配置。\n\n\n图 4.3 USART1 的代码初始化\n\n打开 main.c 文件。\n-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN 0 *//* 宏定义 LED0、LED1 亮灭 */#define LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);#define LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);/* 首先定义了无符号 8 位整数型（unsigned 8-bit integer）数组的语句，常用于表示一串 ASCII 字符。其中，Tx_str1 是数组的名称，方括号中没有指定数组长度，因此该数组长度将根据初始化时赋值的元素个数进行确定 */uint8_t Tx_str1[] = &quot;Hello World!\\r\\n&quot;; // \\r：回车，\\n：换行uint8_t Tx_str2[] = &quot;LED1 Opened!\\r\\n&quot;;uint8_t Tx_str3[] = &quot;LED1 Closed!\\r\\n&quot;;/* 定义了一个无符号8位整数型（unsigned 8-bit integer）变量,通常用于存储通过UART接收到的单个字节数据，每次接收完成后将数据存储到该变量中 */uint8_t Rx_dat = 0;/* 中断回调函数, 在这里面实现接收到指令后的功能*/void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;\tif(huart-&gt;Instance == USART1)\t&#123;\t\tif(Rx_dat == 0xa1)\t\t&#123;\t\t\tLED0_ON();\t\t\t            /* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */\t\t\tLED1_OFF();\t\t\tHAL_Delay(200);\t\t\tHAL_UART_Transmit(&amp;huart1, Tx_str2, sizeof(Tx_str2), 10000);\t\t\tHAL_Delay(200);\t\t\tLED1_ON();\t\t\t\t\t\tHAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);\t\t&#125;\t\telse if(Rx_dat == 0xa2)\t\t&#123;\t\t\tLED0_OFF();\t\t\t            /* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */\t\t\tLED1_OFF();\t\t\tHAL_Delay(200);\t\t\tHAL_UART_Transmit(&amp;huart1, Tx_str3, sizeof(Tx_str3), 10000);\t\t\tHAL_Delay(200);\t\t\tLED1_ON();\t\t\t\t\t\tHAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */-----------------------↓↓↓注：main() 函数内↓↓↓----------------------- /* USER CODE BEGIN 2 *//* 功能 1：开机后向串口 1 发送 “Hello World!” *//* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */LED1_OFF();HAL_Delay(200); //加入延时函数，以便肉眼观察得到HAL_UART_Transmit(&amp;huart1, Tx_str1, sizeof(Tx_str1), 10000);HAL_Delay(200); //加入延时函数，以便肉眼观察得到LED1_ON();/* 功能 2、3：接收串口发来的数据” *//* &amp;huart1 表示指向 UART1 外设的指针，&amp;Rx_dat 表示指向存储接收数据的缓冲区的指针， 1 表示要接收的数据长度 */HAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);/* USER CODE END 2 */  \n\n\n串口调试助手操作要点\n\nMicroUSB 接口要接到板子的左下角第二个口，写着 USB_232。才会显示 COM4：USB-SERIAL。COM3 不能用于串口调试。\n波特率要和 CubeMX 中设置的一致。\n在发送框中输入程序中所写的字符串，然后选择 16 进制发送。\n\n\n\n\n\n\n图 4.4 功能实现\n\n例程 2：定时器与串口综合训练要求：在 STM32F429IGT6 中进行 STM32 应用开发，完成以下的功能。\n\n开机后，LED0 与 LED1 依次点亮，然后熄灭，进行灯光检测。\n\n系统通过串口 1 向上位机发送一个字符串”STM32F429 欢迎您！”。\n\nLED0 作为一个秒闪灯，系统向上位机发送完字符串后，开始亮 0.5 秒，灭 0.5 秒……循环闪烁，并开始启动系统运行时间的记录，其时分秒格式为”XX:XX:XX”。\n\n上位机通过一个由 3 个字节组成的命令帧控制 LED1 灯的开关。该命令帧的格式为”0xBF 控制字 OxFB”。0xBF 为帧头，0xFB 为帧尾，控制字的定义如下：\n0xA1：打开 LED1，返回信息”XX:XX:XX LED1 打开”。\n0xA2：关闭 LED1，返回信息”XX:XX:XX LED1 关闭”。\n其他：返回信息”XX:XX:XX 这是一个错误指令!”。\n\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置[1]配置完成后。将 PB0、PB1 引脚分别设置为 GPIO_Out。接着配置定时器 TIM2、串口 USART1，最后中断使能，如图所示：\n\n\n\n图 5.1 LED 灯引脚设置\n\n\n\n图 5.2 定时器 TIM2 配置\n\n\n\n图 5.3 串口 USART1 配置\n\n\n\n图 5.4 中断使能\n\n\n进行 STM32CubeMX 通用配置 [1]的第 5 步：生成代码。\n\n打开工程文件。按照 Keil5 MDK 通用配置 [1]完成后开始编写代码。\n-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN Includes */#include &quot;stdio.h&quot;/* USER CODE END Includes *//* USER CODE BEGIN 0 */    /* 第一步：宏定义 LED 灯，方便后续代码易读 */#define LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET)#define LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET)#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET)#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET)#define LED0_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1)#define LED1_TOG() HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0)    /* 第二步：定义所要用到的字符串 */uint8_t str1[] = &quot;= = = = = = = Welcome to Xiaoma&#x27;s codes = = = = = = =\\r\\n&quot;; //开机显示uint8_t hh = 0, mm = 0, ss = 0, ss05 = 0; //定义时分秒，以及 0.5suint8_t str_buff[64]; //定义一个字符串的缓冲数组，64 个字节uint8_t Rx_dat[16]; //定义一个串口接收的数组/* 第三步-1：功能函数：灯光检测 *//* 跑马灯，LED0、LED1 轮流灭亮 */void Check_LED()&#123;\tHAL_Delay(1000);\t\tLED0_OFF();\tHAL_Delay(500);\tLED1_OFF();\tHAL_Delay(500);\t\tLED0_ON();\tHAL_Delay(500);\tLED1_ON();\tHAL_Delay(500);&#125;/* 第五步-2：重写定时器 TIM2 的中断回调函数，使 LED0 按 0.5s 间隔闪烁，0.5 是在 CubeMX 中设置好的 500ms 产生一次中断 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;\tLED0_TOG();\t    /* 把时间变化记录到字符串时分秒中 */    /* 逻辑：当记录两次 ss05，则 ss05 清零，记录 1s；当记录 60 次 ss，则 ss 清零，记录 1min；当记录 60 次 1min，则 mm 清零，记录 1h。依此循环*/\tss05++;\tif(ss05 == 2)\t&#123;\t\tss05 = 0;\t\tss++;\t\tif(ss == 60)\t\t&#123;\t\t\tss = 0;\t\t\tmm++;\t\t\tif(mm == 60)\t\t\t&#123;\t\t\t\tmm = 0;\t\t\t\thh++;\t\t\t&#125;\t\t&#125;\t&#125;&#125;/* 第六步-2：重写非阻塞式接收字符串的中断回调函数 */void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;    /* 判断串口是否为 USART1 */\tif(huart-&gt;Instance == USART1)\t&#123;        /* 判断第一个字符是否为 BF 并且第三个字符是否为 FB */\t\tif(Rx_dat[0] == 0xBF &amp;&amp; Rx_dat[2] == 0xFB)\t\t&#123;            /* 使用 switch：case/break 来判断第二个字符是什么，共有三组判断 */            /* 此处也可以使用 if/else 来判断，但使用 switch 使代码更整洁 */\t\t\tswitch(Rx_dat[1])\t\t\t&#123;                /* 接收到 a1 时，则 LED1 关闭 */\t\t\t\tcase 0xa1:\t\t\t\t\tLED1_OFF();                    /* 要想使用 sprintf() 函数，需引入头文件 #include &quot;stdio.h&quot; */                    /* %d 是占位符，在双引号的后面写对应的参数 */                    /* 开头定义 str_buff 为无符号 8 位整型（uint8_t)，此处使用 (char *) 转化为字符型指针，因为 sprintf() 函数需要的参数是字符型指针*/\t\t\t\t\tsprintf((char *)str_buff, &quot;%d:%d:%d    LED1 关闭!\\r\\n&quot;, hh, mm, ss);\t\t\t\tbreak;\t\t\t\t                /* 接收到 a1 时，则 LED1 关闭 */\t\t\t\tcase 0xa2:\t\t\t\t\tLED1_ON();\t\t\t\t\tsprintf((char *)str_buff, &quot;%d:%d:%d    LED2 打开!\\r\\n&quot;, hh, mm, ss);\t\t\t\tbreak;\t\t\t\t\t\t\t\tdefault:\t\t\t\t\tsprintf((char *)str_buff, &quot;%d:%d:%d    这是一个错误的命令!\\r\\n&quot;, hh, mm, ss);\t\t\t\tbreak;\t\t\t&#125;            /* 向串口发送缓冲区 str_buff 字符串 */\t\t\tHAL_UART_Transmit(&amp;huart1, str_buff, sizeof(str_buff), 10000);            /* 补一个接收中断函数，因为还要继续接收串口调试助手发来的字符串，同例程 1*/\t\t\tHAL_UART_Receive_IT(&amp;huart1, Rx_dat, 3);\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN 2 *//* 第三步-2：灯光检测功能运行 */Check_LED();/* 第四步：发送 str1 到串口调试助手*/HAL_UART_Transmit(&amp;huart1, str1, sizeof(str1), 10000); //阻塞式发送/* 第五步-1：启动定时器 TIM2 中断 *//* 此函数在 main.c 关联的 stm32f4xx_hal_tim.h 文件的最下面可以找到 */HAL_TIM_Base_Start_IT(&amp;htim2);/* 第六步-1：采用非阻塞式接收字符串 *//* 接收到的字节放到 Rx_dat，当接收到完整的三个字节后，进入串口接收完成中断，然后调用它的回调函数 */HAL_UART_Receive_IT(&amp;huart1, Rx_dat, 3);/* USER CODE END 2 */   \n\n\n\n图 5.5 串口调试助手功能实现\n\n参考[1] 成为点灯大师 LED Master | Story Begins……\n","categories":["STM32"],"tags":["TIM","USART"]},{"title":"STM32 HAL 库实现 ADC 采样","url":"/2023/04/11/057-STM32-HAL-%E5%BA%93%E5%AE%9E%E7%8E%B0-ADC-%E9%87%87%E6%A0%B7/","content":"例程 1：ADC 单次数据采样与电压换算要求：在 STM32F429IGTx 中进行 STM32 应用开发，完成以下的功能。\n\n将 ADC_IN0 设置为 12 位 ADC，右对齐，启用中断。\n分别用查询和中断这 2 种方式，每隔 0.5 秒采样一次 ADC 数据。\n将每次读取到的 ADC 采样值转换为对应的电压值，发送到上位机（需用到串口）。\nLED1 作为采样指示灯，在 ADC 转换过程中点亮，其余时间熄灭。LED0 作为系统检测灯常亮。\n\n【注】配置 GPIO、ADC1、USART1。\n\nGPIO 比较好配置，就 LED0、LED1 的引脚设为 Output。\n配置 ADC1，PA0 设为 ADC1_IN0，然后勾选 IN0。参数设置模块的 Data Alignment 默认 Right alignment（右对齐）即可，同样其他都默认，NVIC 中断使能勾选。\n配置 USART1，Mode 选 Asynchronous（异步），参数设置模块波特率改为 9600 Bits&#x2F;s，其他默认。由于串口没有用到中断，所以 NVIC 模块不需要使能。\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置[1]配置完成后。将 PB0、PB1 引脚分别设置为 GPIO_Out。如图所示：\n\n\n\n图 1.1 LED 灯引脚配置\n\n\n配置 ADC。将 PA0 引脚设置为 ADC1_IN0，然后勾选 ADC1→IN0。如图所示：\n\n\n\n图 1.2 ADC1 引脚、参数配置\n\n\n图 1.3 ADC1 中断使能\n\n\n配置串口 USART1。选择异步通信，波特率设置为 9600。配置完成后，PA9、PA10 引脚会自动变成绿色。由于本要求中只写了将每次读取到的 ADC 采样值转换为对应的电压值，发送到上位机，且在代码中使用阻塞式发送，因此就没有必要开启中断了。\n\n\n图 1.4 USART1 配置\n\n\n进行 STM32CubeMX 通用配置 [1]的第 5 步：生成代码。\n\n打开工程文件。按照 Keil5 MDK 通用配置 [1]完成后开始编写代码。\n打开 main.c 文件。\n方式 1：查询\n-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN 0 */    /* 第一步：引入头文件，以使用 sprintf() 函数 */#include &quot;stdio.h&quot;     /* 第二步：宏定义 LED 灯开关 */    #define LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);#define LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);/* 第三步-1：定义变量。采样到数据存储在 ADC_Value 中，ADC_Volt 用于运算 *//* 第三步-2：定义 str_buff[64]，用于向上位机发送数据，用在 sprintf() 函数中 */uint16_t ADC_Value = 0, ADC_Volt = 0;uint8_t str_buff[64];/* 第五步：写发送数据到上位机的功能函数 */void UR1_Send_Info()&#123;    /* 将电压值取余，分别放到个位和小数位上 */    sprintf((char *)str_buff, &quot;采样值：%d，电压值：%d.%d%d%dv\\r\\n&quot;, ADC_Value, ADC_Volt/1000, (ADC_Volt%1000)/100, (ADC_Volt%100)/10, ADC_Volt%10);    /* 阻塞式串口发送函数，将缓冲数组 str_buff 发送到上位机，显示在串口调试助手中 */\tHAL_UART_Transmit(&amp;huart1, str_buff, sizeof(str_buff), 10000);&#125;/* 第四步-1：查询方式 *//* 功能函数：采样数据（写完后放在 main() 函数中运行 */void ADC1_Get_Value()&#123;\tHAL_ADC_Start(&amp;hadc1); //启动 ADC1\tLED1_OFF(); //关闭 LED1，表示 ADC 开始转换    \t/* 判断查询转换函数，如果确实是在转换（HAL_OK），则读 ADC1 的值 */\tif(HAL_ADC_PollForConversion(&amp;hadc1, 10) == HAL_OK)\t&#123;\t\tADC_Value = HAL_ADC_GetValue(&amp;hadc1); //得到 ADC1 的值\t\tADC_Volt = ADC_Value * 3300 / 4096; //计算电压值的转换公式，3300mv = 3.3v，4096 是 2 的 12 次方，因为是 12 位的 ADC\t&#125;\t\tUR1_Send_Info(); //在上面写此功能函数，一定要写在上面。或者写在下面，但是一定要在上面声明\tLED1_ON(); //开启 LED1，表示 ADC 转换完成\t\tHAL_ADC_Stop(&amp;hadc1); //关闭 ADC1&#125;/* USER CODE END 0 */-----------------------↓↓↓注：main() 函数内↓↓↓----------------------- /* USER CODE BEGIN WHILE */while (1)&#123;    /*第四步-2，运行该采样功能函数*/    ADC1_Get_Value();    HAL_Delay(500);/* USER CODE END WHILE *//* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n方式 2：中断\n-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN 0 */    /* 第一步：引入头文件，以使用 sprintf() 函数 */#include &quot;stdio.h&quot;     /* 第二步：宏定义 LED 灯开关 */    #define LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);#define LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);/* 第三步-1：定义变量。采样到数据存储在 ADC_Value 中，ADC_Volt 用于运算 *//* 第三步-2：定义 str_buff[64]，用于向上位机发送数据，用在 sprintf() 函数中 */uint16_t ADC_Value = 0, ADC_Volt = 0;uint8_t str_buff[64];/* 第五步：写发送数据到上位机的功能函数 */void UR1_Send_Info()&#123;    /* 将电压值取余，分别放到个位和小数位上 */    sprintf((char *)str_buff, &quot;采样值：%d，电压值：%d.%d%d%dv\\r\\n&quot;, ADC_Value, ADC_Volt/1000, (ADC_Volt%1000)/100, (ADC_Volt%100)/10, ADC_Volt%10);    /* 阻塞式串口发送函数，将缓冲数组 str_buff 发送到上位机，显示在串口调试助手中 */\tHAL_UART_Transmit(&amp;huart1, str_buff, sizeof(str_buff), 10000);&#125;/* 第四步-1：重写 ADC 中断回调函数 */void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)&#123;\tif(hadc-&gt;Instance == ADC1) //如果有多个 ADC，就要先用 if 来判断是不是 ADC1\t&#123;\t\tADC_Value = HAL_ADC_GetValue(&amp;hadc1); //得到 ADC1 的采样值\t\tADC_Volt = ADC_Value * 3300 / 4096; //转换为电压，3300mv = 3.3v，4096 是 2 的 12 次方，因为是 12 位的 ADC\t\tUR1_Send_Info(); //发送函数，写在了上面\t\tLED1_ON(); //因为在主函数中，LED1 先灭掉了，才启动的中断服务函数\t&#125;&#125;/* USER CODE END 0 */-----------------------↓↓↓注：main() 函数内↓↓↓----------------------- /* USER CODE BEGIN WHILE */while (1)&#123;    /*第四步-2，运行该采样功能函数*/    LED1_OFF(); //中断启动前关掉 LED1    HAL_ADC_Start_IT(&amp;hadc1); //以中断方式启动 ADC1    HAL_Delay(500); //延时 0.5s，然后运行中断回调函数里面的内容（最后一句：LED1 开启）    HAL_ADC_Stop_IT(&amp;hadc1);   //运行完后关闭 ADC1，然后继续循环    /* USER CODE END WHILE */\t/* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n\n\n图 1.5 串口调试助手接收到的采样数值\n","categories":["STM32"],"tags":["HAL","ADC"]},{"title":"成为点灯大师 LEDMaster","url":"/2023/04/11/058-%E6%88%90%E4%B8%BA%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88-LEDMaster/","content":"孔乙己说回字有四种写法，而使用 STM32 点灯可不止有四种方式。本文利用 STM32F429IGT6 + STM32CubeMX + Keil5，通过各种外设，实现多种点灯方式。\n\n本系列代码均已开源至 Github，欢迎 Fork&amp;Star。\n\n例程 1：使用 GPIO 点灯要求：利用 STM32CubeMX 和 Keil5 MDK 进行 STM32 应用开发，完成以下功能。\n\n实现 LED0、LED1 闪烁。\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置 [1]创建工程、后。在可视化界面的搜索框中输入 PB1，即可快速定位到引脚位置。\n\n\n\n图 1.1 引脚位置\n\n\n点击该引脚，可以看到多个选项，选择 GPIO_Output。PB0 与 PB 1 两个引脚都选上，使用中的引脚会变成绿色。\n\n\n\n图 1.2 LED 灯引脚配置\n\n\n生成代码。\n\n按路径打开工程文件。按照 Keil5 MDK 通用配置 [1]完成后开始编写代码。\n打开 main.c 文件。\n/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123;    /* LED1 配置 */    /* 输入低电平，点亮 LED1 */    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);    HAL_Delay(200);    /* 输入高电平，熄灭 LED1 */    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);    HAL_Delay(200);    /* LED0 配置 */    /* 翻转电平，使 LED0 闪烁*/    HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);    HAL_Delay(200);          /* USER CODE END WHILE */    /* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n下载程序。\n\n\n例程 2：使用按键点灯要求：利用 STM32CubeMX 和 Keil5 MDK 进行 STM32 应用开发，完成以下功能：\n\n按下 KEY0（PH3）按键，松开后，切换 LED0（PB1）的开关状态。\n按下 KEY1（PH2）按键，切换 LED1（PB0）的开关状态。\n按下 KEY2（PC13）按键，把点亮的 LED 灯全部关闭。\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置[1]完成后。将 PB0、PB1 引脚设置为 GPIO_Output，将 PH3、PH2、PC13 引脚设置为 GPIO_Input。\n\n\n\n\n\n\n\n\n\n\n图 2.1 LED 灯与按键引脚配置\n\n\n将 PH3、PH2、PC13 的 GPIO 都改为上拉（Pull-up）。（注：将GPIO口设置为上拉输入模式，意思是当GPIO口没有外部信号输入时，将其上拉到高电平（即VCC电源电压）状态，从而避免GPIO口悬浮，导致输入不稳定或产生噪声。）\n\n\n\n图 2.2 GPIO 引脚配置\n\n\n生成代码。\n\n打开工程文件。按照 Keil5 MDK 通用配置 完成后开始编写代码。\n① 打开 main.c 文件。\n/* USER CODE BEGIN 0 *//* HAL_Delay() 经常会导致程序卡死，自己写一个延时函数 */void Delay(unsigned int t)&#123;\twhile(t--);&#125;/* 功能函数：扫描按键 */void Scan_Keys()&#123;    /* 配置 KEY0--LED0*/    /* 原理：由于将按键引脚全部配置为上拉，所以按下时会产生低电平(RESET)，检测到低电平执行下面程序 */    if(HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3) == GPIO_PIN_RESET)    &#123;        Delay(1000); //去抖动，防止误触        if(HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3) == GPIO_PIN_RESET)        &#123;            /* while() 是为了保证按下后进入循环，直到松开，程序才会向下执行，即松开后切换 LED0 的状态 */            while(HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3) == GPIO_PIN_RESET);            HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_1);        &#125;    &#125;&#125;/* USER CODE END 0 */\n\n② 在 main 函数中执行 Scan_Keys 功能。\n/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123;    Scan_Keys();    /* USER CODE END WHILE */    /* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n\n宏定义：当执行到 KEY0 时，就会去找到 KEY0 的定义并执行。\n# define KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)\n\n/* GPIO_PIN_RESET 已经被定义好了为 0，相应的 GPIO_PIN_SET = 1。 *//* 右键点击 GPIO_PIN_RESET，选择 Go To Definition of &#x27;GPIO_PIN_RESET&#x27; 可以看到源码如下: */typedef enum&#123;   GPIO_PIN_RESET = 0,   GPIO_PIN_SET&#125;GPIO_PinState;\n\n（补充知识）可以在 gpio.c 文件中通过结构体来配置引脚。\n\n① 完整代码。延时程序和扫描按键功能：\n/* USER CODE BEGIN 0 */# define KEY0 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_3)# define KEY1 HAL_GPIO_ReadPin(GPIOH,GPIO_PIN_2)# define KEY2 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_13)/* HAL_Delay() 经常会导致程序卡死，自己写一个延时函数 */void Delay(unsigned int t)&#123;\twhile(t--);&#125;/* 功能函数：扫描按键 */void Scan_Keys()&#123;    /* 原理：由于将按键引脚全部配置为上拉，所以按下时会产生低电平(RESET)，检测到低电平执行下面程序 */    /* 配置 KEY0--LED0*/    if(KEY0 == 0)    &#123;        Delay(1000); //去抖动，防止误触        if(KEY0 == 0)        &#123;            /* while() 是为了保证按下并抬起只执行一次程序，如果一直按着，那么就一直都是低电平，程序就不会向下执行 */            while(KEY0 == 0);            HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_1);        &#125;    &#125;    /* 配置 KEY1--LED1*/    if(KEY1 == 0)    &#123;        Delay(1000); //去抖动，防止误触        if(KEY1 == 0)        &#123;            HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_0);            while(KEY1 == 0);        &#125;    &#125;    /* 配置 KEY3--LED0|LED1 */    if(KEY2 == 0)    &#123;        Delay(1000); //去抖动，防止误触        if(KEY2 == 0)        &#123;            HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1, 1);            while(KEY2 == 0);        &#125;    &#125;&#125;/* USER CODE END 0 */\n\n② 在 main 函数的 while 中实现扫描按键功能。\n/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123;    Scan_Keys();    /* USER CODE END WHILE */    /* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n下载程序。\n\n\n例程 3：使用外部中断点灯要求：利用 STM32CubeMX 和 Keil5 进行 STM32 应用开发，完成以下功能：\n\n将 KEY0（PH3） 设置为外部中断输入，下降沿触发。在中断服务函数中，切换 LED0（PB1）的开关状态。\n将 KEY1（PH2） 设置为外部中断输入，上升沿触发。在中断服务函数中，切换 LED1（PB0） 的开关状态。\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置 完成后。将 PB0、PB1 引脚设置为 GPIO_Output，将 PH3、PH2 引脚设置为 GPIO_EXTI3。\n\n\n\n\n\n\n\n\n\n图 3.1 LED 灯与按键引脚配置\n\n\n在 GPIO 中将 PH2、PH3 的配置都改为上拉（Pull-up）。同时，PH3 的 GPIO mode 改为外部中断下降沿触发，PH2 的 GPIO mode 改为外部中断上升沿触发。（注：上升沿触发指的是当外部中断引脚输入的信号由低电平变为高电平时，触发中断事件；而下降沿触发则指的是当外部中断引脚输入的信号由高电平变为低电平时，触发中断事件。）\n\n\n\n图 3.2 按键引脚中断配置\n\n\n使能中断。\n\n\n\n图 3.3 使能中断配置\n\n\n生成代码。\n\n打开工程文件。按照 Keil5 MDK 通用配置 完成后开始编写代码。\n\n了解代码结构。\n\n打开 main.c 文件，其【main()】函数中，有【MX_GPIO_Init()】语句，表示 GPIO 的初始化，右键点进它的定义。来到 gpio.c 文件，在【MX_GPIO_Init()】函数中可以看到 EXTI interrupt init。\nHAL_NVIC_SetPriority(EXTI2_IRQn, 0, 0); //第一行：设置优先级HAL_NVIC_EnableIRQ(EXTI2_IRQn); //第二行：使能\n\n打开 stm32f4xx_it.c 文件，拉到最下面，可以看到 PH2、PH3 的中断服务函数【HAL_GPIO_EXTI_IRQHandler()】，右键点进它的定义，来到 stm32f4xx_hal_gpio.c 文件，可以看到在中断服务函数里面，有一个【HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)】函数，右键点进它的定义，来到下面的虚函数【__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)】，可以看到里面什么都没有做，需要重写它。一般将其拷到 main.c 文件中重写。\n\n\n\n打开 main.c 文件。\n/* USER CODE BEGIN 0 */void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)&#123;\t/* KEY0--LED0 配置 */\t/* 判断传进来的引脚是否为 PH3 */\tif(GPIO_Pin == GPIO_PIN_3)\t&#123;\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);\t&#125;        /* KEY1--LED1 配置 */\t/* 判断传进来的引脚是否为 PH2 */\tif(GPIO_Pin == GPIO_PIN_2)\t&#123;\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);\t&#125;&#125;/* USER CODE END 0 */\n\n掌握调试技巧\n\n加断点。在 stm32f4xx_it.c 文件中的【HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3)】前面加上断点。因为我们重写了虚函数，中断响应后，会首先来到这个函数。\n进入调试模式。①全速运行。②按下 KEY0 按键，可以看到代码运行到了函数【HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3)】这里。\n\n\n\n图 3.4 调试步骤-1\n\n\n选择单步走，可以看到现在进入了 stm32f4xx_hal_gpio.c 文件中的【HAL_GPIO_EXTI_IRQHandler()】函数中的 if 语句。\n\n\n\n图 3.5 调试步骤-2\n\n\n继续单步走。当执行【HAL_GPIO_EXTI_Callback()】回调函数时，进入到了 main.c 文件中。然后继续执行，发现 LED0 发生翻转。\n\n\n\n图 3.6 调试步骤-3\n\n\n下载程序。\n\n\n例程 4：使用定时器中断点灯要求：在 STM32F429 进行 STM32 应用开发，完成以下功能：\n\n利用 TIM2 实现间隔定时，每隔 0.2s 将 LED0（PB1）的开关状态翻转。\n\n利用 TIM3 实现间隔定时，每隔 1s 将 LED1（PB0）的开关状态翻转。\n\n\n\n计算公式：定时器发生中断的时间\n定时时间 &#x3D; （PSC + 1）*（ARR + 1）&#x2F; 定时器时钟频率\n\nPSC：Prescaler，预分频器\nARR：重装载值，写在 Counter Period 中。\n\n练习题：时钟信号频率 1KHz，PSC &#x3D; 9，ARR &#x3D; 999，求定时时间。\n\n9 的意思是预分频器接收 10 个脉冲就会溢出。如下图，一个脉冲 1ms，PSC 每接收到 10 个脉冲，也就是 10ms，传给主计数器一次。\n\n999 的意思是主计数器的最大计数值为 1000。如下图，PSC 传给主机数器一个脉冲是 10ms，主计数器一共能接收 1000 个，也就是 10000ms &#x3D; 10s，然后传给内核。\n\n综上所述，此处是每 10s 产生一次中断。\n\n\n\n\n图 4.1 计算过程\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置 完成后，操作通用计时器 TIM2、TIM3。\n\n计算：时钟频率为 84MHz，\n\nTIM2：$ \\frac{8400\\times2\\times10^3}{84\\times10^6}&#x3D;0.2s&#x3D;200ms $\nTIM3：$ \\frac{8400\\times1\\times10^4}{84\\times10^6}&#x3D;1s $\n\n\n\n\n\n\n\n\n\n\n\n\n图 4.2 TIM2&3 配置\n\n\n使能 NVIC 中断。\n\n\n\n图 4.3 NVIC 使能\n\n\n配置 GPIO 向 LED 灯输出高低电平。（同 例程 1：使用 GPIO 点灯 第 2 步）\n\n\n\n图 4.4 LED 灯引脚配置\n\n\n生成代码。\n\n打开工程文件。按照 Keil5 MDK 通用配置 完成后开始编写代码。\n\n写中断服务函数，需要先找到对应的虚函数。\n\n打开 stm32f4xx_it.c 文件，拉到最下面，可以看到 TIM2、TIM3 的中断服务函数【HAL_TIM_IRQHandler(&amp;htim2)、HAL_TIM_IRQHandler(&amp;htim3)】。随便右键点一个进入定义，来到 stm32f4xx_hal_tim.c 文件中，在【HAL_TIM_IRQHandler()】函数中，有很多复杂的功能，找到定时器中断回调函数【HAL_TIM_PeriodElapsedCallback(htim)】，右键点进定义，将原型拷贝到 main.c 文件中。\n\n开启定时器中断。\n\n打开 stm32f4xxhal_hal_tim.c 文件，（在 400~500 行之间）找到【HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)】函数，将其拷贝到 main.c 文件中，在【main】函数中初始化。\n\n\n打开 main.c 文件。\n① 在【main】函数外重写中断服务函数：\n/* USER CODE BEGIN 0 */void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123;\t/* TIM2--LED0 */\tif(htim-&gt;Instance == TIM2)\t&#123;\t\tHAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);\t&#125;        /* TIM3--LED1 */    if(htim-&gt;Instance == TIM3)    &#123;        HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);    &#125;&#125;/* USER CODE END 0 */\n\n② 在【main】函数中开启定时器中断。\n/* USER CODE BEGIN 2 */HAL_TIM_Base_Start_IT(&amp;htim2);HAL_TIM_Base_Start_IT(&amp;htim3);/* USER CODE END 2 */\n\n下载代码。\n\n\n例程 5：使用定时器输出 PWM 实现呼吸灯要求：在 STM32F429 进行 STM32 应用开发，完成以下功能：\n\n利用 TIM3 输出 PWM 信号，使 LED0、LED1 变成呼吸灯效果。\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置 完成后。将 PB0、PB1 引脚分别设置为 TIM3_CH3、TIM3_CH4。\n\n\n\n图 5.1 LED 灯引脚配置\n\n\n配置 TIM3 的 CH3、CH4，完成后可以看到右边 PB0、PB1 引脚变为绿色。\n\n\n\n图 5.2 TIM3 Channel 配置\n\n\n生成代码。\n\n打开工程文件。按照 Keil5 MDK 通用配置 完成后开始编写代码。\n打开 main.c 文件。在 main 函数中开启 PWM。\n/* USER CODE BEGIN 2 */HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3);HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_4);/* USER CODE END 2 */\n\n输出 PWM。\n/* Infinite loop *//* USER CODE BEGIN WHILE */while (1)&#123;    /** LED0 配置 **/    /* LED0 逐渐熄灭 */    for(uint16_t pwmVal=0; pwmVal&lt;1000; pwmVal++)    &#123;        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_4, pwmVal);        HAL_Delay(1);    &#125;    /* LED0 逐渐点亮 */    for(uint16_t pwmVal=1000; pwmVal&gt;0; pwmVal--)    &#123;        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_4, pwmVal);        HAL_Delay(1);    &#125;    /** LED1 配置 **/    /* LED1 逐渐熄灭 */    for(uint16_t pwmVal=0; pwmVal&lt;1000; pwmVal++)    &#123;        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_3, pwmVal);        HAL_Delay(1);    &#125;    /* LED1 逐渐点亮 */    for(uint16_t pwmVal=1000; pwmVal&gt;0; pwmVal--)    &#123;        __HAL_TIM_SetCompare(&amp;htim3, TIM_CHANNEL_3, pwmVal);        HAL_Delay(1);    &#125;    /* USER CODE END WHILE */    /* USER CODE BEGIN 3 */&#125;/* USER CODE END 3 */\n\n下载代码。\n\n\n例程 6：使用串口通信点灯要求：在 STM32F429IGT6 中进行 STM32 应用开发，完成以下功能。\n\n开机后，向串口 1 发送”Hello World!”。\n串口 1 收到字节指令”0xA1”，打开 LED0（PB1），发送”LED0 Opened!”。\n串口 1 收到字节指令”0xA2”，关闭 LED0（PB0），发送”LED0 Closed!”。\n在串口发送过程中，打开 LED1 作为发送数据指示灯。\n\n步骤：\n\n打开 STM32CubeMX 软件，按照 STM32CubeMX 通用配置配置完成后。将 PB0、PB1 引脚分别设置为 GPIO_Out。接着配置 USART1 的模式、参数及使能中断，中断的优先级设置为 1，如图所示：\n\n\n\n图 6.1 串口 USART1 配置\n\n\n\n图 6.2 使能 USART1 中断\n\n\n生成代码。\n\n打开工程文件。按照 Keil5 MDK 通用配置 完成后开始编写代码。\n\n打开 usart1.c 文件，可以看到 huart1 的配置。\n\n\n图 6.3 USART1 的代码初始化\n\n打开 main.c 文件。\n-----------------------↓↓↓注：main() 函数外↓↓↓----------------------- /* USER CODE BEGIN 0 *//* 宏定义 LED0、LED1 亮灭 */#define LED0_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);#define LED0_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);#define LED1_ON() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);#define LED1_OFF() HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);/* 首先定义了无符号 8 位整数型（unsigned 8-bit integer）数组的语句，常用于表示一串 ASCII 字符。其中，Tx_str1 是数组的名称，方括号中没有指定数组长度，因此该数组长度将根据初始化时赋值的元素个数进行确定 */uint8_t Tx_str1[] = &quot;Hello World!\\r\\n&quot;; // \\r：回车，\\n：换行uint8_t Tx_str2[] = &quot;LED1 Opened!\\r\\n&quot;;uint8_t Tx_str3[] = &quot;LED1 Closed!\\r\\n&quot;;/* 定义了一个无符号8位整数型（unsigned 8-bit integer）变量,通常用于存储通过UART接收到的单个字节数据，每次接收完成后将数据存储到该变量中 */uint8_t Rx_dat = 0;/* 中断回调函数, 在这里面实现接收到指令后的功能*/void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123;\tif(huart-&gt;Instance == USART1)\t&#123;\t\tif(Rx_dat == 0xa1)\t\t&#123;\t\t\tLED0_ON();\t\t\t            /* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */\t\t\tLED1_OFF();\t\t\tHAL_Delay(200);\t\t\tHAL_UART_Transmit(&amp;huart1, Tx_str2, sizeof(Tx_str2), 10000);\t\t\tHAL_Delay(200);\t\t\tLED1_ON();\t\t\t\t\t\tHAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);\t\t&#125;\t\telse if(Rx_dat == 0xa2)\t\t&#123;\t\t\tLED0_OFF();\t\t\t            /* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */\t\t\tLED1_OFF();\t\t\tHAL_Delay(200);\t\t\tHAL_UART_Transmit(&amp;huart1, Tx_str3, sizeof(Tx_str3), 10000);\t\t\tHAL_Delay(200);\t\t\tLED1_ON();\t\t\t\t\t\tHAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);\t\t&#125;\t&#125;&#125;/* USER CODE END 0 */-----------------------↓↓↓注：main() 函数内↓↓↓----------------------- /* USER CODE BEGIN 2 *//* 功能 1：开机后向串口 1 发送 “Hello World!” *//* LED1 作为指示灯，先设置高电平灭掉，然后发送数据，再点亮 */LED1_OFF();HAL_Delay(200); //加入延时函数，以便肉眼观察得到HAL_UART_Transmit(&amp;huart1, Tx_str1, sizeof(Tx_str1), 10000);HAL_Delay(200); //加入延时函数，以便肉眼观察得到LED1_ON();/* 功能 2、3：接收串口发来的数据” *//* &amp;huart1 表示指向 UART1 外设的指针，&amp;Rx_dat 表示指向存储接收数据的缓冲区的指针， 1 表示要接收的数据长度 */HAL_UART_Receive_IT(&amp;huart1, &amp;Rx_dat, 1);/* USER CODE END 2 */  \n\n\n串口调试助手操作要点\n\nMicroUSB 接口要接到板子的左下角第二个口，写着 USB_232。才会显示 COM4：USB-SERIAL。COM3 不能用于串口调试。\n波特率要和 CubeMX 中设置的一致。\n在发送框中输入程序中所写的字符串，然后选择 16 进制发送。\n\n\n\n\n\n\n图 6.4 功能实现\n\n参考[1] STM32CubeMX-Keil 通用配置 | Story Begins…… \n","categories":["STM32"],"tags":["TIM","USART","ADC","GPIO"]}]